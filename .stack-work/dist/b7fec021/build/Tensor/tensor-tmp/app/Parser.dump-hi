
==================== FINAL INTERFACE ====================
2017-01-18 22:15:32.1821641 UTC

interface main@main:Main 8001
  interface hash: 4f737c9dc1a3170e7aaad2a9d3e0cd14
  ABI hash: d546fb44654007d7e204ba6788d5a11c
  export-list hash: 2ed5975a5f0984820ef73a8f8b4efb82
  orphan hash: 4bda42b802a9964cdf4a1e2755134db4
  flag hash: 0fc2fde570e4d4f28d78a18cba230ff0
  sig of: Nothing
  used TH splices: False
  where
exports:
  Main.happyAccept
  Main.happyActOffsets
  Main.happyCheck
  Main.happyDefActions
  Main.happyDoAction
  Main.happyDoSeq
  Main.happyDontSeq
  Main.happyDrop
  Main.happyDropStk
  Main.happyError'
  Main.happyError_
  Main.happyFail
  Main.happyGoto
  Main.happyGotoOffsets
  Main.happyIn10
  Main.happyIn11
  Main.happyIn12
  Main.happyIn13
  Main.happyIn14
  Main.happyIn4
  Main.happyIn5
  Main.happyIn6
  Main.happyIn7
  Main.happyIn8
  Main.happyIn9
  Main.happyInTok
  Main.happyMonad2Reduce
  Main.happyMonadReduce
  Main.happyNewToken
  Main.happyOut10
  Main.happyOut11
  Main.happyOut12
  Main.happyOut13
  Main.happyOut14
  Main.happyOut4
  Main.happyOut5
  Main.happyOut6
  Main.happyOut7
  Main.happyOut8
  Main.happyOut9
  Main.happyOutTok
  Main.happyParse
  Main.happyReduce
  Main.happyReduceArr
  Main.happyReduce_1
  Main.happyReduce_10
  Main.happyReduce_11
  Main.happyReduce_12
  Main.happyReduce_13
  Main.happyReduce_14
  Main.happyReduce_15
  Main.happyReduce_16
  Main.happyReduce_17
  Main.happyReduce_18
  Main.happyReduce_19
  Main.happyReduce_2
  Main.happyReduce_20
  Main.happyReduce_21
  Main.happyReduce_22
  Main.happyReduce_23
  Main.happyReduce_24
  Main.happyReduce_25
  Main.happyReduce_26
  Main.happyReduce_27
  Main.happyReduce_28
  Main.happyReduce_29
  Main.happyReduce_3
  Main.happyReduce_4
  Main.happyReduce_5
  Main.happyReduce_6
  Main.happyReduce_7
  Main.happyReduce_8
  Main.happyReduce_9
  Main.happyReduction_1
  Main.happyReduction_10
  Main.happyReduction_11
  Main.happyReduction_12
  Main.happyReduction_13
  Main.happyReduction_14
  Main.happyReduction_15
  Main.happyReduction_16
  Main.happyReduction_17
  Main.happyReduction_18
  Main.happyReduction_19
  Main.happyReduction_2
  Main.happyReduction_20
  Main.happyReduction_21
  Main.happyReduction_22
  Main.happyReduction_23
  Main.happyReduction_24
  Main.happyReduction_25
  Main.happyReduction_26
  Main.happyReduction_27
  Main.happyReduction_28
  Main.happyReduction_29
  Main.happyReduction_3
  Main.happyReduction_4
  Main.happyReduction_5
  Main.happyReduction_6
  Main.happyReduction_7
  Main.happyReduction_8
  Main.happyReduction_9
  Main.happyReturn
  Main.happyReturn1
  Main.happySeq
  Main.happyShift
  Main.happySpecReduce_0
  Main.happySpecReduce_1
  Main.happySpecReduce_2
  Main.happySpecReduce_3
  Main.happyTable
  Main.happyTcHack
  Main.happyThen
  Main.happyThen1
  Main.happy_n_nonterms
  Main.happy_n_terms
  Main.indexShortOffAddr
  Main.main
  Main.neurol
  Main.notHappyAtAll
  Main.parseError
  Main.repl
  Main.HappyAbsSyn{Main.HappyAbsSyn}
  Main.HappyAddr{Main.HappyA#}
  Main.HappyAny
  Main.HappyStk{Main.HappyStk}
  Main.Happy_IntList{Main.HappyCons}
module dependencies: Lekser
package dependencies: Tensor-0.1.0.0@Tensor-0.1.0.0-K5QdifOX00t2w9C27ImRWh
                      Win32-2.3.1.1@Win32-2.3.1.1 array-0.5.1.1@array-0.5.1.1
                      base-4.9.0.0 binary-0.8.3.0@binary-0.8.3.0
                      bytestring-0.10.8.1@bytestring-0.10.8.1
                      containers-0.5.7.1@containers-0.5.7.1
                      deepseq-1.4.2.0@deepseq-1.4.2.0 directory-1.2.6.2@directory-1.2.6.2
                      filepath-1.4.1.0@filepath-1.4.1.0 ghc-prim-0.5.0.0
                      integer-gmp-1.0.0.1 time-1.6.0.1@time-1.6.0.1
                      zlib-0.6.1.2@zlib-0.6.1.2-4CWLN1T27kOJhNvXgy46ZV
orphans: base-4.9.0.0:GHC.Base base-4.9.0.0:GHC.Float
         binary-0.8.3.0@binary-0.8.3.0:Data.Binary.Generic
         bytestring-0.10.8.1@bytestring-0.10.8.1:Data.ByteString.Builder
         time-1.6.0.1@time-1.6.0.1:Data.Time.Calendar.Gregorian
         time-1.6.0.1@time-1.6.0.1:Data.Time.Format.Parse
         time-1.6.0.1@time-1.6.0.1:Data.Time.LocalTime.LocalTime
family instance modules: base-4.9.0.0:Control.Applicative
                         base-4.9.0.0:Data.Complex base-4.9.0.0:Data.Either
                         base-4.9.0.0:Data.Functor.Const base-4.9.0.0:Data.Functor.Identity
                         base-4.9.0.0:Data.List.NonEmpty base-4.9.0.0:Data.Monoid
                         base-4.9.0.0:Data.Semigroup base-4.9.0.0:Data.Type.Equality
                         base-4.9.0.0:Data.Version base-4.9.0.0:Data.Void
                         base-4.9.0.0:GHC.Exts base-4.9.0.0:GHC.Generics
                         base-4.9.0.0:GHC.IO.Exception base-4.9.0.0:GHC.TypeLits
                         containers-0.5.7.1@containers-0.5.7.1:Data.IntMap.Base
                         containers-0.5.7.1@containers-0.5.7.1:Data.IntSet.Base
                         containers-0.5.7.1@containers-0.5.7.1:Data.Map.Base
                         containers-0.5.7.1@containers-0.5.7.1:Data.Sequence
                         containers-0.5.7.1@containers-0.5.7.1:Data.Set.Base
                         zlib-0.6.1.2@zlib-0.6.1.2-4CWLN1T27kOJhNvXgy46ZV:Codec.Compression.Zlib.Stream
import  -/  Tensor-0.1.0.0@Tensor-0.1.0.0-K5QdifOX00t2w9C27ImRWh:Tensor 254e68f7279f60998a78ead71fab707f
import  -/  Tensor-0.1.0.0@Tensor-0.1.0.0-K5QdifOX00t2w9C27ImRWh:Tensor.Index 6bdc44f3d1849d0934612a9de4da6cc7
import  -/  Tensor-0.1.0.0@Tensor-0.1.0.0-K5QdifOX00t2w9C27ImRWh:Tensor.Multilinear 300bb48a7ab08cf6176b08c588ef5d7b
import  -/  Tensor-0.1.0.0@Tensor-0.1.0.0-K5QdifOX00t2w9C27ImRWh:Tensor.Restricted 77c62fd08cbd093b6fbf31f6d01553ff
import  -/  array-0.5.1.1@array-0.5.1.1:Data.Array 01310623526f8acc73d1bb69e9d9530a
import  -/  base-4.9.0.0:Control.Applicative fdcece230f8af145aec7b432bfe73083
import  -/  base-4.9.0.0:Control.Monad b6b2f076948b5e8acd6d95beb4d22bfc
import  -/  base-4.9.0.0:Data.Either 4cef602ce360a0155ac0dd580a5b4863
import  -/  base-4.9.0.0:Data.Maybe 086a84053ef7f7810663b5f03b7ec3f7
import  -/  base-4.9.0.0:GHC.Arr 5b2eaa2ae8ea7c2b81f0c13a6f0fb75d
import  -/  base-4.9.0.0:GHC.Base dd8044a8d640eee51828c17c476a6ba7
import  -/  base-4.9.0.0:GHC.Err 20faef8829fd13c027d0ee2213637534
import  -/  base-4.9.0.0:GHC.Exts 8dde1ef8f2283d1c13b06a4e51aded72
import  -/  base-4.9.0.0:GHC.Float a46e197015eefaa013d7004e58481c54
import  -/  base-4.9.0.0:GHC.IO.Handle 0ec5f3e063751c91152d6f1b0286ca9a
import  -/  base-4.9.0.0:GHC.IO.Handle.FD 5311a39f33255d27517e14bdb344dca6
import  -/  base-4.9.0.0:GHC.Num f0aed3315b3ed1b330b71fc4148a5581
import  -/  base-4.9.0.0:GHC.Real 011de9ca3282ad24a84e4e15f974f98e
import  -/  base-4.9.0.0:GHC.Show 0b5845243cb2ec62b57dd6963d276ec6
import  -/  base-4.9.0.0:Prelude 2d9cd8b0ec3d728f62b734df888d2e34
import  -/  base-4.9.0.0:System.Exit 7cf768f13668f85ae54602581633c241
import  -/  base-4.9.0.0:System.IO c1068c4f4231e3198e330f99a58145b0
import  -/  binary-0.8.3.0@binary-0.8.3.0:Data.Binary 6874ec1640b9c9e26e0b523287f2c847
import  -/  bytestring-0.10.8.1@bytestring-0.10.8.1:Data.ByteString.Lazy 19646d445c770f98ae8d9258dfe37061
import  -/  containers-0.5.7.1@containers-0.5.7.1:Data.Map.Base d6db6ac95571c976686f97c64548b060
import  -/  containers-0.5.7.1@containers-0.5.7.1:Data.Map.Strict 81f15caf07282f1c84ab3ccc8bbe2604
import  -/  directory-1.2.6.2@directory-1.2.6.2:System.Directory 6ab32ada667d61db0e6e44603c58043c
import  -/  ghc-prim-0.5.0.0:GHC.Classes 16d48e012d23eaef9bca91ccdd572c02
import  -/  ghc-prim-0.5.0.0:GHC.Types 7378e41b7749213c8c88ceb6b0665d4c
import  -/  Lekser 09e5f9e41d812e741fe16be2a574336f
  exports: 63ec72f37d94669abd9f174c9a3a8696
  All 4c1cd016a3c761751333acac63152d3f
  As 18eb48cbb4b8167a359f24220d85e140
  AssignOperator e8e1b80b24519a6b5e837bbff3fb681c
  Binds e71738226ce6cb9f42cc436e2724754c
  Boolean fa915986707e3754f699aed520a34097
  Clear 44cdcd2d5b4870abae2072b5fedaedce
  CloseBlock 5facd823f88c68b0376bbb0b8cebdc5b
  ClosingBracket ef4a0d3e59e70e1926674a2c18e6cc55
  Colon 9612118cf58eaab58f3ec20d6e0bc6f4
  Comma af2bfc9a66a09691e5c1eb8914c84e02
  ConnectOperator 68970cce1ab480f2af788b1f6d7e41e4
  ContravariantClose a5fc556770edf0b306f0254603ad2204
  ContravariantOpen 35116479d333dda1651e78f1c1e94284
  CovariantClose 033282cfef121a090a85194263502a5a
  CovariantOpen 6dcf65b1d34ce9f2be0cb972628f8bc0
  Dot cf918ee9d8bd68ecb7d162a600b62859
  Else 26aa8fa1cf955fe2cfd841500434a798
  Exit 873a2fe187ea3f31f024bd0bff0b37f4
  Experiment d3d6cb9eebaa93fd8c10c18f37af2d0c
  FilePath c9581ade969f9f80bdbac6772b3366e1
  First bacbde8f46523e968a3a8cf035117f6d
  From 09073f5c2dcbfc2d5267a46e1fd206d4
  Get 5f4e5f86952c7c7205e3fe1fa396a164
  Guard ba944334cb2494c2c56b95cfb8d1a236
  If 7491daae7151b843a29e9d5bc42f62b2
  Import 1bbc1836e91535ac51807eae8d5ce949
  Index fce1db616a0d3bd136fc7fa619fb4a82
  InfiksAddBool 0fedd3a2d50cc2f9a9f4b427943465dc
  InfiksAddNum 9902a83d7c1c703df36b83d7191847fd
  InfiksComp e9f8294a935f61ea0079763ff0a0c10d
  InfiksMultBool c92621bc97870e29ffd87ffc6a8e4a3f
  InfiksMultNum 3e6c1dee16e7818bb586726e4b02ce8c
  InfiksPowNum 7e0e11ba47493c68c7fec0ecef0ebf86
  Input e0949f2ad6d26de06a882a3b53a88d72
  Integer 1275f12a34ef09b36665fe854b1ed157
  Interpolation 2764b16f0d8905d613e237d2e85bfb47
  Layer e2011a5854e8e94ca8f565bfa0ddec29
  Learn 7aaf74443cb289e3c9f6306137c7ffa8
  Learning af8cb167bd46c1afb0a823402962cb98
  LearningType d59cf0848a5f31c0c8b01ed984db88be
  Maxtime cbeae1f5dbd4ef9a614dbd1fdc8beb4d
  Module fca670ab248e1146612deeaea4e0a11c
  Name 3fa42edc9676a69affa0f1122573359a
  Natural 0a6848544407663a98b8782831213c43
  Negate 722fa5d88680ad18fad3e32dd244afa2
  Network 7f77fec9218897df64ca1b99bfdcce83
  NormBinary 7eaeaadd17ec8b778c4ff7063564825f
  NormUnary 81874e904b6bfad939cc026f8c1addec
  OpenBlock 012e2ad5aa4d37ee1200d48382f1d3b4
  OpeningBracket 3b1f71f553363f21233ce3eeb6bdd40f
  PrefiksBinary a658c7b555d24f590c00ecacd1710962
  PrefiksBoolNeg ddf4da5ce6c245b3448c7d980fc8cd8e
  PrefiksUnary a0f0a32ddade5db7370b73923ac1e4ea
  Quantifier 122a53f81815d9649b4a61f9f07671a8
  Real a37f83d6f84241a9e7082645758e10ae
  Semicolon d2a159fb3ef044f49c243d19665cdee0
  TensUnary 0f1a08660fc17fca48317a80bb0107b0
  TensorProduct 9b0c41196fd96bc40026f7846efbe10d
  Then 43c4359dc6e54e86c86b5a68be3b33c0
  Time c4788ac970987d6c5439730b04a560ad
  Token 80ec8abd7ecd5bfa04be43f61c84ea3a
  alexScanTokens ebdcc711871ef625069e0115c8ae20fb
import  -/  zlib-0.6.1.2@zlib-0.6.1.2-4CWLN1T27kOJhNvXgy46ZV:Codec.Compression.GZip dcaaf1ee484aeb9c38a74bee29c3b634
addDependentFile "C:\Program Files\Haskell Platform\8.0.1\lib\include\ghcversion.h"
addDependentFile ".stack-work\dist\b7fec021\build\autogen\cabal_macros.h"
fixities infixr 9 HappyStk, infixr 9 HappyStk
07eb32af07dfd55c1aa5aa16bb84436b
  $s$fBinaryMap ::
    Data.Binary.Class.Binary
      (Data.Map.Base.Map
         [GHC.Types.Char] (Tensor.Restricted.Tensor GHC.Types.Double))
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ (Data.Map.Base.Map
                       [GHC.Types.Char] (Tensor.Restricted.Tensor GHC.Types.Double))
                  (Data.Binary.Class.$fBinaryMap_$cput
                     @ [GHC.Types.Char]
                     @ (Tensor.Restricted.Tensor GHC.Types.Double)
                     Data.Binary.Class.$fBinaryVersion_$s$fBinary[]
                     Main.$s$fBinaryMap_$dBinary1)
                  (Data.Binary.Class.$fBinaryMap_$cget
                     @ [GHC.Types.Char]
                     @ (Tensor.Restricted.Tensor GHC.Types.Double)
                     Data.Binary.Class.$fBinaryVersion_$s$fBinary[]
                     Main.$s$fBinaryMap_$dBinary1)
                  (Data.Binary.Class.$fBinaryMap_$cputList
                     @ [GHC.Types.Char]
                     @ (Tensor.Restricted.Tensor GHC.Types.Double)
                     Data.Binary.Class.$fBinaryVersion_$s$fBinary[]
                     Main.$s$fBinaryMap_$dBinary1) -}
465cb7bfbb0b489f0ff5dc15323fd99e
  $s$fBinaryMap_$dBinary1 ::
    Data.Binary.Class.Binary
      (Tensor.Restricted.Tensor GHC.Types.Double)
  {- Strictness: m,
     Unfolding: InlineRule (0, True, True)
                Main.$s$fBinaryMap_$s$fBinaryTensor -}
65be664800a18036e316edb3e766aa2b
  $s$fBinaryMap_$s$fBinaryTensor ::
    Data.Binary.Class.Binary
      (Tensor.Restricted.Tensor GHC.Types.Double)
  {- Strictness: m,
     Unfolding: DFun:.
                  @ (Tensor.Restricted.Tensor GHC.Types.Double)
                  (Tensor.Restricted.$fBinaryTensor_$cput
                     @ GHC.Types.Double
                     Data.Binary.Class.$fBinaryDouble)
                  (Tensor.Restricted.$fBinaryTensor_$cget
                     @ GHC.Types.Double
                     Data.Binary.Class.$fBinaryDouble)
                  (Tensor.Restricted.$fBinaryTensor_$cputList
                     @ GHC.Types.Double
                     Data.Binary.Class.$fBinaryDouble) -}
f078c103867fc20b8561e5f888340a0b
  $sdelete_$sgo10 ::
    forall {a1}.
    GHC.Base.String
    -> Data.Map.Base.Map GHC.Base.String a1
    -> Data.Map.Base.Map GHC.Base.String a1
  {- Arity: 2, Strictness: <S,1*U><S,1*U> -}
1b851eb57e86f30e289489aeacfae728
  $sinsert_$sgo4 ::
    forall {a1}.
    GHC.Base.String
    -> a1
    -> Data.Map.Base.Map GHC.Base.String a1
    -> Data.Map.Base.Map GHC.Base.String a1
  {- Arity: 3, Strictness: <S,1*U><S,1*U><S,1*U> -}
0d3fcd1cbc27a36ce86d648a0f6ff230
  $slookup1 ::
    forall {a}.
    GHC.Base.String
    -> Data.Map.Base.Map GHC.Base.String a -> GHC.Base.Maybe a
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U> -}
580f64ac1ba30532f344608fb0790e73
  $tc'HappyA# :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   9424879793818794372##
                   16851866178419054929##
                   Main.$trModule
                   Main.$tc'HappyA#1) -}
14419e03e4f6e4fb23bd083c3958aa96
  $tc'HappyA#1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "'HappyA#"#) -}
51498e155a03c58669249da7d0a60866
  $tc'HappyAbsSyn :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   5577092161638755018##
                   7383997426664865597##
                   Main.$trModule
                   Main.$tc'HappyAbsSyn1) -}
2f2ec4104e813042cbb553f8412b5e5b
  $tc'HappyAbsSyn1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "'HappyAbsSyn"#) -}
ee9252847d3ec60ebe2e1a09fc0e9cbf
  $tc'HappyCons :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   15394472158021912168##
                   12142348159076597809##
                   Main.$trModule
                   Main.$tc'HappyCons1) -}
1a716616ff4e757bd7c39aa70b762706
  $tc'HappyCons1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "'HappyCons"#) -}
566279f94b2f3fa49ce6ba67c0e7fff4
  $tc'HappyStk :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   11302484882872923411##
                   14324382004866540344##
                   Main.$trModule
                   Main.$tc'HappyStk1) -}
8d1ee9464ef6faa6da537ad795c0c44e
  $tc'HappyStk1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "'HappyStk"#) -}
3c45bf0b3fb7fb547e78454df83da94f
  $tcHappyAbsSyn :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   13669151835032000741##
                   10516042063568819094##
                   Main.$trModule
                   Main.$tcHappyAbsSyn1) -}
886a0f1daedc547ed8993decc592f6ae
  $tcHappyAbsSyn1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "HappyAbsSyn"#) -}
b9028c24c1f816312b79d20572fe0038
  $tcHappyAddr :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   8429803494278121073##
                   2452950358151784357##
                   Main.$trModule
                   Main.$tcHappyAddr1) -}
9ccd1252b76bb25f6b2dc87d244e7b88
  $tcHappyAddr1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "HappyAddr"#) -}
d7d32c9457d42b6b3059cf3b953e2716
  $tcHappyStk :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   5383813221183880011##
                   9183106103316850234##
                   Main.$trModule
                   Main.$tcHappyStk1) -}
c281745400b1cc171f9d7552e4f1781f
  $tcHappyStk1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "HappyStk"#) -}
a8ce6cb20ff96b69316f44cb641ab41a
  $tcHappy_IntList :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   6038899332760454989##
                   9316175232351891502##
                   Main.$trModule
                   Main.$tcHappy_IntList1) -}
6a13424d8ecb241945df295b6da6c19d
  $tcHappy_IntList1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "Happy_IntList"#) -}
d6831ef04cb9301b090dfae6f7bb7ec7
  $trModule :: GHC.Types.Module
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.Module Main.$trModule2 Main.$trModule1) -}
847d9fc3b8e6f0b424199f36b4999bb2
  $trModule1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "Main"#) -}
24ef6042833e75ffd7aa98b83ecca98d
  $trModule2 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "main"#) -}
565d215a96a3ff28cba327e048448b87
  $wgo1 ::
    GHC.Prim.Int#
    -> Data.ByteString.Lazy.Internal.ByteString -> GHC.Prim.Int#
  {- Arity: 2, HasNoCafRefs, Strictness: <L,U><S,1*U>, Inline: [0] -}
dc530f923a33b352ce02ab292a0169c5
  $whappyReduction_14 ::
    forall {t} {t4} {t1}.
    Main.HappyAbsSyn t4
    -> Data.Map.Base.Map
         GHC.Base.String (Tensor.Restricted.Tensor GHC.Types.Double)
    -> GHC.Base.Maybe (Tensor.Restricted.Tensor GHC.Types.Double)
  {- Arity: 2, Strictness: <S,1*U><L,U>, Inline: [0],
     Unfolding: (\ @ t
                   @ t4
                   @ t1
                   (w :: Main.HappyAbsSyn t4)
                   (w1 :: Data.Map.Base.Map
                            GHC.Base.String (Tensor.Restricted.Tensor GHC.Types.Double)) ->
                 case w `cast`
                      (UnsafeCo representational (Main.HappyAbsSyn t4) (Data.Map.Base.Map
                                                                          GHC.Base.String
                                                                          (Tensor.Restricted.Tensor
                                                                             GHC.Types.Double)
                                                                        -> GHC.Base.Maybe
                                                                             (Tensor.Restricted.Tensor
                                                                                GHC.Types.Double)))
                        w1 of wild {
                   GHC.Base.Nothing
                   -> GHC.Base.Nothing @ (Tensor.Restricted.Tensor GHC.Types.Double)
                   GHC.Base.Just x
                   -> GHC.Base.Just
                        @ (Tensor.Restricted.Tensor GHC.Types.Double)
                        (Tensor.Restricted.$fFloatingTensor26
                           @ GHC.Types.Double
                           GHC.Float.$fNumDouble
                           Main.happyReduction_43
                           x) }) -}
3edb48a843003b6288afdde1f74dd90c
  $whappyReduction_2 ::
    forall {t} {t4} {t1} {t2}.
    Main.HappyAbsSyn t1 -> Main.HappyAbsSyn t4 -> Main.HappyAbsSyn t2
  {- Arity: 2, Strictness: <L,U><S,1*U>, Inline: [0],
     Unfolding: (\ @ t
                   @ t4
                   @ t1
                   @ t2
                   (w :: Main.HappyAbsSyn t1)
                   (w1 :: Main.HappyAbsSyn t4) ->
                 case w1
                        `cast`
                      (UnsafeCo representational (Main.HappyAbsSyn
                                                    t4) Lekser.Token) of wild {
                   DEFAULT -> Main.happyReduction_57 @ t2
                   Lekser.Name happy_var_1
                   -> let {
                        lvl40 :: [GHC.Types.Char]
                        = GHC.Base.++ @ GHC.Types.Char happy_var_1 Main.happyReduction_56
                      } in
                      (\ (ts :: Data.Map.Base.Map
                                  GHC.Base.String (Tensor.Restricted.Tensor GHC.Types.Double))
                         (eta :: GHC.Prim.State# GHC.Prim.RealWorld)[OneShot] ->
                       case w `cast`
                            (UnsafeCo representational (Main.HappyAbsSyn t1) (Data.Map.Base.Map
                                                                                GHC.Base.String
                                                                                (Tensor.Restricted.Tensor
                                                                                   GHC.Types.Double)
                                                                              -> GHC.Base.Maybe
                                                                                   (Tensor.Restricted.Tensor
                                                                                      GHC.Types.Double)))
                              ts of wild1 {
                         GHC.Base.Nothing
                         -> case GHC.IO.Handle.Text.hPutStr2
                                   GHC.IO.Handle.FD.stdout
                                   Main.happyReduction_55
                                   GHC.Types.True
                                   eta of ds1 { (#,#) ipv ipv1 ->
                            (# ipv, ts #) }
                         GHC.Base.Just ipv
                         -> case Tensor.Restricted.$wds
                                   @ GHC.Types.Double
                                   ipv of ww { DEFAULT ->
                            let {
                              $w$j :: GHC.Prim.State# GHC.Prim.RealWorld
                                      -> (# GHC.Prim.State# GHC.Prim.RealWorld,
                                            Data.Map.Base.Map
                                              GHC.Base.String
                                              (Tensor.Restricted.Tensor GHC.Types.Double) #)
                                {- Arity: 1, Strictness: <S,U>, Inline: [0] -}
                              = \ (w2 :: GHC.Prim.State# GHC.Prim.RealWorld)[OneShot] ->
                                let {
                                  $w$j1 :: GHC.Prim.State# GHC.Prim.RealWorld
                                           -> (# GHC.Prim.State# GHC.Prim.RealWorld,
                                                 Data.Map.Base.Map
                                                   GHC.Base.String
                                                   (Tensor.Restricted.Tensor GHC.Types.Double) #)
                                    {- Arity: 1, Strictness: <S,U>, Inline: [0] -}
                                  = \ (w3 :: GHC.Prim.State# GHC.Prim.RealWorld)[OneShot] ->
                                    let {
                                      ts' :: Data.Map.Base.Map
                                               GHC.Base.String
                                               (Tensor.Restricted.Tensor GHC.Types.Double)
                                      = Main.$sinsert_$sgo4
                                          @ (Tensor.Restricted.Tensor GHC.Types.Double)
                                          happy_var_1
                                          ipv
                                          ts
                                    } in
                                    case Control.Exception.Base.bracket1
                                           @ GHC.IO.Handle.Types.Handle
                                           @ ()
                                           @ ()
                                           Main.happyReduction_54
                                             `cast`
                                           (Sym (GHC.Types.N:IO[0] <GHC.IO.Handle.Types.Handle>_R))
                                           GHC.IO.Handle.hClose1
                                             `cast`
                                           (<GHC.IO.Handle.Types.Handle>_R
                                            ->_R Sym (GHC.Types.N:IO[0] <()>_R))
                                           (\ (hdl :: GHC.IO.Handle.Types.Handle)[OneShot]
                                              (eta1 :: GHC.Prim.State#
                                                         GHC.Prim.RealWorld)[OneShot] ->
                                            Data.ByteString.Lazy.appendFile2
                                              hdl
                                              (Codec.Compression.Zlib.Internal.foldCompressStreamWithInput
                                                 @ Data.ByteString.Lazy.Internal.ByteString
                                                 Data.ByteString.Lazy.Internal.$WChunk
                                                 Data.ByteString.Lazy.Internal.Empty
                                                 Codec.Compression.GZip.compress1
                                                 (Data.ByteString.Builder.toLazyByteString
                                                    (case Data.Binary.Class.$w$cput18
                                                            @ [GHC.Types.Char]
                                                            @ (Tensor.Restricted.Tensor
                                                                 GHC.Types.Double)
                                                            Data.Binary.Class.$fBinaryVersion_$s$fBinary[]
                                                            Main.$s$fBinaryMap_$s$fBinaryTensor
                                                            ts' of ww1 { (#,#) ww2 ww3 ->
                                                     ww3 })))
                                              eta1)
                                             `cast`
                                           (<GHC.IO.Handle.Types.Handle>_R
                                            ->_R Sym (GHC.Types.N:IO[0] <()>_R))
                                           w3 of ds1 { (#,#) ipv1 ipv2 ->
                                    case GHC.IO.Handle.Text.hPutStr2
                                           GHC.IO.Handle.FD.stdout
                                           lvl40
                                           GHC.Types.True
                                           ipv1 of ds2 { (#,#) ipv3 ipv4 ->
                                    (# ipv3, ts' #) } }
                                } in
                                case GHC.Prim.tagToEnum#
                                       @ GHC.Types.Bool
                                       (GHC.Prim.># ww 100000#) of wild2 {
                                  GHC.Types.False -> $w$j1 w2
                                  GHC.Types.True
                                  -> case GHC.IO.Handle.Text.hPutStr2
                                            GHC.IO.Handle.FD.stdout
                                            Main.happyReduction_53
                                            GHC.Types.True
                                            w2 of ds1 { (#,#) ipv1 ipv2 ->
                                     $w$j1 ipv1 } }
                            } in
                            case GHC.Prim.tagToEnum#
                                   @ GHC.Types.Bool
                                   (GHC.Prim.># ww 100000#) of wild2 {
                              GHC.Types.False -> $w$j eta
                              GHC.Types.True
                              -> case GHC.IO.Handle.Text.hPutStr2
                                        GHC.IO.Handle.FD.stdout
                                        Main.happyReduction_52
                                        GHC.Types.True
                                        eta of ds1 { (#,#) ipv1 ipv2 ->
                                 $w$j ipv1 } } } })
                        `cast`
                      (Trans
                           (<Data.Map.Base.Map
                               GHC.Base.String (Tensor.Restricted.Tensor GHC.Types.Double)>_R
                            ->_R Sym (GHC.Types.N:IO[0]
                                          <Data.Map.Base.Map
                                             GHC.Base.String
                                             (Tensor.Restricted.Tensor GHC.Types.Double)>_R))
                           (UnsafeCo representational (Data.Map.Base.Map
                                                         GHC.Base.String
                                                         (Tensor.Restricted.Tensor GHC.Types.Double)
                                                       -> GHC.Types.IO
                                                            (Data.Map.Base.Map
                                                               GHC.Base.String
                                                               (Tensor.Restricted.Tensor
                                                                  GHC.Types.Double))) (Main.HappyAbsSyn
                                                                                         t2))) }) -}
92f429a9385180e5e0802f2c96b7460b
  $whappyReduction_7 ::
    forall {t} {t4} {t1}. Main.HappyAbsSyn t4 -> Main.HappyAbsSyn t1
  {- Arity: 1, Strictness: <S,1*U>, Inline: [0],
     Unfolding: (\ @ t @ t4 @ t1 (w :: Main.HappyAbsSyn t4) ->
                 case w `cast`
                      (UnsafeCo representational (Main.HappyAbsSyn
                                                    t4) Lekser.Token) of wild {
                   DEFAULT -> Main.happyReduction_79 @ t1
                   Lekser.Name happy_var_2
                   -> let {
                        lvl40 :: [GHC.Types.Char]
                        = GHC.CString.unpackAppendCString#
                            "Variable "#
                            (GHC.Base.++ @ GHC.Types.Char happy_var_2 Main.happyReduction_78)
                      } in
                      (\ (ts :: Data.Map.Base.Map
                                  GHC.Base.String (Tensor.Restricted.Tensor GHC.Types.Double))
                         (eta :: GHC.Prim.State# GHC.Prim.RealWorld)[OneShot] ->
                       let {
                         ts' :: Data.Map.Base.Map
                                  GHC.Base.String (Tensor.Restricted.Tensor GHC.Types.Double)
                         = Main.$sdelete_$sgo10
                             @ (Tensor.Restricted.Tensor GHC.Types.Double)
                             happy_var_2
                             ts
                       } in
                       case Control.Exception.Base.bracket1
                              @ GHC.IO.Handle.Types.Handle
                              @ ()
                              @ ()
                              Main.happyReduction_54
                                `cast`
                              (Sym (GHC.Types.N:IO[0] <GHC.IO.Handle.Types.Handle>_R))
                              GHC.IO.Handle.hClose1
                                `cast`
                              (<GHC.IO.Handle.Types.Handle>_R
                               ->_R Sym (GHC.Types.N:IO[0] <()>_R))
                              (\ (hdl :: GHC.IO.Handle.Types.Handle)[OneShot]
                                 (eta1 :: GHC.Prim.State# GHC.Prim.RealWorld)[OneShot] ->
                               Data.ByteString.Lazy.appendFile2
                                 hdl
                                 (Codec.Compression.Zlib.Internal.foldCompressStreamWithInput
                                    @ Data.ByteString.Lazy.Internal.ByteString
                                    Data.ByteString.Lazy.Internal.$WChunk
                                    Data.ByteString.Lazy.Internal.Empty
                                    Codec.Compression.GZip.compress1
                                    (Data.ByteString.Builder.toLazyByteString
                                       (case Data.Binary.Class.$w$cput18
                                               @ [GHC.Types.Char]
                                               @ (Tensor.Restricted.Tensor GHC.Types.Double)
                                               Data.Binary.Class.$fBinaryVersion_$s$fBinary[]
                                               Main.$s$fBinaryMap_$s$fBinaryTensor
                                               ts' of ww { (#,#) ww1 ww2 ->
                                        ww2 })))
                                 eta1)
                                `cast`
                              (<GHC.IO.Handle.Types.Handle>_R
                               ->_R Sym (GHC.Types.N:IO[0] <()>_R))
                              eta of ds1 { (#,#) ipv ipv1 ->
                       case GHC.IO.Handle.Text.hPutStr2
                              GHC.IO.Handle.FD.stdout
                              lvl40
                              GHC.Types.True
                              ipv of ds2 { (#,#) ipv2 ipv3 ->
                       (# ipv2, ts' #) } })
                        `cast`
                      (Trans
                           (<Data.Map.Base.Map
                               GHC.Base.String (Tensor.Restricted.Tensor GHC.Types.Double)>_R
                            ->_R Sym (GHC.Types.N:IO[0]
                                          <Data.Map.Base.Map
                                             GHC.Base.String
                                             (Tensor.Restricted.Tensor GHC.Types.Double)>_R))
                           (UnsafeCo representational (Data.Map.Base.Map
                                                         GHC.Base.String
                                                         (Tensor.Restricted.Tensor GHC.Types.Double)
                                                       -> GHC.Types.IO
                                                            (Data.Map.Base.Map
                                                               GHC.Base.String
                                                               (Tensor.Restricted.Tensor
                                                                  GHC.Types.Double))) (Main.HappyAbsSyn
                                                                                         t1))) }) -}
d4c8e8f0e32a79585ff17c4a64d9ef0e
  $wlvl ::
    GHC.Prim.State# GHC.Prim.RealWorld
    -> (# GHC.Prim.State# GHC.Prim.RealWorld,
          Data.Map.Base.Map
            GHC.Base.String (Tensor.Restricted.Tensor GHC.Types.Double) #)
  {- Arity: 1, Strictness: <S,U>, Inline: [0],
     Unfolding: (\ (w :: GHC.Prim.State# GHC.Prim.RealWorld)[OneShot] ->
                 case Control.Exception.Base.bracket1
                        @ GHC.IO.Handle.Types.Handle
                        @ ()
                        @ ()
                        Main.happyReduction_54
                          `cast`
                        (Sym (GHC.Types.N:IO[0] <GHC.IO.Handle.Types.Handle>_R))
                        GHC.IO.Handle.hClose1
                          `cast`
                        (<GHC.IO.Handle.Types.Handle>_R
                         ->_R Sym (GHC.Types.N:IO[0] <()>_R))
                        Main.happyReduction_74
                          `cast`
                        (<GHC.IO.Handle.Types.Handle>_R
                         ->_R Sym (GHC.Types.N:IO[0] <()>_R))
                        w of ds1 { (#,#) ipv ipv1 ->
                 case GHC.IO.Handle.Text.hPutStr2
                        GHC.IO.Handle.FD.stdout
                        Main.happyReduction_73
                        GHC.Types.True
                        ipv of ds2 { (#,#) ipv2 ipv3 ->
                 (# ipv2,
                    Data.Map.Base.Tip
                      @ GHC.Base.String
                      @ (Tensor.Restricted.Tensor GHC.Types.Double) #) } }) -}
0a84263b76b561ff8bc2b5b6af751a06
  type role HappyAbsSyn phantom
  newtype HappyAbsSyn t4 = HappyAbsSyn Main.HappyAny
62ada51a97215751b7273d1477394d51
  data HappyAddr = HappyA# GHC.Prim.Addr#
687d027b38560377a15b0ec22dbb5f49
  type HappyAny = GHC.Prim.Any
72ce36310a008d2c2bd5b32cceeb7d5b
  data HappyStk a = HappyStk a (Main.HappyStk a)
    RecFlag: Recursive
17643f0012740e5cd8eb2bc106ac3be7
  data Happy_IntList = HappyCons GHC.Prim.Int# Main.Happy_IntList
    RecFlag: Recursive
fbe35c00ecaca1abcc1970ff3db8d526
  happyAccept ::
    forall {t} {t1} {a} {b}.
    GHC.Prim.Int#
    -> t
    -> GHC.Prim.Int#
    -> t1
    -> Main.HappyStk a
    -> b
    -> GHC.Types.IO a
  {- Arity: 7, HasNoCafRefs,
     Strictness: <S,1*U><L,A><L,A><L,A><S,1*U(U,1*U(U,A))><L,A><S,U>,
     Unfolding: InlineRule (0, True, True)
                Main.happyAccept1
                  `cast`
                (forall (t :: <*>_N) (t1 :: <*>_N) (a :: <*>_N) (b :: <*>_N).
                 <GHC.Prim.Int#>_R
                 ->_R <t>_R
                 ->_R <GHC.Prim.Int#>_R
                 ->_R <t1>_R
                 ->_R <Main.HappyStk a>_R
                 ->_R <b>_R
                 ->_R Sym (GHC.Types.N:IO[0] <a>_R)) -}
4e1f4e5959121728efb5eaf80cb0f115
  happyAccept1 ::
    forall {t} {t1} {a} {b}.
    GHC.Prim.Int#
    -> t
    -> GHC.Prim.Int#
    -> t1
    -> Main.HappyStk a
    -> b
    -> GHC.Prim.State# GHC.Prim.RealWorld
    -> (# GHC.Prim.State# GHC.Prim.RealWorld, a #)
  {- Arity: 7, HasNoCafRefs,
     Strictness: <S,1*U><L,A><L,A><L,A><S,1*U(U,1*U(U,A))><L,A><S,U>,
     Unfolding: InlineRule (7, True, False)
                (\ @ t
                   @ t1
                   @ a
                   @ b
                   (ds :: GHC.Prim.Int#)
                   (tk :: t)
                   (st :: GHC.Prim.Int#)
                   (sts :: t1)
                   (ds1 :: Main.HappyStk a)
                   (eta :: b)
                   (eta1 :: GHC.Prim.State# GHC.Prim.RealWorld)[OneShot] ->
                 case ds of ds2 {
                   DEFAULT
                   -> case ds1 of wild { Main.HappyStk ans ds3 -> (# eta1, ans #) }
                   0#
                   -> case ds1 of wild { Main.HappyStk ds3 ds4 ->
                      case ds4 of wild1 { Main.HappyStk ans ds5 ->
                      (# eta1, ans #) } } }) -}
7a84e0ed745e3dc17fad3d0c8de4eaf0
  happyActOffsets :: Main.HappyAddr
  {- HasNoCafRefs, Strictness: m, Inline: NOINLINE -}
cb2eb0cbe3a60bb691109596f49791e0
  happyCheck :: Main.HappyAddr
  {- HasNoCafRefs, Strictness: m, Inline: NOINLINE -}
ba05b0fbb9b150c23e7b42fbe72fa747
  happyDefActions :: Main.HappyAddr
  {- HasNoCafRefs, Strictness: m, Inline: NOINLINE -}
c57cc3134e429f6524ff5a7800d0cff0
  happyDoAction ::
    GHC.Prim.Int#
    -> Lekser.Token
    -> GHC.Prim.Int#
    -> Main.Happy_IntList
    -> Main.HappyStk
         (Main.HappyAbsSyn
            (Data.Map.Base.Map
               GHC.Base.String (Tensor.Restricted.Tensor GHC.Types.Double)
             -> GHC.Types.IO
                  (Data.Map.Base.Map
                     GHC.Base.String (Tensor.Restricted.Tensor GHC.Types.Double))))
    -> [Lekser.Token]
    -> GHC.Types.IO
         (Main.HappyAbsSyn
            (Data.Map.Base.Map
               GHC.Base.String (Tensor.Restricted.Tensor GHC.Types.Double)
             -> GHC.Types.IO
                  (Data.Map.Base.Map
                     GHC.Base.String (Tensor.Restricted.Tensor GHC.Types.Double))))
  {- Arity: 3, Strictness: <S,U><L,U><S,U>, Inline: NOINLINE -}
5d47f49886ff85316ef7ff3a80591086
  happyDoSeq :: forall a b. a -> b -> b
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ @ a @ b (a1 :: a) (b1 :: b) ->
                 case a1 of a2 { DEFAULT -> b1 }) -}
5870d1ab96e50b747006601c42988d14
  happyDontSeq :: forall a b. a -> b -> b
  {- Arity: 2, HasNoCafRefs, Strictness: <L,A><S,1*U>,
     Unfolding: InlineRule (2, True, True)
                (\ @ a @ b (a1 :: a) (b1 :: b) -> b1) -}
255dbde73a3eab472e2b5d9e798cfc99
  happyDrop ::
    GHC.Prim.Int# -> Main.Happy_IntList -> Main.Happy_IntList
  {- Arity: 2, HasNoCafRefs -}
78d9e64f3eb0843d83c0c05c8af35c04
  happyDropStk ::
    forall {t}. GHC.Prim.Int# -> Main.HappyStk t -> Main.HappyStk t
  {- Arity: 2, HasNoCafRefs -}
157c4ef1fb746c5d38c59b1fb1695467
  happyError' :: forall a. [Lekser.Token] -> GHC.Types.IO a
  {- Arity: 2, Strictness: <L,1*U><S,U>,
     Unfolding: InlineRule (0, True, True)
                Main.happyError'1
                  `cast`
                (forall (a :: <*>_N).
                 <[Lekser.Token]>_R ->_R Sym (GHC.Types.N:IO[0] <a>_R)) -}
62f689d659626783fc95e03980ba487f
  happyError'1 ::
    forall {a}.
    [Lekser.Token]
    -> GHC.Prim.State# GHC.Prim.RealWorld
    -> (# GHC.Prim.State# GHC.Prim.RealWorld, a #)
  {- Arity: 2, Strictness: <L,1*U><S,U>,
     Unfolding: (\ @ a
                   (tok :: [Lekser.Token])
                   (s :: GHC.Prim.State# GHC.Prim.RealWorld)[OneShot] ->
                 case GHC.IO.Handle.Text.hPutStr2
                        GHC.IO.Handle.FD.stdout
                        (GHC.CString.unpackAppendCString#
                           "Command error at "#
                           (GHC.Base.++
                              @ GHC.Types.Char
                              (GHC.Show.showList__
                                 @ Lekser.Token
                                 Lekser.$fShowToken1
                                 tok
                                 (GHC.Types.[] @ GHC.Types.Char))
                              Main.happyError'5))
                        GHC.Types.True
                        s of ds1 { (#,#) ipv ipv1 ->
                 case Data.Binary.decodeFile11
                        @ (Data.Map.Base.Map
                             GHC.Base.String (Tensor.Restricted.Tensor GHC.Types.Double))
                        Main.$s$fBinaryMap
                        Main.happyError'4
                        ipv of ds2 { (#,#) ipv2 ipv3 ->
                 case ipv3 of wild {
                   Data.Either.Left ds
                   -> case ds of wild1 { (,) ds3 str ->
                      case Main.happyError'3 str
                      ret_ty (# GHC.Prim.State# GHC.Prim.RealWorld, a #)
                      of {} }
                   Data.Either.Right x -> Main.happyError'2 @ a x ipv2 } } }) -}
b7c5fe743de664cea53bfa432a6a75be
  happyError'2 ::
    forall {a}.
    Data.Map.Base.Map
      GHC.Base.String (Tensor.Restricted.Tensor GHC.Types.Double)
    -> GHC.Prim.State# GHC.Prim.RealWorld
    -> (# GHC.Prim.State# GHC.Prim.RealWorld, a #)
  {- Arity: 2, Strictness: <L,U><S,U> -}
a526fcf2788c5ca756e429d3a9520a32
  happyError'3 ::
    GHC.Base.String
    -> GHC.Types.IO
         (Data.Map.Base.Map
            GHC.Base.String (Tensor.Restricted.Tensor GHC.Types.Double))
  {- Arity: 1, Strictness: <L,U>x -}
a008ae83b8fbb5cddeddaa00e117b560
  happyError'4 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "~neurol.tmp"#) -}
3ddd141862666a3799155d4c74d228ca
  happyError'5 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "!"#) -}
ae0d63edfc03f48ee71e7d37b7063e7e
  happyError_ ::
    forall {a}.
    GHC.Prim.Int# -> Lekser.Token -> [Lekser.Token] -> GHC.Types.IO a
  {- Arity: 4, Strictness: <S,1*U><L,U><L,U><S,U>,
     Unfolding: InlineRule (0, True, True)
                Main.happyError_1
                  `cast`
                (forall (a :: <*>_N).
                 <GHC.Prim.Int#>_R
                 ->_R <Lekser.Token>_R
                 ->_R <[Lekser.Token]>_R
                 ->_R Sym (GHC.Types.N:IO[0] <a>_R)) -}
2650462d565a00db7656fc20b86eb5ca
  happyError_1 ::
    forall {a}.
    GHC.Prim.Int#
    -> Lekser.Token
    -> [Lekser.Token]
    -> GHC.Prim.State# GHC.Prim.RealWorld
    -> (# GHC.Prim.State# GHC.Prim.RealWorld, a #)
  {- Arity: 4, Strictness: <S,1*U><L,U><L,U><S,U>,
     Unfolding: InlineRule (4, True, False)
                (\ @ a
                   (ds :: GHC.Prim.Int#)
                   (tk :: Lekser.Token)
                   (tks :: [Lekser.Token])
                   (eta :: GHC.Prim.State# GHC.Prim.RealWorld)[OneShot] ->
                 case ds of ds1 {
                   DEFAULT
                   -> Main.happyError'1 @ a (GHC.Types.: @ Lekser.Token tk tks) eta
                   61# -> Main.happyError'1 @ a tks eta }) -}
409921ed8544b078dbebf5a8f3edfd8a
  happyFail ::
    GHC.Prim.Int#
    -> Lekser.Token
    -> GHC.Prim.Int#
    -> Main.Happy_IntList
    -> Main.HappyStk
         (Main.HappyAbsSyn
            (Data.Map.Base.Map
               GHC.Base.String (Tensor.Restricted.Tensor GHC.Types.Double)
             -> GHC.Types.IO
                  (Data.Map.Base.Map
                     GHC.Base.String (Tensor.Restricted.Tensor GHC.Types.Double))))
    -> [Lekser.Token]
    -> GHC.Types.IO
         (Main.HappyAbsSyn
            (Data.Map.Base.Map
               GHC.Base.String (Tensor.Restricted.Tensor GHC.Types.Double)
             -> GHC.Types.IO
                  (Data.Map.Base.Map
                     GHC.Base.String (Tensor.Restricted.Tensor GHC.Types.Double))))
  {- Arity: 5, Strictness: <S,1*U><L,U><L,U><L,U><L,U(U,U)>,
     Inline: NOINLINE -}
52c9ffbedc485c1746ee332c96f2146e
  happyGoto ::
    GHC.Prim.Int#
    -> GHC.Prim.Int#
    -> Lekser.Token
    -> GHC.Prim.Int#
    -> Main.Happy_IntList
    -> Main.HappyStk
         (Main.HappyAbsSyn
            (Data.Map.Base.Map
               GHC.Base.String (Tensor.Restricted.Tensor GHC.Types.Double)
             -> GHC.Types.IO
                  (Data.Map.Base.Map
                     GHC.Base.String (Tensor.Restricted.Tensor GHC.Types.Double))))
    -> [Lekser.Token]
    -> GHC.Types.IO
         (Main.HappyAbsSyn
            (Data.Map.Base.Map
               GHC.Base.String (Tensor.Restricted.Tensor GHC.Types.Double)
             -> GHC.Types.IO
                  (Data.Map.Base.Map
                     GHC.Base.String (Tensor.Restricted.Tensor GHC.Types.Double))))
  {- Arity: 4, Strictness: <S,U><S,U><L,U><S,U>, Inline: NOINLINE -}
8e4dc71fac19abefc0f6ba7b0d2e0e59
  happyGotoOffsets :: Main.HappyAddr
  {- HasNoCafRefs, Strictness: m, Inline: NOINLINE -}
a6d5a2356595b10014bfd274199e6285
  happyIn10 ::
    forall t4.
    (Data.Map.Base.Map
       GHC.Base.String (Tensor.Restricted.Tensor GHC.Types.Double)
     -> GHC.Base.Maybe (Tensor.Restricted.Tensor GHC.Types.Double))
    -> Main.HappyAbsSyn t4
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U>,
     Inline: INLINE (sat-args=1),
     Unfolding: InlineRule (1, False, True)
                (\ @ t4
                   (x :: Data.Map.Base.Map
                           GHC.Base.String (Tensor.Restricted.Tensor GHC.Types.Double)
                         -> GHC.Base.Maybe (Tensor.Restricted.Tensor GHC.Types.Double)) ->
                 x)
                  `cast`
                (forall (t4 :: <*>_N).
                 <Data.Map.Base.Map
                    GHC.Base.String (Tensor.Restricted.Tensor GHC.Types.Double)
                  -> GHC.Base.Maybe (Tensor.Restricted.Tensor GHC.Types.Double)>_R
                 ->_R UnsafeCo representational (Data.Map.Base.Map
                                                   GHC.Base.String
                                                   (Tensor.Restricted.Tensor GHC.Types.Double)
                                                 -> GHC.Base.Maybe
                                                      (Tensor.Restricted.Tensor
                                                         GHC.Types.Double)) (Main.HappyAbsSyn
                                                                               t4)) -}
871396f17999d20dd1bea2d6a36c8959
  happyIn11 ::
    forall t4.
    (Data.Map.Base.Map
       GHC.Base.String (Tensor.Restricted.Tensor GHC.Types.Double)
     -> GHC.Base.Maybe (Tensor.Restricted.Tensor GHC.Types.Double))
    -> Main.HappyAbsSyn t4
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U>,
     Inline: INLINE (sat-args=1),
     Unfolding: InlineRule (1, False, True)
                (\ @ t4
                   (x :: Data.Map.Base.Map
                           GHC.Base.String (Tensor.Restricted.Tensor GHC.Types.Double)
                         -> GHC.Base.Maybe (Tensor.Restricted.Tensor GHC.Types.Double)) ->
                 x)
                  `cast`
                (forall (t4 :: <*>_N).
                 <Data.Map.Base.Map
                    GHC.Base.String (Tensor.Restricted.Tensor GHC.Types.Double)
                  -> GHC.Base.Maybe (Tensor.Restricted.Tensor GHC.Types.Double)>_R
                 ->_R UnsafeCo representational (Data.Map.Base.Map
                                                   GHC.Base.String
                                                   (Tensor.Restricted.Tensor GHC.Types.Double)
                                                 -> GHC.Base.Maybe
                                                      (Tensor.Restricted.Tensor
                                                         GHC.Types.Double)) (Main.HappyAbsSyn
                                                                               t4)) -}
08c1fa39baf179602dd3861637341d28
  happyIn12 ::
    forall t4.
    (Data.Map.Base.Map
       GHC.Base.String (Tensor.Restricted.Tensor GHC.Types.Double)
     -> GHC.Base.Maybe (Tensor.Restricted.Tensor GHC.Types.Double))
    -> Main.HappyAbsSyn t4
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U>,
     Inline: INLINE (sat-args=1),
     Unfolding: InlineRule (1, False, True)
                (\ @ t4
                   (x :: Data.Map.Base.Map
                           GHC.Base.String (Tensor.Restricted.Tensor GHC.Types.Double)
                         -> GHC.Base.Maybe (Tensor.Restricted.Tensor GHC.Types.Double)) ->
                 x)
                  `cast`
                (forall (t4 :: <*>_N).
                 <Data.Map.Base.Map
                    GHC.Base.String (Tensor.Restricted.Tensor GHC.Types.Double)
                  -> GHC.Base.Maybe (Tensor.Restricted.Tensor GHC.Types.Double)>_R
                 ->_R UnsafeCo representational (Data.Map.Base.Map
                                                   GHC.Base.String
                                                   (Tensor.Restricted.Tensor GHC.Types.Double)
                                                 -> GHC.Base.Maybe
                                                      (Tensor.Restricted.Tensor
                                                         GHC.Types.Double)) (Main.HappyAbsSyn
                                                                               t4)) -}
1c59a6988de8c554c0b56d857d04dfbf
  happyIn13 ::
    forall t4.
    (Data.Map.Base.Map
       GHC.Base.String (Tensor.Restricted.Tensor GHC.Types.Double)
     -> GHC.Base.Maybe (Tensor.Restricted.Tensor GHC.Types.Double))
    -> Main.HappyAbsSyn t4
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U>,
     Inline: INLINE (sat-args=1),
     Unfolding: InlineRule (1, False, True)
                (\ @ t4
                   (x :: Data.Map.Base.Map
                           GHC.Base.String (Tensor.Restricted.Tensor GHC.Types.Double)
                         -> GHC.Base.Maybe (Tensor.Restricted.Tensor GHC.Types.Double)) ->
                 x)
                  `cast`
                (forall (t4 :: <*>_N).
                 <Data.Map.Base.Map
                    GHC.Base.String (Tensor.Restricted.Tensor GHC.Types.Double)
                  -> GHC.Base.Maybe (Tensor.Restricted.Tensor GHC.Types.Double)>_R
                 ->_R UnsafeCo representational (Data.Map.Base.Map
                                                   GHC.Base.String
                                                   (Tensor.Restricted.Tensor GHC.Types.Double)
                                                 -> GHC.Base.Maybe
                                                      (Tensor.Restricted.Tensor
                                                         GHC.Types.Double)) (Main.HappyAbsSyn
                                                                               t4)) -}
bdf26d9f843f76d8e80d114c568d8576
  happyIn14 ::
    forall t4.
    (Data.Map.Base.Map
       GHC.Base.String (Tensor.Restricted.Tensor GHC.Types.Double)
     -> GHC.Base.Maybe (Tensor.Restricted.Tensor GHC.Types.Double))
    -> Main.HappyAbsSyn t4
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U>,
     Inline: INLINE (sat-args=1),
     Unfolding: InlineRule (1, False, True)
                (\ @ t4
                   (x :: Data.Map.Base.Map
                           GHC.Base.String (Tensor.Restricted.Tensor GHC.Types.Double)
                         -> GHC.Base.Maybe (Tensor.Restricted.Tensor GHC.Types.Double)) ->
                 x)
                  `cast`
                (forall (t4 :: <*>_N).
                 <Data.Map.Base.Map
                    GHC.Base.String (Tensor.Restricted.Tensor GHC.Types.Double)
                  -> GHC.Base.Maybe (Tensor.Restricted.Tensor GHC.Types.Double)>_R
                 ->_R UnsafeCo representational (Data.Map.Base.Map
                                                   GHC.Base.String
                                                   (Tensor.Restricted.Tensor GHC.Types.Double)
                                                 -> GHC.Base.Maybe
                                                      (Tensor.Restricted.Tensor
                                                         GHC.Types.Double)) (Main.HappyAbsSyn
                                                                               t4)) -}
669b764588a8eb065752b6a7e246aa65
  happyIn4 :: forall t4. t4 -> Main.HappyAbsSyn t4
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U>,
     Inline: INLINE (sat-args=1),
     Unfolding: InlineRule (1, False, True)
                (\ @ t4 (x :: t4) -> x)
                  `cast`
                (forall (t4 :: <*>_N).
                 <t4>_R ->_R UnsafeCo representational t4 (Main.HappyAbsSyn t4)) -}
4cebbf2352e81a7bea1b9154fedef38f
  happyIn5 ::
    forall t4.
    (Data.Map.Base.Map
       GHC.Base.String (Tensor.Restricted.Tensor GHC.Types.Double)
     -> GHC.Types.IO
          (Data.Map.Base.Map
             GHC.Base.String (Tensor.Restricted.Tensor GHC.Types.Double)))
    -> Main.HappyAbsSyn t4
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U>,
     Inline: INLINE (sat-args=1),
     Unfolding: InlineRule (1, False, True)
                (\ @ t4
                   (x :: Data.Map.Base.Map
                           GHC.Base.String (Tensor.Restricted.Tensor GHC.Types.Double)
                         -> GHC.Types.IO
                              (Data.Map.Base.Map
                                 GHC.Base.String (Tensor.Restricted.Tensor GHC.Types.Double))) ->
                 x)
                  `cast`
                (forall (t4 :: <*>_N).
                 <Data.Map.Base.Map
                    GHC.Base.String (Tensor.Restricted.Tensor GHC.Types.Double)
                  -> GHC.Types.IO
                       (Data.Map.Base.Map
                          GHC.Base.String (Tensor.Restricted.Tensor GHC.Types.Double))>_R
                 ->_R UnsafeCo representational (Data.Map.Base.Map
                                                   GHC.Base.String
                                                   (Tensor.Restricted.Tensor GHC.Types.Double)
                                                 -> GHC.Types.IO
                                                      (Data.Map.Base.Map
                                                         GHC.Base.String
                                                         (Tensor.Restricted.Tensor
                                                            GHC.Types.Double))) (Main.HappyAbsSyn
                                                                                   t4)) -}
0fafa24dd9cd400845f0b0891a596108
  happyIn6 :: forall t4. Tensor.Index.TIndex -> Main.HappyAbsSyn t4
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U>,
     Inline: INLINE (sat-args=1),
     Unfolding: InlineRule (1, False, True)
                (\ @ t4 (x :: Tensor.Index.TIndex) -> x)
                  `cast`
                (forall (t4 :: <*>_N).
                 <Tensor.Index.TIndex>_R
                 ->_R UnsafeCo representational Tensor.Index.TIndex (Main.HappyAbsSyn
                                                                       t4)) -}
41a2783363e77fccd238f9aad444ad1a
  happyIn7 ::
    forall t4.
    (Data.Map.Base.Map
       GHC.Base.String (Tensor.Restricted.Tensor GHC.Types.Double)
     -> GHC.Base.Maybe (Tensor.Restricted.Tensor GHC.Types.Double))
    -> Main.HappyAbsSyn t4
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U>,
     Inline: INLINE (sat-args=1),
     Unfolding: InlineRule (1, False, True)
                (\ @ t4
                   (x :: Data.Map.Base.Map
                           GHC.Base.String (Tensor.Restricted.Tensor GHC.Types.Double)
                         -> GHC.Base.Maybe (Tensor.Restricted.Tensor GHC.Types.Double)) ->
                 x)
                  `cast`
                (forall (t4 :: <*>_N).
                 <Data.Map.Base.Map
                    GHC.Base.String (Tensor.Restricted.Tensor GHC.Types.Double)
                  -> GHC.Base.Maybe (Tensor.Restricted.Tensor GHC.Types.Double)>_R
                 ->_R UnsafeCo representational (Data.Map.Base.Map
                                                   GHC.Base.String
                                                   (Tensor.Restricted.Tensor GHC.Types.Double)
                                                 -> GHC.Base.Maybe
                                                      (Tensor.Restricted.Tensor
                                                         GHC.Types.Double)) (Main.HappyAbsSyn
                                                                               t4)) -}
b262fdf0046f5405834a1f9c3a74eb72
  happyIn8 ::
    forall t4.
    (Data.Map.Base.Map
       GHC.Base.String (Tensor.Restricted.Tensor GHC.Types.Double)
     -> GHC.Base.Maybe (Tensor.Restricted.Tensor GHC.Types.Double))
    -> Main.HappyAbsSyn t4
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U>,
     Inline: INLINE (sat-args=1),
     Unfolding: InlineRule (1, False, True)
                (\ @ t4
                   (x :: Data.Map.Base.Map
                           GHC.Base.String (Tensor.Restricted.Tensor GHC.Types.Double)
                         -> GHC.Base.Maybe (Tensor.Restricted.Tensor GHC.Types.Double)) ->
                 x)
                  `cast`
                (forall (t4 :: <*>_N).
                 <Data.Map.Base.Map
                    GHC.Base.String (Tensor.Restricted.Tensor GHC.Types.Double)
                  -> GHC.Base.Maybe (Tensor.Restricted.Tensor GHC.Types.Double)>_R
                 ->_R UnsafeCo representational (Data.Map.Base.Map
                                                   GHC.Base.String
                                                   (Tensor.Restricted.Tensor GHC.Types.Double)
                                                 -> GHC.Base.Maybe
                                                      (Tensor.Restricted.Tensor
                                                         GHC.Types.Double)) (Main.HappyAbsSyn
                                                                               t4)) -}
7005577fa509644a633a7c50b7cde6e7
  happyIn9 ::
    forall t4.
    (Data.Map.Base.Map
       GHC.Base.String (Tensor.Restricted.Tensor GHC.Types.Double)
     -> GHC.Base.Maybe (Tensor.Restricted.Tensor GHC.Types.Double))
    -> Main.HappyAbsSyn t4
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U>,
     Inline: INLINE (sat-args=1),
     Unfolding: InlineRule (1, False, True)
                (\ @ t4
                   (x :: Data.Map.Base.Map
                           GHC.Base.String (Tensor.Restricted.Tensor GHC.Types.Double)
                         -> GHC.Base.Maybe (Tensor.Restricted.Tensor GHC.Types.Double)) ->
                 x)
                  `cast`
                (forall (t4 :: <*>_N).
                 <Data.Map.Base.Map
                    GHC.Base.String (Tensor.Restricted.Tensor GHC.Types.Double)
                  -> GHC.Base.Maybe (Tensor.Restricted.Tensor GHC.Types.Double)>_R
                 ->_R UnsafeCo representational (Data.Map.Base.Map
                                                   GHC.Base.String
                                                   (Tensor.Restricted.Tensor GHC.Types.Double)
                                                 -> GHC.Base.Maybe
                                                      (Tensor.Restricted.Tensor
                                                         GHC.Types.Double)) (Main.HappyAbsSyn
                                                                               t4)) -}
e66fadaf847edf302918b2e4de737cad
  happyInTok :: forall t4. Lekser.Token -> Main.HappyAbsSyn t4
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U>,
     Inline: INLINE (sat-args=1),
     Unfolding: InlineRule (1, False, True)
                (\ @ t4 (x :: Lekser.Token) -> x)
                  `cast`
                (forall (t4 :: <*>_N).
                 <Lekser.Token>_R
                 ->_R UnsafeCo representational Lekser.Token (Main.HappyAbsSyn
                                                                t4)) -}
b2c4599d1e20cdb1d93825b89402acd6
  happyMonad2Reduce ::
    GHC.Prim.Int#
    -> GHC.Prim.Int#
    -> (Main.HappyStk
          (Main.HappyAbsSyn
             (Data.Map.Base.Map
                GHC.Base.String (Tensor.Restricted.Tensor GHC.Types.Double)
              -> GHC.Types.IO
                   (Data.Map.Base.Map
                      GHC.Base.String (Tensor.Restricted.Tensor GHC.Types.Double))))
        -> Lekser.Token
        -> GHC.Types.IO
             (Main.HappyAbsSyn
                (Data.Map.Base.Map
                   GHC.Base.String (Tensor.Restricted.Tensor GHC.Types.Double)
                 -> GHC.Types.IO
                      (Data.Map.Base.Map
                         GHC.Base.String (Tensor.Restricted.Tensor GHC.Types.Double)))))
    -> GHC.Prim.Int#
    -> Lekser.Token
    -> GHC.Prim.Int#
    -> Main.Happy_IntList
    -> Main.HappyStk
         (Main.HappyAbsSyn
            (Data.Map.Base.Map
               GHC.Base.String (Tensor.Restricted.Tensor GHC.Types.Double)
             -> GHC.Types.IO
                  (Data.Map.Base.Map
                     GHC.Base.String (Tensor.Restricted.Tensor GHC.Types.Double))))
    -> [Lekser.Token]
    -> GHC.Types.IO
         (Main.HappyAbsSyn
            (Data.Map.Base.Map
               GHC.Base.String (Tensor.Restricted.Tensor GHC.Types.Double)
             -> GHC.Types.IO
                  (Data.Map.Base.Map
                     GHC.Base.String (Tensor.Restricted.Tensor GHC.Types.Double))))
  {- Arity: 8,
     Strictness: <L,U><L,U><L,1*C1(C1(U))><S,1*U><L,U><S,U><L,U(U,U(U,U(U,U(U,U(U,U(U,U(U,U(U,U))))))))><L,U(U,U(U,U(U,U(U,U(U,U(U,U(U,U(U,U(U,U)))))))))>,
     Unfolding: (\ (k :: GHC.Prim.Int#)
                   (nt :: GHC.Prim.Int#)
                   (fn :: Main.HappyStk
                            (Main.HappyAbsSyn
                               (Data.Map.Base.Map
                                  GHC.Base.String (Tensor.Restricted.Tensor GHC.Types.Double)
                                -> GHC.Types.IO
                                     (Data.Map.Base.Map
                                        GHC.Base.String
                                        (Tensor.Restricted.Tensor GHC.Types.Double))))
                          -> Lekser.Token
                          -> GHC.Types.IO
                               (Main.HappyAbsSyn
                                  (Data.Map.Base.Map
                                     GHC.Base.String (Tensor.Restricted.Tensor GHC.Types.Double)
                                   -> GHC.Types.IO
                                        (Data.Map.Base.Map
                                           GHC.Base.String
                                           (Tensor.Restricted.Tensor GHC.Types.Double)))))
                   (ds :: GHC.Prim.Int#)
                   (tk :: Lekser.Token)
                   (st :: GHC.Prim.Int#)
                   (sts :: Main.Happy_IntList)
                   (stk :: Main.HappyStk
                             (Main.HappyAbsSyn
                                (Data.Map.Base.Map
                                   GHC.Base.String (Tensor.Restricted.Tensor GHC.Types.Double)
                                 -> GHC.Types.IO
                                      (Data.Map.Base.Map
                                         GHC.Base.String
                                         (Tensor.Restricted.Tensor GHC.Types.Double))))) ->
                 case ds of ds1 {
                   DEFAULT
                   -> case Main.happyDrop
                             k
                             (Main.HappyCons st sts) of wild { Main.HappyCons st1 ds2 ->
                      case Main.happyGotoOffsets of wild1 { Main.HappyA# arr ->
                      case Main.happyTable of wild2 { Main.HappyA# arr1 ->
                      let {
                        off' :: GHC.Prim.Int# = GHC.Prim.*# st1 2#
                      } in
                      case GHC.Prim.indexCharOffAddr# arr off' of wild3 { DEFAULT ->
                      case GHC.Prim.indexCharOffAddr#
                             arr
                             (GHC.Prim.+# off' 1#) of wild4 { DEFAULT ->
                      let {
                        off'1 :: GHC.Prim.Int#
                        = GHC.Prim.*#
                            (GHC.Prim.+#
                               (GHC.Prim.narrow16Int#
                                  (GHC.Prim.word2Int#
                                     (GHC.Prim.or#
                                        (GHC.Prim.uncheckedShiftL#
                                           (GHC.Prim.int2Word# (GHC.Prim.ord# wild4))
                                           8#)
                                        (GHC.Prim.int2Word# (GHC.Prim.ord# wild3)))))
                               nt)
                            2#
                      } in
                      case GHC.Prim.indexCharOffAddr# arr1 off'1 of wild5 { DEFAULT ->
                      case GHC.Prim.indexCharOffAddr#
                             arr1
                             (GHC.Prim.+# off'1 1#) of wild6 { DEFAULT ->
                      let {
                        new_state :: GHC.Prim.Int#
                        = GHC.Prim.narrow16Int#
                            (GHC.Prim.word2Int#
                               (GHC.Prim.or#
                                  (GHC.Prim.uncheckedShiftL#
                                     (GHC.Prim.int2Word# (GHC.Prim.ord# wild6))
                                     8#)
                                  (GHC.Prim.int2Word# (GHC.Prim.ord# wild5))))
                      } in
                      let {
                        drop_stk :: Main.HappyStk
                                      (Main.HappyAbsSyn
                                         (Data.Map.Base.Map
                                            GHC.Base.String
                                            (Tensor.Restricted.Tensor GHC.Types.Double)
                                          -> GHC.Types.IO
                                               (Data.Map.Base.Map
                                                  GHC.Base.String
                                                  (Tensor.Restricted.Tensor GHC.Types.Double))))
                        = Main.happyDropStk
                            @ (Main.HappyAbsSyn
                                 (Data.Map.Base.Map
                                    GHC.Base.String (Tensor.Restricted.Tensor GHC.Types.Double)
                                  -> GHC.Types.IO
                                       (Data.Map.Base.Map
                                          GHC.Base.String
                                          (Tensor.Restricted.Tensor GHC.Types.Double))))
                            k
                            stk
                      } in
                      let {
                        m :: GHC.Types.IO
                               (Main.HappyAbsSyn
                                  (Data.Map.Base.Map
                                     GHC.Base.String (Tensor.Restricted.Tensor GHC.Types.Double)
                                   -> GHC.Types.IO
                                        (Data.Map.Base.Map
                                           GHC.Base.String
                                           (Tensor.Restricted.Tensor GHC.Types.Double))))
                        = fn stk tk
                      } in
                      (\ (tks :: [Lekser.Token])
                         (s :: GHC.Prim.State# GHC.Prim.RealWorld)[OneShot] ->
                       case m `cast`
                            (GHC.Types.N:IO[0]
                                 <Main.HappyAbsSyn
                                    (Data.Map.Base.Map
                                       GHC.Base.String (Tensor.Restricted.Tensor GHC.Types.Double)
                                     -> GHC.Types.IO
                                          (Data.Map.Base.Map
                                             GHC.Base.String
                                             (Tensor.Restricted.Tensor GHC.Types.Double)))>_R)
                              s of ds3 { (#,#) ipv ipv1 ->
                       (Main.happyNewToken
                          new_state
                          wild
                          (Main.HappyStk
                             @ (Main.HappyAbsSyn
                                  (Data.Map.Base.Map
                                     GHC.Base.String (Tensor.Restricted.Tensor GHC.Types.Double)
                                   -> GHC.Types.IO
                                        (Data.Map.Base.Map
                                           GHC.Base.String
                                           (Tensor.Restricted.Tensor GHC.Types.Double))))
                             ipv1
                             drop_stk)
                          tks)
                         `cast`
                       (GHC.Types.N:IO[0]
                            <Main.HappyAbsSyn
                               (Data.Map.Base.Map
                                  GHC.Base.String (Tensor.Restricted.Tensor GHC.Types.Double)
                                -> GHC.Types.IO
                                     (Data.Map.Base.Map
                                        GHC.Base.String
                                        (Tensor.Restricted.Tensor GHC.Types.Double)))>_R)
                         ipv })
                        `cast`
                      (<[Lekser.Token]>_R
                       ->_R Sym (GHC.Types.N:IO[0]
                                     <Main.HappyAbsSyn
                                        (Data.Map.Base.Map
                                           GHC.Base.String
                                           (Tensor.Restricted.Tensor GHC.Types.Double)
                                         -> GHC.Types.IO
                                              (Data.Map.Base.Map
                                                 GHC.Base.String
                                                 (Tensor.Restricted.Tensor
                                                    GHC.Types.Double)))>_R)) } } } } } } }
                   0# -> Main.happyFail 0# tk st sts stk }) -}
1001f523fe54564a797a254e1a97c8e7
  happyMonadReduce ::
    GHC.Prim.Int#
    -> GHC.Prim.Int#
    -> (Main.HappyStk
          (Main.HappyAbsSyn
             (Data.Map.Base.Map
                GHC.Base.String (Tensor.Restricted.Tensor GHC.Types.Double)
              -> GHC.Types.IO
                   (Data.Map.Base.Map
                      GHC.Base.String (Tensor.Restricted.Tensor GHC.Types.Double))))
        -> Lekser.Token
        -> GHC.Types.IO
             (Main.HappyAbsSyn
                (Data.Map.Base.Map
                   GHC.Base.String (Tensor.Restricted.Tensor GHC.Types.Double)
                 -> GHC.Types.IO
                      (Data.Map.Base.Map
                         GHC.Base.String (Tensor.Restricted.Tensor GHC.Types.Double)))))
    -> GHC.Prim.Int#
    -> Lekser.Token
    -> GHC.Prim.Int#
    -> Main.Happy_IntList
    -> Main.HappyStk
         (Main.HappyAbsSyn
            (Data.Map.Base.Map
               GHC.Base.String (Tensor.Restricted.Tensor GHC.Types.Double)
             -> GHC.Types.IO
                  (Data.Map.Base.Map
                     GHC.Base.String (Tensor.Restricted.Tensor GHC.Types.Double))))
    -> [Lekser.Token]
    -> GHC.Types.IO
         (Main.HappyAbsSyn
            (Data.Map.Base.Map
               GHC.Base.String (Tensor.Restricted.Tensor GHC.Types.Double)
             -> GHC.Types.IO
                  (Data.Map.Base.Map
                     GHC.Base.String (Tensor.Restricted.Tensor GHC.Types.Double))))
  {- Arity: 8,
     Strictness: <L,U><L,U><L,1*C1(C1(U))><S,1*U><L,U><S,U><L,U(U,U(U,U(U,U(U,U(U,U(U,U(U,U(U,U))))))))><L,U(U,U(U,U(U,U(U,U(U,U(U,U(U,U(U,U(U,U)))))))))>,
     Inline: NOINLINE -}
68b5b15478ed59520d7e02f243212915
  happyNewToken ::
    GHC.Prim.Int#
    -> Main.Happy_IntList
    -> Main.HappyStk
         (Main.HappyAbsSyn
            (Data.Map.Base.Map
               GHC.Base.String (Tensor.Restricted.Tensor GHC.Types.Double)
             -> GHC.Types.IO
                  (Data.Map.Base.Map
                     GHC.Base.String (Tensor.Restricted.Tensor GHC.Types.Double))))
    -> [Lekser.Token]
    -> GHC.Types.IO
         (Main.HappyAbsSyn
            (Data.Map.Base.Map
               GHC.Base.String (Tensor.Restricted.Tensor GHC.Types.Double)
             -> GHC.Types.IO
                  (Data.Map.Base.Map
                     GHC.Base.String (Tensor.Restricted.Tensor GHC.Types.Double))))
  {- Arity: 4, Strictness: <S,U><L,U><L,U><S,1*U> -}
f2d926750de88cd80643459314c386f9
  happyOut10 ::
    forall t4.
    Main.HappyAbsSyn t4
    -> Data.Map.Base.Map
         GHC.Base.String (Tensor.Restricted.Tensor GHC.Types.Double)
    -> GHC.Base.Maybe (Tensor.Restricted.Tensor GHC.Types.Double)
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U>,
     Inline: INLINE (sat-args=1),
     Unfolding: InlineRule (1, False, True)
                (\ @ t4 (x :: Main.HappyAbsSyn t4) -> x)
                  `cast`
                (forall (t4 :: <*>_N).
                 <Main.HappyAbsSyn t4>_R
                 ->_R UnsafeCo representational (Main.HappyAbsSyn
                                                   t4) (Data.Map.Base.Map
                                                          GHC.Base.String
                                                          (Tensor.Restricted.Tensor
                                                             GHC.Types.Double)
                                                        -> GHC.Base.Maybe
                                                             (Tensor.Restricted.Tensor
                                                                GHC.Types.Double))) -}
a37d0d24ba68349da251a73b164af459
  happyOut11 ::
    forall t4.
    Main.HappyAbsSyn t4
    -> Data.Map.Base.Map
         GHC.Base.String (Tensor.Restricted.Tensor GHC.Types.Double)
    -> GHC.Base.Maybe (Tensor.Restricted.Tensor GHC.Types.Double)
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U>,
     Inline: INLINE (sat-args=1),
     Unfolding: InlineRule (1, False, True)
                (\ @ t4 (x :: Main.HappyAbsSyn t4) -> x)
                  `cast`
                (forall (t4 :: <*>_N).
                 <Main.HappyAbsSyn t4>_R
                 ->_R UnsafeCo representational (Main.HappyAbsSyn
                                                   t4) (Data.Map.Base.Map
                                                          GHC.Base.String
                                                          (Tensor.Restricted.Tensor
                                                             GHC.Types.Double)
                                                        -> GHC.Base.Maybe
                                                             (Tensor.Restricted.Tensor
                                                                GHC.Types.Double))) -}
c1e5a95498a7f378433f8c744d4d996d
  happyOut12 ::
    forall t4.
    Main.HappyAbsSyn t4
    -> Data.Map.Base.Map
         GHC.Base.String (Tensor.Restricted.Tensor GHC.Types.Double)
    -> GHC.Base.Maybe (Tensor.Restricted.Tensor GHC.Types.Double)
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U>,
     Inline: INLINE (sat-args=1),
     Unfolding: InlineRule (1, False, True)
                (\ @ t4 (x :: Main.HappyAbsSyn t4) -> x)
                  `cast`
                (forall (t4 :: <*>_N).
                 <Main.HappyAbsSyn t4>_R
                 ->_R UnsafeCo representational (Main.HappyAbsSyn
                                                   t4) (Data.Map.Base.Map
                                                          GHC.Base.String
                                                          (Tensor.Restricted.Tensor
                                                             GHC.Types.Double)
                                                        -> GHC.Base.Maybe
                                                             (Tensor.Restricted.Tensor
                                                                GHC.Types.Double))) -}
45ecaea120aad20257df9f6319f302bd
  happyOut13 ::
    forall t4.
    Main.HappyAbsSyn t4
    -> Data.Map.Base.Map
         GHC.Base.String (Tensor.Restricted.Tensor GHC.Types.Double)
    -> GHC.Base.Maybe (Tensor.Restricted.Tensor GHC.Types.Double)
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U>,
     Inline: INLINE (sat-args=1),
     Unfolding: InlineRule (1, False, True)
                (\ @ t4 (x :: Main.HappyAbsSyn t4) -> x)
                  `cast`
                (forall (t4 :: <*>_N).
                 <Main.HappyAbsSyn t4>_R
                 ->_R UnsafeCo representational (Main.HappyAbsSyn
                                                   t4) (Data.Map.Base.Map
                                                          GHC.Base.String
                                                          (Tensor.Restricted.Tensor
                                                             GHC.Types.Double)
                                                        -> GHC.Base.Maybe
                                                             (Tensor.Restricted.Tensor
                                                                GHC.Types.Double))) -}
495e8390b1b8af1dd20399844ae69b0f
  happyOut14 ::
    forall t4.
    Main.HappyAbsSyn t4
    -> Data.Map.Base.Map
         GHC.Base.String (Tensor.Restricted.Tensor GHC.Types.Double)
    -> GHC.Base.Maybe (Tensor.Restricted.Tensor GHC.Types.Double)
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U>,
     Inline: INLINE (sat-args=1),
     Unfolding: InlineRule (1, False, True)
                (\ @ t4 (x :: Main.HappyAbsSyn t4) -> x)
                  `cast`
                (forall (t4 :: <*>_N).
                 <Main.HappyAbsSyn t4>_R
                 ->_R UnsafeCo representational (Main.HappyAbsSyn
                                                   t4) (Data.Map.Base.Map
                                                          GHC.Base.String
                                                          (Tensor.Restricted.Tensor
                                                             GHC.Types.Double)
                                                        -> GHC.Base.Maybe
                                                             (Tensor.Restricted.Tensor
                                                                GHC.Types.Double))) -}
888ce691a50c6e63477e90ea4b3736ad
  happyOut4 :: forall t4. Main.HappyAbsSyn t4 -> t4
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U>,
     Inline: INLINE (sat-args=1),
     Unfolding: InlineRule (1, False, True)
                (\ @ t4 (x :: Main.HappyAbsSyn t4) -> x)
                  `cast`
                (forall (t4 :: <*>_N).
                 <Main.HappyAbsSyn t4>_R
                 ->_R UnsafeCo representational (Main.HappyAbsSyn t4) t4) -}
7daa9ea59a8b1bb54049082e405c4f50
  happyOut5 ::
    forall t4.
    Main.HappyAbsSyn t4
    -> Data.Map.Base.Map
         GHC.Base.String (Tensor.Restricted.Tensor GHC.Types.Double)
    -> GHC.Types.IO
         (Data.Map.Base.Map
            GHC.Base.String (Tensor.Restricted.Tensor GHC.Types.Double))
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U>,
     Inline: INLINE (sat-args=1),
     Unfolding: InlineRule (1, False, True)
                (\ @ t4 (x :: Main.HappyAbsSyn t4) -> x)
                  `cast`
                (forall (t4 :: <*>_N).
                 <Main.HappyAbsSyn t4>_R
                 ->_R UnsafeCo representational (Main.HappyAbsSyn
                                                   t4) (Data.Map.Base.Map
                                                          GHC.Base.String
                                                          (Tensor.Restricted.Tensor
                                                             GHC.Types.Double)
                                                        -> GHC.Types.IO
                                                             (Data.Map.Base.Map
                                                                GHC.Base.String
                                                                (Tensor.Restricted.Tensor
                                                                   GHC.Types.Double)))) -}
34f441e8f71623a3a97e5971829fea05
  happyOut6 :: forall t4. Main.HappyAbsSyn t4 -> Tensor.Index.TIndex
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U>,
     Inline: INLINE (sat-args=1),
     Unfolding: InlineRule (1, False, True)
                (\ @ t4 (x :: Main.HappyAbsSyn t4) -> x)
                  `cast`
                (forall (t4 :: <*>_N).
                 <Main.HappyAbsSyn t4>_R
                 ->_R UnsafeCo representational (Main.HappyAbsSyn
                                                   t4) Tensor.Index.TIndex) -}
3c2ffa59467d7f201da8d9c8fa449209
  happyOut7 ::
    forall t4.
    Main.HappyAbsSyn t4
    -> Data.Map.Base.Map
         GHC.Base.String (Tensor.Restricted.Tensor GHC.Types.Double)
    -> GHC.Base.Maybe (Tensor.Restricted.Tensor GHC.Types.Double)
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U>,
     Inline: INLINE (sat-args=1),
     Unfolding: InlineRule (1, False, True)
                (\ @ t4 (x :: Main.HappyAbsSyn t4) -> x)
                  `cast`
                (forall (t4 :: <*>_N).
                 <Main.HappyAbsSyn t4>_R
                 ->_R UnsafeCo representational (Main.HappyAbsSyn
                                                   t4) (Data.Map.Base.Map
                                                          GHC.Base.String
                                                          (Tensor.Restricted.Tensor
                                                             GHC.Types.Double)
                                                        -> GHC.Base.Maybe
                                                             (Tensor.Restricted.Tensor
                                                                GHC.Types.Double))) -}
93b3eb952865513251250e71e85766b9
  happyOut8 ::
    forall t4.
    Main.HappyAbsSyn t4
    -> Data.Map.Base.Map
         GHC.Base.String (Tensor.Restricted.Tensor GHC.Types.Double)
    -> GHC.Base.Maybe (Tensor.Restricted.Tensor GHC.Types.Double)
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U>,
     Inline: INLINE (sat-args=1),
     Unfolding: InlineRule (1, False, True)
                (\ @ t4 (x :: Main.HappyAbsSyn t4) -> x)
                  `cast`
                (forall (t4 :: <*>_N).
                 <Main.HappyAbsSyn t4>_R
                 ->_R UnsafeCo representational (Main.HappyAbsSyn
                                                   t4) (Data.Map.Base.Map
                                                          GHC.Base.String
                                                          (Tensor.Restricted.Tensor
                                                             GHC.Types.Double)
                                                        -> GHC.Base.Maybe
                                                             (Tensor.Restricted.Tensor
                                                                GHC.Types.Double))) -}
eea585fbe2ffe520bf56da43ef43b264
  happyOut9 ::
    forall t4.
    Main.HappyAbsSyn t4
    -> Data.Map.Base.Map
         GHC.Base.String (Tensor.Restricted.Tensor GHC.Types.Double)
    -> GHC.Base.Maybe (Tensor.Restricted.Tensor GHC.Types.Double)
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U>,
     Inline: INLINE (sat-args=1),
     Unfolding: InlineRule (1, False, True)
                (\ @ t4 (x :: Main.HappyAbsSyn t4) -> x)
                  `cast`
                (forall (t4 :: <*>_N).
                 <Main.HappyAbsSyn t4>_R
                 ->_R UnsafeCo representational (Main.HappyAbsSyn
                                                   t4) (Data.Map.Base.Map
                                                          GHC.Base.String
                                                          (Tensor.Restricted.Tensor
                                                             GHC.Types.Double)
                                                        -> GHC.Base.Maybe
                                                             (Tensor.Restricted.Tensor
                                                                GHC.Types.Double))) -}
93b8714c0110059621a239fe7c7bdd64
  happyOutTok :: forall t4. Main.HappyAbsSyn t4 -> Lekser.Token
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U>,
     Inline: INLINE (sat-args=1),
     Unfolding: InlineRule (1, False, True)
                (\ @ t4 (x :: Main.HappyAbsSyn t4) -> x)
                  `cast`
                (forall (t4 :: <*>_N).
                 <Main.HappyAbsSyn t4>_R
                 ->_R UnsafeCo representational (Main.HappyAbsSyn
                                                   t4) Lekser.Token) -}
86c8bb532611143f98aec359810d6c44
  happyParse ::
    GHC.Prim.Int#
    -> [Lekser.Token]
    -> GHC.Types.IO
         (Main.HappyAbsSyn
            (Data.Map.Base.Map
               GHC.Base.String (Tensor.Restricted.Tensor GHC.Types.Double)
             -> GHC.Types.IO
                  (Data.Map.Base.Map
                     GHC.Base.String (Tensor.Restricted.Tensor GHC.Types.Double))))
  {- Arity: 2, Strictness: <S,U>,
     Unfolding: InlineRule (1, True, False)
                (\ (start_state :: GHC.Prim.Int#) (eta :: [Lekser.Token]) ->
                 Main.happyNewToken
                   start_state
                   (Main.notHappyAtAll @ Main.Happy_IntList)
                   (Main.notHappyAtAll
                      @ (Main.HappyStk
                           (Main.HappyAbsSyn
                              (Data.Map.Base.Map
                                 GHC.Base.String (Tensor.Restricted.Tensor GHC.Types.Double)
                               -> GHC.Types.IO
                                    (Data.Map.Base.Map
                                       GHC.Base.String
                                       (Tensor.Restricted.Tensor GHC.Types.Double))))))
                   eta) -}
a9399f0d4d40c78720e8a664dbcf3514
  happyReduce ::
    GHC.Prim.Int#
    -> GHC.Prim.Int#
    -> (Main.HappyStk
          (Main.HappyAbsSyn
             (Data.Map.Base.Map
                GHC.Base.String (Tensor.Restricted.Tensor GHC.Types.Double)
              -> GHC.Types.IO
                   (Data.Map.Base.Map
                      GHC.Base.String (Tensor.Restricted.Tensor GHC.Types.Double))))
        -> Main.HappyStk
             (Main.HappyAbsSyn
                (Data.Map.Base.Map
                   GHC.Base.String (Tensor.Restricted.Tensor GHC.Types.Double)
                 -> GHC.Types.IO
                      (Data.Map.Base.Map
                         GHC.Base.String (Tensor.Restricted.Tensor GHC.Types.Double)))))
    -> GHC.Prim.Int#
    -> Lekser.Token
    -> GHC.Prim.Int#
    -> Main.Happy_IntList
    -> Main.HappyStk
         (Main.HappyAbsSyn
            (Data.Map.Base.Map
               GHC.Base.String (Tensor.Restricted.Tensor GHC.Types.Double)
             -> GHC.Types.IO
                  (Data.Map.Base.Map
                     GHC.Base.String (Tensor.Restricted.Tensor GHC.Types.Double))))
    -> [Lekser.Token]
    -> GHC.Types.IO
         (Main.HappyAbsSyn
            (Data.Map.Base.Map
               GHC.Base.String (Tensor.Restricted.Tensor GHC.Types.Double)
             -> GHC.Types.IO
                  (Data.Map.Base.Map
                     GHC.Base.String (Tensor.Restricted.Tensor GHC.Types.Double))))
  {- Arity: 8,
     Strictness: <L,U><L,U><L,1*C1(U(U,U))><S,1*U><L,U><L,U><L,U(U,U(U,U(U,U(U,U(U,U(U,U(U,U(U,U(U,U)))))))))><L,U(U,U)>,
     Inline: NOINLINE -}
7b76218be91dd840d38dcc226dedbef0
  happyReduceArr ::
    GHC.Arr.Array
      GHC.Types.Int
      (GHC.Prim.Int#
       -> Lekser.Token
       -> GHC.Prim.Int#
       -> Main.Happy_IntList
       -> Main.HappyStk
            (Main.HappyAbsSyn
               (Data.Map.Base.Map
                  GHC.Base.String (Tensor.Restricted.Tensor GHC.Types.Double)
                -> GHC.Types.IO
                     (Data.Map.Base.Map
                        GHC.Base.String (Tensor.Restricted.Tensor GHC.Types.Double))))
       -> [Lekser.Token]
       -> GHC.Types.IO
            (Main.HappyAbsSyn
               (Data.Map.Base.Map
                  GHC.Base.String (Tensor.Restricted.Tensor GHC.Types.Double)
                -> GHC.Types.IO
                     (Data.Map.Base.Map
                        GHC.Base.String (Tensor.Restricted.Tensor GHC.Types.Double)))))
422c340b69e8ece43e2a3da68b66702b
  happyReduce_1 ::
    GHC.Prim.Int#
    -> Lekser.Token
    -> GHC.Prim.Int#
    -> Main.Happy_IntList
    -> Main.HappyStk
         (Main.HappyAbsSyn
            (Data.Map.Base.Map
               GHC.Base.String (Tensor.Restricted.Tensor GHC.Types.Double)
             -> GHC.Types.IO
                  (Data.Map.Base.Map
                     GHC.Base.String (Tensor.Restricted.Tensor GHC.Types.Double))))
    -> [Lekser.Token]
    -> GHC.Types.IO
         (Main.HappyAbsSyn
            (Data.Map.Base.Map
               GHC.Base.String (Tensor.Restricted.Tensor GHC.Types.Double)
             -> GHC.Types.IO
                  (Data.Map.Base.Map
                     GHC.Base.String (Tensor.Restricted.Tensor GHC.Types.Double))))
  {- Arity: 5 -}
05b0469bd60b52a5af0665e8f4cdc2a2
  happyReduce_10 ::
    GHC.Prim.Int#
    -> Lekser.Token
    -> GHC.Prim.Int#
    -> Main.Happy_IntList
    -> Main.HappyStk
         (Main.HappyAbsSyn
            (Data.Map.Base.Map
               GHC.Base.String (Tensor.Restricted.Tensor GHC.Types.Double)
             -> GHC.Types.IO
                  (Data.Map.Base.Map
                     GHC.Base.String (Tensor.Restricted.Tensor GHC.Types.Double))))
    -> [Lekser.Token]
    -> GHC.Types.IO
         (Main.HappyAbsSyn
            (Data.Map.Base.Map
               GHC.Base.String (Tensor.Restricted.Tensor GHC.Types.Double)
             -> GHC.Types.IO
                  (Data.Map.Base.Map
                     GHC.Base.String (Tensor.Restricted.Tensor GHC.Types.Double))))
  {- Arity: 5 -}
21df91979e050496c81b075d8642d854
  happyReduce_11 ::
    GHC.Prim.Int#
    -> Lekser.Token
    -> GHC.Prim.Int#
    -> Main.Happy_IntList
    -> Main.HappyStk
         (Main.HappyAbsSyn
            (Data.Map.Base.Map
               GHC.Base.String (Tensor.Restricted.Tensor GHC.Types.Double)
             -> GHC.Types.IO
                  (Data.Map.Base.Map
                     GHC.Base.String (Tensor.Restricted.Tensor GHC.Types.Double))))
    -> [Lekser.Token]
    -> GHC.Types.IO
         (Main.HappyAbsSyn
            (Data.Map.Base.Map
               GHC.Base.String (Tensor.Restricted.Tensor GHC.Types.Double)
             -> GHC.Types.IO
                  (Data.Map.Base.Map
                     GHC.Base.String (Tensor.Restricted.Tensor GHC.Types.Double))))
  {- Arity: 5 -}
b2784060817d53b66e9cf77f343c4f85
  happyReduce_12 ::
    GHC.Prim.Int#
    -> Lekser.Token
    -> GHC.Prim.Int#
    -> Main.Happy_IntList
    -> Main.HappyStk
         (Main.HappyAbsSyn
            (Data.Map.Base.Map
               GHC.Base.String (Tensor.Restricted.Tensor GHC.Types.Double)
             -> GHC.Types.IO
                  (Data.Map.Base.Map
                     GHC.Base.String (Tensor.Restricted.Tensor GHC.Types.Double))))
    -> [Lekser.Token]
    -> GHC.Types.IO
         (Main.HappyAbsSyn
            (Data.Map.Base.Map
               GHC.Base.String (Tensor.Restricted.Tensor GHC.Types.Double)
             -> GHC.Types.IO
                  (Data.Map.Base.Map
                     GHC.Base.String (Tensor.Restricted.Tensor GHC.Types.Double))))
  {- Arity: 5 -}
48c579cab627ee492aea3dd1fc83376c
  happyReduce_13 ::
    GHC.Prim.Int#
    -> Lekser.Token
    -> GHC.Prim.Int#
    -> Main.Happy_IntList
    -> Main.HappyStk
         (Main.HappyAbsSyn
            (Data.Map.Base.Map
               GHC.Base.String (Tensor.Restricted.Tensor GHC.Types.Double)
             -> GHC.Types.IO
                  (Data.Map.Base.Map
                     GHC.Base.String (Tensor.Restricted.Tensor GHC.Types.Double))))
    -> [Lekser.Token]
    -> GHC.Types.IO
         (Main.HappyAbsSyn
            (Data.Map.Base.Map
               GHC.Base.String (Tensor.Restricted.Tensor GHC.Types.Double)
             -> GHC.Types.IO
                  (Data.Map.Base.Map
                     GHC.Base.String (Tensor.Restricted.Tensor GHC.Types.Double))))
  {- Arity: 5 -}
dcaceadc845a7f747eb15c8abe2220fa
  happyReduce_14 ::
    GHC.Prim.Int#
    -> Lekser.Token
    -> GHC.Prim.Int#
    -> Main.Happy_IntList
    -> Main.HappyStk
         (Main.HappyAbsSyn
            (Data.Map.Base.Map
               GHC.Base.String (Tensor.Restricted.Tensor GHC.Types.Double)
             -> GHC.Types.IO
                  (Data.Map.Base.Map
                     GHC.Base.String (Tensor.Restricted.Tensor GHC.Types.Double))))
    -> [Lekser.Token]
    -> GHC.Types.IO
         (Main.HappyAbsSyn
            (Data.Map.Base.Map
               GHC.Base.String (Tensor.Restricted.Tensor GHC.Types.Double)
             -> GHC.Types.IO
                  (Data.Map.Base.Map
                     GHC.Base.String (Tensor.Restricted.Tensor GHC.Types.Double))))
  {- Arity: 5 -}
f7004140cb439c5d458c950c6c2908d0
  happyReduce_15 ::
    GHC.Prim.Int#
    -> Lekser.Token
    -> GHC.Prim.Int#
    -> Main.Happy_IntList
    -> Main.HappyStk
         (Main.HappyAbsSyn
            (Data.Map.Base.Map
               GHC.Base.String (Tensor.Restricted.Tensor GHC.Types.Double)
             -> GHC.Types.IO
                  (Data.Map.Base.Map
                     GHC.Base.String (Tensor.Restricted.Tensor GHC.Types.Double))))
    -> [Lekser.Token]
    -> GHC.Types.IO
         (Main.HappyAbsSyn
            (Data.Map.Base.Map
               GHC.Base.String (Tensor.Restricted.Tensor GHC.Types.Double)
             -> GHC.Types.IO
                  (Data.Map.Base.Map
                     GHC.Base.String (Tensor.Restricted.Tensor GHC.Types.Double))))
  {- Arity: 5 -}
e7fcc63acf07573404c1566a2a112e48
  happyReduce_16 ::
    GHC.Prim.Int#
    -> Lekser.Token
    -> GHC.Prim.Int#
    -> Main.Happy_IntList
    -> Main.HappyStk
         (Main.HappyAbsSyn
            (Data.Map.Base.Map
               GHC.Base.String (Tensor.Restricted.Tensor GHC.Types.Double)
             -> GHC.Types.IO
                  (Data.Map.Base.Map
                     GHC.Base.String (Tensor.Restricted.Tensor GHC.Types.Double))))
    -> [Lekser.Token]
    -> GHC.Types.IO
         (Main.HappyAbsSyn
            (Data.Map.Base.Map
               GHC.Base.String (Tensor.Restricted.Tensor GHC.Types.Double)
             -> GHC.Types.IO
                  (Data.Map.Base.Map
                     GHC.Base.String (Tensor.Restricted.Tensor GHC.Types.Double))))
  {- Arity: 5 -}
16a2e7db04951f5e2ed3b477c3be9562
  happyReduce_17 ::
    GHC.Prim.Int#
    -> Lekser.Token
    -> GHC.Prim.Int#
    -> Main.Happy_IntList
    -> Main.HappyStk
         (Main.HappyAbsSyn
            (Data.Map.Base.Map
               GHC.Base.String (Tensor.Restricted.Tensor GHC.Types.Double)
             -> GHC.Types.IO
                  (Data.Map.Base.Map
                     GHC.Base.String (Tensor.Restricted.Tensor GHC.Types.Double))))
    -> [Lekser.Token]
    -> GHC.Types.IO
         (Main.HappyAbsSyn
            (Data.Map.Base.Map
               GHC.Base.String (Tensor.Restricted.Tensor GHC.Types.Double)
             -> GHC.Types.IO
                  (Data.Map.Base.Map
                     GHC.Base.String (Tensor.Restricted.Tensor GHC.Types.Double))))
  {- Arity: 5 -}
f87aee6858de58f37827aa521c27c396
  happyReduce_18 ::
    GHC.Prim.Int#
    -> Lekser.Token
    -> GHC.Prim.Int#
    -> Main.Happy_IntList
    -> Main.HappyStk
         (Main.HappyAbsSyn
            (Data.Map.Base.Map
               GHC.Base.String (Tensor.Restricted.Tensor GHC.Types.Double)
             -> GHC.Types.IO
                  (Data.Map.Base.Map
                     GHC.Base.String (Tensor.Restricted.Tensor GHC.Types.Double))))
    -> [Lekser.Token]
    -> GHC.Types.IO
         (Main.HappyAbsSyn
            (Data.Map.Base.Map
               GHC.Base.String (Tensor.Restricted.Tensor GHC.Types.Double)
             -> GHC.Types.IO
                  (Data.Map.Base.Map
                     GHC.Base.String (Tensor.Restricted.Tensor GHC.Types.Double))))
  {- Arity: 5 -}
9d377cdb4ab874a0d40bc5ff1cbb0ff6
  happyReduce_19 ::
    GHC.Prim.Int#
    -> Lekser.Token
    -> GHC.Prim.Int#
    -> Main.Happy_IntList
    -> Main.HappyStk
         (Main.HappyAbsSyn
            (Data.Map.Base.Map
               GHC.Base.String (Tensor.Restricted.Tensor GHC.Types.Double)
             -> GHC.Types.IO
                  (Data.Map.Base.Map
                     GHC.Base.String (Tensor.Restricted.Tensor GHC.Types.Double))))
    -> [Lekser.Token]
    -> GHC.Types.IO
         (Main.HappyAbsSyn
            (Data.Map.Base.Map
               GHC.Base.String (Tensor.Restricted.Tensor GHC.Types.Double)
             -> GHC.Types.IO
                  (Data.Map.Base.Map
                     GHC.Base.String (Tensor.Restricted.Tensor GHC.Types.Double))))
  {- Arity: 5 -}
0da510b86940856c3ab8987b638a26dd
  happyReduce_2 ::
    GHC.Prim.Int#
    -> Lekser.Token
    -> GHC.Prim.Int#
    -> Main.Happy_IntList
    -> Main.HappyStk
         (Main.HappyAbsSyn
            (Data.Map.Base.Map
               GHC.Base.String (Tensor.Restricted.Tensor GHC.Types.Double)
             -> GHC.Types.IO
                  (Data.Map.Base.Map
                     GHC.Base.String (Tensor.Restricted.Tensor GHC.Types.Double))))
    -> [Lekser.Token]
    -> GHC.Types.IO
         (Main.HappyAbsSyn
            (Data.Map.Base.Map
               GHC.Base.String (Tensor.Restricted.Tensor GHC.Types.Double)
             -> GHC.Types.IO
                  (Data.Map.Base.Map
                     GHC.Base.String (Tensor.Restricted.Tensor GHC.Types.Double))))
  {- Arity: 5 -}
660cc35461e49650436a7072a9dd8678
  happyReduce_20 ::
    GHC.Prim.Int#
    -> Lekser.Token
    -> GHC.Prim.Int#
    -> Main.Happy_IntList
    -> Main.HappyStk
         (Main.HappyAbsSyn
            (Data.Map.Base.Map
               GHC.Base.String (Tensor.Restricted.Tensor GHC.Types.Double)
             -> GHC.Types.IO
                  (Data.Map.Base.Map
                     GHC.Base.String (Tensor.Restricted.Tensor GHC.Types.Double))))
    -> [Lekser.Token]
    -> GHC.Types.IO
         (Main.HappyAbsSyn
            (Data.Map.Base.Map
               GHC.Base.String (Tensor.Restricted.Tensor GHC.Types.Double)
             -> GHC.Types.IO
                  (Data.Map.Base.Map
                     GHC.Base.String (Tensor.Restricted.Tensor GHC.Types.Double))))
  {- Arity: 5 -}
94eeb0dd69217383f6f5b5365610a169
  happyReduce_21 ::
    GHC.Prim.Int#
    -> Lekser.Token
    -> GHC.Prim.Int#
    -> Main.Happy_IntList
    -> Main.HappyStk
         (Main.HappyAbsSyn
            (Data.Map.Base.Map
               GHC.Base.String (Tensor.Restricted.Tensor GHC.Types.Double)
             -> GHC.Types.IO
                  (Data.Map.Base.Map
                     GHC.Base.String (Tensor.Restricted.Tensor GHC.Types.Double))))
    -> [Lekser.Token]
    -> GHC.Types.IO
         (Main.HappyAbsSyn
            (Data.Map.Base.Map
               GHC.Base.String (Tensor.Restricted.Tensor GHC.Types.Double)
             -> GHC.Types.IO
                  (Data.Map.Base.Map
                     GHC.Base.String (Tensor.Restricted.Tensor GHC.Types.Double))))
  {- Arity: 5 -}
b4e45384b4ce072f9f1479df45e10fdf
  happyReduce_22 ::
    GHC.Prim.Int#
    -> Lekser.Token
    -> GHC.Prim.Int#
    -> Main.Happy_IntList
    -> Main.HappyStk
         (Main.HappyAbsSyn
            (Data.Map.Base.Map
               GHC.Base.String (Tensor.Restricted.Tensor GHC.Types.Double)
             -> GHC.Types.IO
                  (Data.Map.Base.Map
                     GHC.Base.String (Tensor.Restricted.Tensor GHC.Types.Double))))
    -> [Lekser.Token]
    -> GHC.Types.IO
         (Main.HappyAbsSyn
            (Data.Map.Base.Map
               GHC.Base.String (Tensor.Restricted.Tensor GHC.Types.Double)
             -> GHC.Types.IO
                  (Data.Map.Base.Map
                     GHC.Base.String (Tensor.Restricted.Tensor GHC.Types.Double))))
  {- Arity: 5 -}
94446efe6e175c0b2763bec7474d94ef
  happyReduce_23 ::
    GHC.Prim.Int#
    -> Lekser.Token
    -> GHC.Prim.Int#
    -> Main.Happy_IntList
    -> Main.HappyStk
         (Main.HappyAbsSyn
            (Data.Map.Base.Map
               GHC.Base.String (Tensor.Restricted.Tensor GHC.Types.Double)
             -> GHC.Types.IO
                  (Data.Map.Base.Map
                     GHC.Base.String (Tensor.Restricted.Tensor GHC.Types.Double))))
    -> [Lekser.Token]
    -> GHC.Types.IO
         (Main.HappyAbsSyn
            (Data.Map.Base.Map
               GHC.Base.String (Tensor.Restricted.Tensor GHC.Types.Double)
             -> GHC.Types.IO
                  (Data.Map.Base.Map
                     GHC.Base.String (Tensor.Restricted.Tensor GHC.Types.Double))))
  {- Arity: 5 -}
4de2d42bd7717e07bde9275817c0a5d6
  happyReduce_24 ::
    GHC.Prim.Int#
    -> Lekser.Token
    -> GHC.Prim.Int#
    -> Main.Happy_IntList
    -> Main.HappyStk
         (Main.HappyAbsSyn
            (Data.Map.Base.Map
               GHC.Base.String (Tensor.Restricted.Tensor GHC.Types.Double)
             -> GHC.Types.IO
                  (Data.Map.Base.Map
                     GHC.Base.String (Tensor.Restricted.Tensor GHC.Types.Double))))
    -> [Lekser.Token]
    -> GHC.Types.IO
         (Main.HappyAbsSyn
            (Data.Map.Base.Map
               GHC.Base.String (Tensor.Restricted.Tensor GHC.Types.Double)
             -> GHC.Types.IO
                  (Data.Map.Base.Map
                     GHC.Base.String (Tensor.Restricted.Tensor GHC.Types.Double))))
  {- Arity: 5 -}
d8e4e8ec30d7300bdef5dfe3c4fb6cdb
  happyReduce_25 ::
    GHC.Prim.Int#
    -> Lekser.Token
    -> GHC.Prim.Int#
    -> Main.Happy_IntList
    -> Main.HappyStk
         (Main.HappyAbsSyn
            (Data.Map.Base.Map
               GHC.Base.String (Tensor.Restricted.Tensor GHC.Types.Double)
             -> GHC.Types.IO
                  (Data.Map.Base.Map
                     GHC.Base.String (Tensor.Restricted.Tensor GHC.Types.Double))))
    -> [Lekser.Token]
    -> GHC.Types.IO
         (Main.HappyAbsSyn
            (Data.Map.Base.Map
               GHC.Base.String (Tensor.Restricted.Tensor GHC.Types.Double)
             -> GHC.Types.IO
                  (Data.Map.Base.Map
                     GHC.Base.String (Tensor.Restricted.Tensor GHC.Types.Double))))
  {- Arity: 5 -}
348b055787f5cf4353e5425cb7293a7a
  happyReduce_26 ::
    GHC.Prim.Int#
    -> Lekser.Token
    -> GHC.Prim.Int#
    -> Main.Happy_IntList
    -> Main.HappyStk
         (Main.HappyAbsSyn
            (Data.Map.Base.Map
               GHC.Base.String (Tensor.Restricted.Tensor GHC.Types.Double)
             -> GHC.Types.IO
                  (Data.Map.Base.Map
                     GHC.Base.String (Tensor.Restricted.Tensor GHC.Types.Double))))
    -> [Lekser.Token]
    -> GHC.Types.IO
         (Main.HappyAbsSyn
            (Data.Map.Base.Map
               GHC.Base.String (Tensor.Restricted.Tensor GHC.Types.Double)
             -> GHC.Types.IO
                  (Data.Map.Base.Map
                     GHC.Base.String (Tensor.Restricted.Tensor GHC.Types.Double))))
  {- Arity: 5 -}
9d96bb4b423a4c692781f25bb59ac560
  happyReduce_27 ::
    GHC.Prim.Int#
    -> Lekser.Token
    -> GHC.Prim.Int#
    -> Main.Happy_IntList
    -> Main.HappyStk
         (Main.HappyAbsSyn
            (Data.Map.Base.Map
               GHC.Base.String (Tensor.Restricted.Tensor GHC.Types.Double)
             -> GHC.Types.IO
                  (Data.Map.Base.Map
                     GHC.Base.String (Tensor.Restricted.Tensor GHC.Types.Double))))
    -> [Lekser.Token]
    -> GHC.Types.IO
         (Main.HappyAbsSyn
            (Data.Map.Base.Map
               GHC.Base.String (Tensor.Restricted.Tensor GHC.Types.Double)
             -> GHC.Types.IO
                  (Data.Map.Base.Map
                     GHC.Base.String (Tensor.Restricted.Tensor GHC.Types.Double))))
  {- Arity: 5 -}
a5ea60487419390774be7e838d4d5c30
  happyReduce_28 ::
    GHC.Prim.Int#
    -> Lekser.Token
    -> GHC.Prim.Int#
    -> Main.Happy_IntList
    -> Main.HappyStk
         (Main.HappyAbsSyn
            (Data.Map.Base.Map
               GHC.Base.String (Tensor.Restricted.Tensor GHC.Types.Double)
             -> GHC.Types.IO
                  (Data.Map.Base.Map
                     GHC.Base.String (Tensor.Restricted.Tensor GHC.Types.Double))))
    -> [Lekser.Token]
    -> GHC.Types.IO
         (Main.HappyAbsSyn
            (Data.Map.Base.Map
               GHC.Base.String (Tensor.Restricted.Tensor GHC.Types.Double)
             -> GHC.Types.IO
                  (Data.Map.Base.Map
                     GHC.Base.String (Tensor.Restricted.Tensor GHC.Types.Double))))
  {- Arity: 5 -}
c9b66a77be646f600b3dfed0c782667e
  happyReduce_29 ::
    GHC.Prim.Int#
    -> Lekser.Token
    -> GHC.Prim.Int#
    -> Main.Happy_IntList
    -> Main.HappyStk
         (Main.HappyAbsSyn
            (Data.Map.Base.Map
               GHC.Base.String (Tensor.Restricted.Tensor GHC.Types.Double)
             -> GHC.Types.IO
                  (Data.Map.Base.Map
                     GHC.Base.String (Tensor.Restricted.Tensor GHC.Types.Double))))
    -> [Lekser.Token]
    -> GHC.Types.IO
         (Main.HappyAbsSyn
            (Data.Map.Base.Map
               GHC.Base.String (Tensor.Restricted.Tensor GHC.Types.Double)
             -> GHC.Types.IO
                  (Data.Map.Base.Map
                     GHC.Base.String (Tensor.Restricted.Tensor GHC.Types.Double))))
  {- Arity: 5 -}
0dd691a6101d51f7212a93f525c4f73b
  happyReduce_3 ::
    GHC.Prim.Int#
    -> Lekser.Token
    -> GHC.Prim.Int#
    -> Main.Happy_IntList
    -> Main.HappyStk
         (Main.HappyAbsSyn
            (Data.Map.Base.Map
               GHC.Base.String (Tensor.Restricted.Tensor GHC.Types.Double)
             -> GHC.Types.IO
                  (Data.Map.Base.Map
                     GHC.Base.String (Tensor.Restricted.Tensor GHC.Types.Double))))
    -> [Lekser.Token]
    -> GHC.Types.IO
         (Main.HappyAbsSyn
            (Data.Map.Base.Map
               GHC.Base.String (Tensor.Restricted.Tensor GHC.Types.Double)
             -> GHC.Types.IO
                  (Data.Map.Base.Map
                     GHC.Base.String (Tensor.Restricted.Tensor GHC.Types.Double))))
  {- Arity: 5 -}
824c2f6e128cdf15f04b9fb51e381748
  happyReduce_4 ::
    GHC.Prim.Int#
    -> Lekser.Token
    -> GHC.Prim.Int#
    -> Main.Happy_IntList
    -> Main.HappyStk
         (Main.HappyAbsSyn
            (Data.Map.Base.Map
               GHC.Base.String (Tensor.Restricted.Tensor GHC.Types.Double)
             -> GHC.Types.IO
                  (Data.Map.Base.Map
                     GHC.Base.String (Tensor.Restricted.Tensor GHC.Types.Double))))
    -> [Lekser.Token]
    -> GHC.Types.IO
         (Main.HappyAbsSyn
            (Data.Map.Base.Map
               GHC.Base.String (Tensor.Restricted.Tensor GHC.Types.Double)
             -> GHC.Types.IO
                  (Data.Map.Base.Map
                     GHC.Base.String (Tensor.Restricted.Tensor GHC.Types.Double))))
  {- Arity: 5 -}
e2f6d59378ecedb56483309854e3c925
  happyReduce_5 ::
    GHC.Prim.Int#
    -> Lekser.Token
    -> GHC.Prim.Int#
    -> Main.Happy_IntList
    -> Main.HappyStk
         (Main.HappyAbsSyn
            (Data.Map.Base.Map
               GHC.Base.String (Tensor.Restricted.Tensor GHC.Types.Double)
             -> GHC.Types.IO
                  (Data.Map.Base.Map
                     GHC.Base.String (Tensor.Restricted.Tensor GHC.Types.Double))))
    -> [Lekser.Token]
    -> GHC.Types.IO
         (Main.HappyAbsSyn
            (Data.Map.Base.Map
               GHC.Base.String (Tensor.Restricted.Tensor GHC.Types.Double)
             -> GHC.Types.IO
                  (Data.Map.Base.Map
                     GHC.Base.String (Tensor.Restricted.Tensor GHC.Types.Double))))
  {- Arity: 5 -}
d5d0d910f557d170fd74491db90e5ede
  happyReduce_6 ::
    GHC.Prim.Int#
    -> Lekser.Token
    -> GHC.Prim.Int#
    -> Main.Happy_IntList
    -> Main.HappyStk
         (Main.HappyAbsSyn
            (Data.Map.Base.Map
               GHC.Base.String (Tensor.Restricted.Tensor GHC.Types.Double)
             -> GHC.Types.IO
                  (Data.Map.Base.Map
                     GHC.Base.String (Tensor.Restricted.Tensor GHC.Types.Double))))
    -> [Lekser.Token]
    -> GHC.Types.IO
         (Main.HappyAbsSyn
            (Data.Map.Base.Map
               GHC.Base.String (Tensor.Restricted.Tensor GHC.Types.Double)
             -> GHC.Types.IO
                  (Data.Map.Base.Map
                     GHC.Base.String (Tensor.Restricted.Tensor GHC.Types.Double))))
  {- Arity: 5 -}
d7eae0561fbd2d96ea6f12b78b9d4660
  happyReduce_7 ::
    GHC.Prim.Int#
    -> Lekser.Token
    -> GHC.Prim.Int#
    -> Main.Happy_IntList
    -> Main.HappyStk
         (Main.HappyAbsSyn
            (Data.Map.Base.Map
               GHC.Base.String (Tensor.Restricted.Tensor GHC.Types.Double)
             -> GHC.Types.IO
                  (Data.Map.Base.Map
                     GHC.Base.String (Tensor.Restricted.Tensor GHC.Types.Double))))
    -> [Lekser.Token]
    -> GHC.Types.IO
         (Main.HappyAbsSyn
            (Data.Map.Base.Map
               GHC.Base.String (Tensor.Restricted.Tensor GHC.Types.Double)
             -> GHC.Types.IO
                  (Data.Map.Base.Map
                     GHC.Base.String (Tensor.Restricted.Tensor GHC.Types.Double))))
  {- Arity: 5 -}
6f408e02bc0c1cee4d9281098bab9041
  happyReduce_8 ::
    GHC.Prim.Int#
    -> Lekser.Token
    -> GHC.Prim.Int#
    -> Main.Happy_IntList
    -> Main.HappyStk
         (Main.HappyAbsSyn
            (Data.Map.Base.Map
               GHC.Base.String (Tensor.Restricted.Tensor GHC.Types.Double)
             -> GHC.Types.IO
                  (Data.Map.Base.Map
                     GHC.Base.String (Tensor.Restricted.Tensor GHC.Types.Double))))
    -> [Lekser.Token]
    -> GHC.Types.IO
         (Main.HappyAbsSyn
            (Data.Map.Base.Map
               GHC.Base.String (Tensor.Restricted.Tensor GHC.Types.Double)
             -> GHC.Types.IO
                  (Data.Map.Base.Map
                     GHC.Base.String (Tensor.Restricted.Tensor GHC.Types.Double))))
  {- Arity: 5 -}
3448c2d7fbf40d090f11e82fe530a100
  happyReduce_9 ::
    GHC.Prim.Int#
    -> Lekser.Token
    -> GHC.Prim.Int#
    -> Main.Happy_IntList
    -> Main.HappyStk
         (Main.HappyAbsSyn
            (Data.Map.Base.Map
               GHC.Base.String (Tensor.Restricted.Tensor GHC.Types.Double)
             -> GHC.Types.IO
                  (Data.Map.Base.Map
                     GHC.Base.String (Tensor.Restricted.Tensor GHC.Types.Double))))
    -> [Lekser.Token]
    -> GHC.Types.IO
         (Main.HappyAbsSyn
            (Data.Map.Base.Map
               GHC.Base.String (Tensor.Restricted.Tensor GHC.Types.Double)
             -> GHC.Types.IO
                  (Data.Map.Base.Map
                     GHC.Base.String (Tensor.Restricted.Tensor GHC.Types.Double))))
  {- Arity: 5 -}
d003a495cecd0081321416999f8273e5
  happyReduction_1 ::
    forall {t4}.
    Main.HappyAbsSyn t4
    -> Main.HappyAbsSyn
         (Data.Map.Base.Map
            GHC.Base.String (Tensor.Restricted.Tensor GHC.Types.Double)
          -> GHC.Types.IO
               (Data.Map.Base.Map
                  GHC.Base.String (Tensor.Restricted.Tensor GHC.Types.Double)))
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U>,
     Unfolding: InlineRule (0, True, True)
                Main.happyReduction_37
                  `cast`
                (forall (t4 :: <*>_N).
                 <Main.HappyAbsSyn t4>_R
                 ->_R (Main.HappyAbsSyn
                         <t4, Data.Map.Base.Map
                                GHC.Base.String (Tensor.Restricted.Tensor GHC.Types.Double)
                              -> GHC.Types.IO
                                   (Data.Map.Base.Map
                                      GHC.Base.String
                                      (Tensor.Restricted.Tensor GHC.Types.Double))>)_R) -}
7259673ec8fd29d155dccbc93eecb96c
  happyReduction_10 ::
    forall {t4} {t1}. Main.HappyAbsSyn t4 -> Main.HappyAbsSyn t1
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: (\ @ t4 @ t1 (happy_x_1 :: Main.HappyAbsSyn t4) ->
                 case happy_x_1
                        `cast`
                      (UnsafeCo representational (Main.HappyAbsSyn
                                                    t4) Lekser.Token) of wild {
                   DEFAULT -> Main.happyReduction_38 @ t1
                   Lekser.Natural happy_var_1
                   -> let {
                        lvl40 :: Tensor.Restricted.Tensor GHC.Types.Double
                        = case happy_var_1 of wild1 { GHC.Types.I# i ->
                          Tensor.Restricted.Scalar
                            @ GHC.Types.Double
                            (GHC.Types.D# (GHC.Prim.int2Double# i)) }
                      } in
                      let {
                        lvl41 :: GHC.Base.Maybe (Tensor.Restricted.Tensor GHC.Types.Double)
                        = GHC.Base.Just @ (Tensor.Restricted.Tensor GHC.Types.Double) lvl40
                      } in
                      (\ (ts :: Data.Map.Base.Map
                                  GHC.Base.String (Tensor.Restricted.Tensor GHC.Types.Double)) ->
                       lvl41)
                        `cast`
                      (UnsafeCo representational (Data.Map.Base.Map
                                                    GHC.Base.String
                                                    (Tensor.Restricted.Tensor GHC.Types.Double)
                                                  -> GHC.Base.Maybe
                                                       (Tensor.Restricted.Tensor
                                                          GHC.Types.Double)) (Main.HappyAbsSyn
                                                                                t1)) }) -}
252afc1d561a6c913b94dfb2a7dade61
  happyReduction_11 ::
    forall {t4} {t1}. Main.HappyAbsSyn t4 -> Main.HappyAbsSyn t1
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: (\ @ t4 @ t1 (happy_x_1 :: Main.HappyAbsSyn t4) ->
                 case happy_x_1
                        `cast`
                      (UnsafeCo representational (Main.HappyAbsSyn
                                                    t4) Lekser.Token) of wild {
                   DEFAULT -> Main.happyReduction_39 @ t1
                   Lekser.Integer happy_var_1
                   -> let {
                        lvl40 :: Tensor.Restricted.Tensor GHC.Types.Double
                        = case happy_var_1 of wild1 { GHC.Types.I# i ->
                          Tensor.Restricted.Scalar
                            @ GHC.Types.Double
                            (GHC.Types.D# (GHC.Prim.int2Double# i)) }
                      } in
                      let {
                        lvl41 :: GHC.Base.Maybe (Tensor.Restricted.Tensor GHC.Types.Double)
                        = GHC.Base.Just @ (Tensor.Restricted.Tensor GHC.Types.Double) lvl40
                      } in
                      (\ (ts :: Data.Map.Base.Map
                                  GHC.Base.String (Tensor.Restricted.Tensor GHC.Types.Double)) ->
                       lvl41)
                        `cast`
                      (UnsafeCo representational (Data.Map.Base.Map
                                                    GHC.Base.String
                                                    (Tensor.Restricted.Tensor GHC.Types.Double)
                                                  -> GHC.Base.Maybe
                                                       (Tensor.Restricted.Tensor
                                                          GHC.Types.Double)) (Main.HappyAbsSyn
                                                                                t1)) }) -}
472f64bae4055364ab52cba5677b4a15
  happyReduction_12 ::
    forall {t4} {t1}. Main.HappyAbsSyn t4 -> Main.HappyAbsSyn t1
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ @ t4 @ t1 (happy_x_1 :: Main.HappyAbsSyn t4) ->
                 case happy_x_1
                        `cast`
                      (UnsafeCo representational (Main.HappyAbsSyn
                                                    t4) Lekser.Token) of wild {
                   DEFAULT -> Main.happyReduction_40 @ t1
                   Lekser.Real happy_var_1
                   -> let {
                        lvl40 :: Tensor.Restricted.Tensor GHC.Types.Double
                        = case happy_var_1 of dt { GHC.Types.D# ipv ->
                          Tensor.Restricted.Scalar @ GHC.Types.Double dt }
                      } in
                      let {
                        lvl41 :: GHC.Base.Maybe (Tensor.Restricted.Tensor GHC.Types.Double)
                        = GHC.Base.Just @ (Tensor.Restricted.Tensor GHC.Types.Double) lvl40
                      } in
                      (\ (ts :: Data.Map.Base.Map
                                  GHC.Base.String (Tensor.Restricted.Tensor GHC.Types.Double)) ->
                       lvl41)
                        `cast`
                      (UnsafeCo representational (Data.Map.Base.Map
                                                    GHC.Base.String
                                                    (Tensor.Restricted.Tensor GHC.Types.Double)
                                                  -> GHC.Base.Maybe
                                                       (Tensor.Restricted.Tensor
                                                          GHC.Types.Double)) (Main.HappyAbsSyn
                                                                                t1)) }) -}
4807c9eb30ae4bf88f8de69cd95b3016
  happyReduction_13 ::
    forall {t4} {t1}. Main.HappyAbsSyn t4 -> Main.HappyAbsSyn t1
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ @ t4 @ t1 (happy_x_1 :: Main.HappyAbsSyn t4) ->
                 case happy_x_1
                        `cast`
                      (UnsafeCo representational (Main.HappyAbsSyn
                                                    t4) Lekser.Token) of wild {
                   DEFAULT -> Main.happyReduction_41 @ t1
                   Lekser.Index happy_var_1
                   -> (\ (ts :: Data.Map.Base.Map
                                  GHC.Base.String (Tensor.Restricted.Tensor GHC.Types.Double)) ->
                       Main.$slookup1
                         @ (Tensor.Restricted.Tensor GHC.Types.Double)
                         happy_var_1
                         ts)
                        `cast`
                      (UnsafeCo representational (Data.Map.Base.Map
                                                    GHC.Base.String
                                                    (Tensor.Restricted.Tensor GHC.Types.Double)
                                                  -> GHC.Base.Maybe
                                                       (Tensor.Restricted.Tensor
                                                          GHC.Types.Double)) (Main.HappyAbsSyn
                                                                                t1)) }) -}
d019a56e1a817530480021db5a6dced8
  happyReduction_14 ::
    forall {t} {t4} {t1}.
    Main.HappyAbsSyn t4 -> t -> Main.HappyAbsSyn t1
  {- Arity: 2, Strictness: <S,1*U><L,A><L,U>,
     Unfolding: InlineRule (0, True, True)
                Main.happyReduction_42
                  `cast`
                (forall (t :: <*>_N) (t4 :: <*>_N) (t1 :: <*>_N).
                 <Main.HappyAbsSyn t4>_R
                 ->_R <t>_R
                 ->_R UnsafeCo representational (Data.Map.Base.Map
                                                   GHC.Base.String
                                                   (Tensor.Restricted.Tensor GHC.Types.Double)
                                                 -> GHC.Base.Maybe
                                                      (Tensor.Restricted.Tensor
                                                         GHC.Types.Double)) (Main.HappyAbsSyn
                                                                               t1)) -}
783a6288522afd7f36e7771e4658ecd3
  happyReduction_15 ::
    forall {t4} {t1}. Main.HappyAbsSyn t4 -> Main.HappyAbsSyn t1
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U>,
     Unfolding: InlineRule (0, True, True)
                Main.happyReduction_48
                  `cast`
                (forall (t4 :: <*>_N) (t1 :: <*>_N).
                 <Main.HappyAbsSyn t4>_R ->_R (Main.HappyAbsSyn <t4, t1>)_R) -}
d96b7afbf5033cfff4ac265cce7100fb
  happyReduction_16 ::
    forall {t4} {t1}. Main.HappyAbsSyn t4 -> Main.HappyAbsSyn t1
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ @ t4 @ t1 (happy_x_1 :: Main.HappyAbsSyn t4) ->
                 case happy_x_1
                        `cast`
                      (UnsafeCo representational (Main.HappyAbsSyn
                                                    t4) Lekser.Token) of wild {
                   DEFAULT -> Main.happyReduction_49 @ t1
                   Lekser.Name happy_var_1
                   -> (\ (ts :: Data.Map.Base.Map
                                  GHC.Base.String (Tensor.Restricted.Tensor GHC.Types.Double)) ->
                       Main.$slookup1
                         @ (Tensor.Restricted.Tensor GHC.Types.Double)
                         happy_var_1
                         ts)
                        `cast`
                      (UnsafeCo representational (Data.Map.Base.Map
                                                    GHC.Base.String
                                                    (Tensor.Restricted.Tensor GHC.Types.Double)
                                                  -> GHC.Base.Maybe
                                                       (Tensor.Restricted.Tensor
                                                          GHC.Types.Double)) (Main.HappyAbsSyn
                                                                                t1)) }) -}
92386803cac05d6c9f4f27386842de1f
  happyReduction_17 ::
    forall {t4} {t1}. Main.HappyAbsSyn t4 -> Main.HappyAbsSyn t1
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U>,
     Unfolding: InlineRule (0, True, True)
                Main.happyReduction_48
                  `cast`
                (forall (t4 :: <*>_N) (t1 :: <*>_N).
                 <Main.HappyAbsSyn t4>_R ->_R (Main.HappyAbsSyn <t4, t1>)_R) -}
2844881fdd30f6f6f56580075b83a39d
  happyReduction_18 ::
    forall {t4} {t1} {t2} {t3}.
    Main.HappyAbsSyn t2
    -> Main.HappyAbsSyn t1
    -> Main.HappyAbsSyn t4
    -> Main.HappyAbsSyn t3
  {- Arity: 3, Strictness: <L,U><S,1*U><L,U>,
     Unfolding: (\ @ t4
                   @ t1
                   @ t2
                   @ t3
                   (happy_x_3 :: Main.HappyAbsSyn t2)
                   (happy_x_2 :: Main.HappyAbsSyn t1)
                   (happy_x_1 :: Main.HappyAbsSyn t4) ->
                 case happy_x_2
                        `cast`
                      (UnsafeCo representational (Main.HappyAbsSyn
                                                    t1) Lekser.Token) of wild {
                   DEFAULT -> Main.happyReduction_51 @ t3
                   Lekser.InfiksAddNum happy_var_2
                   -> (\ (ts :: Data.Map.Base.Map
                                  GHC.Base.String (Tensor.Restricted.Tensor GHC.Types.Double)) ->
                       case happy_var_2 of wild1 {
                         [] -> Main.happyReduction_50
                         : ds ds1
                         -> case ds of wild2 { GHC.Types.C# ds2 ->
                            case ds2 of ds3 {
                              DEFAULT -> Main.happyReduction_50
                              '+'#
                              -> case ds1 of wild3 {
                                   []
                                   -> case happy_x_1
                                             `cast`
                                           (UnsafeCo representational (Main.HappyAbsSyn
                                                                         t4) (Data.Map.Base.Map
                                                                                GHC.Base.String
                                                                                (Tensor.Restricted.Tensor
                                                                                   GHC.Types.Double)
                                                                              -> GHC.Base.Maybe
                                                                                   (Tensor.Restricted.Tensor
                                                                                      GHC.Types.Double)))
                                             ts of wild4 {
                                        GHC.Base.Nothing
                                        -> GHC.Base.Nothing
                                             @ (Tensor.Restricted.Tensor GHC.Types.Double)
                                        GHC.Base.Just x
                                        -> case happy_x_3
                                                  `cast`
                                                (UnsafeCo representational (Main.HappyAbsSyn
                                                                              t2) (Data.Map.Base.Map
                                                                                     GHC.Base.String
                                                                                     (Tensor.Restricted.Tensor
                                                                                        GHC.Types.Double)
                                                                                   -> GHC.Base.Maybe
                                                                                        (Tensor.Restricted.Tensor
                                                                                           GHC.Types.Double)))
                                                  ts of wild5 {
                                             GHC.Base.Nothing
                                             -> GHC.Base.Nothing
                                                  @ (Tensor.Restricted.Tensor GHC.Types.Double)
                                             GHC.Base.Just x1
                                             -> GHC.Base.Just
                                                  @ (Tensor.Restricted.Tensor GHC.Types.Double)
                                                  (Tensor.Restricted.$fFloatingTensor5
                                                     @ GHC.Types.Double
                                                     GHC.Float.$fNumDouble
                                                     x
                                                     x1) } }
                                   : ipv ipv1 -> Main.happyReduction_50 }
                              '-'#
                              -> case ds1 of wild3 {
                                   []
                                   -> case happy_x_1
                                             `cast`
                                           (UnsafeCo representational (Main.HappyAbsSyn
                                                                         t4) (Data.Map.Base.Map
                                                                                GHC.Base.String
                                                                                (Tensor.Restricted.Tensor
                                                                                   GHC.Types.Double)
                                                                              -> GHC.Base.Maybe
                                                                                   (Tensor.Restricted.Tensor
                                                                                      GHC.Types.Double)))
                                             ts of wild4 {
                                        GHC.Base.Nothing
                                        -> GHC.Base.Nothing
                                             @ (Tensor.Restricted.Tensor GHC.Types.Double)
                                        GHC.Base.Just x
                                        -> case happy_x_3
                                                  `cast`
                                                (UnsafeCo representational (Main.HappyAbsSyn
                                                                              t2) (Data.Map.Base.Map
                                                                                     GHC.Base.String
                                                                                     (Tensor.Restricted.Tensor
                                                                                        GHC.Types.Double)
                                                                                   -> GHC.Base.Maybe
                                                                                        (Tensor.Restricted.Tensor
                                                                                           GHC.Types.Double)))
                                                  ts of wild5 {
                                             GHC.Base.Nothing
                                             -> GHC.Base.Nothing
                                                  @ (Tensor.Restricted.Tensor GHC.Types.Double)
                                             GHC.Base.Just x1
                                             -> GHC.Base.Just
                                                  @ (Tensor.Restricted.Tensor GHC.Types.Double)
                                                  (Tensor.Restricted.$fFloatingTensor3
                                                     @ GHC.Types.Double
                                                     GHC.Float.$fNumDouble
                                                     x
                                                     x1) } }
                                   : ipv ipv1 -> Main.happyReduction_50 } } } })
                        `cast`
                      (UnsafeCo representational (Data.Map.Base.Map
                                                    GHC.Base.String
                                                    (Tensor.Restricted.Tensor GHC.Types.Double)
                                                  -> GHC.Base.Maybe
                                                       (Tensor.Restricted.Tensor
                                                          GHC.Types.Double)) (Main.HappyAbsSyn
                                                                                t3)) }) -}
70ab5f93d0227240e89c5fcd2e493096
  happyReduction_19 ::
    forall {t4} {t1} {t2}.
    Main.HappyAbsSyn t1 -> Main.HappyAbsSyn t4 -> Main.HappyAbsSyn t2
  {- Arity: 2, Strictness: <L,U><L,U>,
     Unfolding: (\ @ t4
                   @ t1
                   @ t2
                   (happy_x_2 :: Main.HappyAbsSyn t1)
                   (happy_x_1 :: Main.HappyAbsSyn t4) ->
                 let {
                   lvl40 :: GHC.Base.String
                   = case happy_x_1
                            `cast`
                          (UnsafeCo representational (Main.HappyAbsSyn
                                                        t4) Tensor.Index.TIndex) of wild {
                       Tensor.Index.Covariant dt ds2 -> ds2
                       Tensor.Index.Contravariant dt ds2 -> ds2
                       Tensor.Index.Indifferent dt ds2 -> ds2 }
                 } in
                 (\ (ts :: Data.Map.Base.Map
                             GHC.Base.String (Tensor.Restricted.Tensor GHC.Types.Double)) ->
                  GHC.Base.Just
                    @ (Tensor.Restricted.Tensor GHC.Types.Double)
                    (Tensor.Restricted.$fMultilinearTensor_$cgenerate
                       @ GHC.Types.Double
                       happy_x_1
                         `cast`
                       (UnsafeCo representational (Main.HappyAbsSyn
                                                     t4) Tensor.Index.TIndex)
                       (\ (i :: GHC.Types.Int) ->
                        case happy_x_2
                               `cast`
                             (UnsafeCo representational (Main.HappyAbsSyn t1) (Data.Map.Base.Map
                                                                                 GHC.Base.String
                                                                                 (Tensor.Restricted.Tensor
                                                                                    GHC.Types.Double)
                                                                               -> GHC.Base.Maybe
                                                                                    (Tensor.Restricted.Tensor
                                                                                       GHC.Types.Double)))
                               (case i of wild { GHC.Types.I# i1 ->
                                Main.$sinsert_$sgo4
                                  @ (Tensor.Restricted.Tensor GHC.Types.Double)
                                  lvl40
                                  (Tensor.Restricted.Scalar
                                     @ GHC.Types.Double
                                     (GHC.Types.D# (GHC.Prim.int2Double# i1)))
                                  ts }) of wild {
                          GHC.Base.Nothing
                          -> Data.Maybe.fromJust1
                               @ (Tensor.Restricted.Tensor GHC.Types.Double)
                          GHC.Base.Just x -> x })))
                   `cast`
                 (UnsafeCo representational (Data.Map.Base.Map
                                               GHC.Base.String
                                               (Tensor.Restricted.Tensor GHC.Types.Double)
                                             -> GHC.Base.Maybe
                                                  (Tensor.Restricted.Tensor
                                                     GHC.Types.Double)) (Main.HappyAbsSyn t2))) -}
cda1cea845ee1ba57292f9b7d8803ce3
  happyReduction_2 ::
    forall {t} {t4} {t1} {t2}.
    Main.HappyAbsSyn t1
    -> t -> Main.HappyAbsSyn t4 -> Main.HappyAbsSyn t2
  {- Arity: 3, Strictness: <L,U><L,A><S,1*U>, Inline: INLINE[0],
     Unfolding: InlineRule (3, True, True)
                (\ @ t
                   @ t4
                   @ t1
                   @ t2
                   (w :: Main.HappyAbsSyn t1)
                   (w1 :: t)
                   (w2 :: Main.HappyAbsSyn t4) ->
                 Main.$whappyReduction_2 @ t @ t4 @ t1 @ t2 w w2) -}
a4ebe94823383b11c9342c5b3bdfc466
  happyReduction_20 ::
    forall {t4} {t1}. Main.HappyAbsSyn t4 -> Main.HappyAbsSyn t1
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U>,
     Unfolding: InlineRule (0, True, True)
                Main.happyReduction_48
                  `cast`
                (forall (t4 :: <*>_N) (t1 :: <*>_N).
                 <Main.HappyAbsSyn t4>_R ->_R (Main.HappyAbsSyn <t4, t1>)_R) -}
19f1effeaed412b9cf143e3d0fb22ccc
  happyReduction_21 ::
    forall {t4} {t1}. Main.HappyAbsSyn t4 -> Main.HappyAbsSyn t1
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U>,
     Unfolding: InlineRule (0, True, True)
                Main.happyReduction_48
                  `cast`
                (forall (t4 :: <*>_N) (t1 :: <*>_N).
                 <Main.HappyAbsSyn t4>_R ->_R (Main.HappyAbsSyn <t4, t1>)_R) -}
42f64bbd8ca345511bd093ac3d088a4e
  happyReduction_22 ::
    forall {t4} {t1} {t2} {t3}.
    Main.HappyAbsSyn t2
    -> Main.HappyAbsSyn t1
    -> Main.HappyAbsSyn t4
    -> Main.HappyAbsSyn t3
  {- Arity: 3, Strictness: <L,U><S,1*U><L,U>,
     Unfolding: (\ @ t4
                   @ t1
                   @ t2
                   @ t3
                   (happy_x_3 :: Main.HappyAbsSyn t2)
                   (happy_x_2 :: Main.HappyAbsSyn t1)
                   (happy_x_1 :: Main.HappyAbsSyn t4) ->
                 case happy_x_2
                        `cast`
                      (UnsafeCo representational (Main.HappyAbsSyn
                                                    t1) Lekser.Token) of wild {
                   DEFAULT -> Main.happyReduction_59 @ t3
                   Lekser.InfiksMultNum happy_var_2
                   -> (\ (ts :: Data.Map.Base.Map
                                  GHC.Base.String (Tensor.Restricted.Tensor GHC.Types.Double)) ->
                       case happy_var_2 of wild1 {
                         [] -> Main.happyReduction_58
                         : ds ds1
                         -> case ds of wild2 { GHC.Types.C# ds2 ->
                            case ds2 of ds3 {
                              DEFAULT -> Main.happyReduction_58
                              '*'#
                              -> case ds1 of wild3 {
                                   []
                                   -> case happy_x_1
                                             `cast`
                                           (UnsafeCo representational (Main.HappyAbsSyn
                                                                         t4) (Data.Map.Base.Map
                                                                                GHC.Base.String
                                                                                (Tensor.Restricted.Tensor
                                                                                   GHC.Types.Double)
                                                                              -> GHC.Base.Maybe
                                                                                   (Tensor.Restricted.Tensor
                                                                                      GHC.Types.Double)))
                                             ts of wild4 {
                                        GHC.Base.Nothing
                                        -> GHC.Base.Nothing
                                             @ (Tensor.Restricted.Tensor GHC.Types.Double)
                                        GHC.Base.Just x
                                        -> case happy_x_3
                                                  `cast`
                                                (UnsafeCo representational (Main.HappyAbsSyn
                                                                              t2) (Data.Map.Base.Map
                                                                                     GHC.Base.String
                                                                                     (Tensor.Restricted.Tensor
                                                                                        GHC.Types.Double)
                                                                                   -> GHC.Base.Maybe
                                                                                        (Tensor.Restricted.Tensor
                                                                                           GHC.Types.Double)))
                                                  ts of wild5 {
                                             GHC.Base.Nothing
                                             -> GHC.Base.Nothing
                                                  @ (Tensor.Restricted.Tensor GHC.Types.Double)
                                             GHC.Base.Just x1
                                             -> GHC.Base.Just
                                                  @ (Tensor.Restricted.Tensor GHC.Types.Double)
                                                  (Tensor.Restricted.$fFloatingTensor26
                                                     @ GHC.Types.Double
                                                     GHC.Float.$fNumDouble
                                                     x
                                                     x1) } }
                                   : ipv ipv1 -> Main.happyReduction_58 }
                              '/'#
                              -> case ds1 of wild3 {
                                   []
                                   -> case happy_x_1
                                             `cast`
                                           (UnsafeCo representational (Main.HappyAbsSyn
                                                                         t4) (Data.Map.Base.Map
                                                                                GHC.Base.String
                                                                                (Tensor.Restricted.Tensor
                                                                                   GHC.Types.Double)
                                                                              -> GHC.Base.Maybe
                                                                                   (Tensor.Restricted.Tensor
                                                                                      GHC.Types.Double)))
                                             ts of wild4 {
                                        GHC.Base.Nothing
                                        -> GHC.Base.Nothing
                                             @ (Tensor.Restricted.Tensor GHC.Types.Double)
                                        GHC.Base.Just x
                                        -> case happy_x_3
                                                  `cast`
                                                (UnsafeCo representational (Main.HappyAbsSyn
                                                                              t2) (Data.Map.Base.Map
                                                                                     GHC.Base.String
                                                                                     (Tensor.Restricted.Tensor
                                                                                        GHC.Types.Double)
                                                                                   -> GHC.Base.Maybe
                                                                                        (Tensor.Restricted.Tensor
                                                                                           GHC.Types.Double)))
                                                  ts of wild5 {
                                             GHC.Base.Nothing
                                             -> GHC.Base.Nothing
                                                  @ (Tensor.Restricted.Tensor GHC.Types.Double)
                                             GHC.Base.Just x1
                                             -> GHC.Base.Just
                                                  @ (Tensor.Restricted.Tensor GHC.Types.Double)
                                                  (Tensor.Restricted.$fFloatingTensor17
                                                     @ GHC.Types.Double
                                                     GHC.Float.$fFractionalDouble
                                                     x
                                                     x1) } }
                                   : ipv ipv1 -> Main.happyReduction_58 } } } })
                        `cast`
                      (UnsafeCo representational (Data.Map.Base.Map
                                                    GHC.Base.String
                                                    (Tensor.Restricted.Tensor GHC.Types.Double)
                                                  -> GHC.Base.Maybe
                                                       (Tensor.Restricted.Tensor
                                                          GHC.Types.Double)) (Main.HappyAbsSyn
                                                                                t3)) }) -}
37f89f721fffdf8ffd708b90467fa61c
  happyReduction_23 ::
    forall {t4} {t1}. Main.HappyAbsSyn t4 -> Main.HappyAbsSyn t1
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U>,
     Unfolding: InlineRule (0, True, True)
                Main.happyReduction_48
                  `cast`
                (forall (t4 :: <*>_N) (t1 :: <*>_N).
                 <Main.HappyAbsSyn t4>_R ->_R (Main.HappyAbsSyn <t4, t1>)_R) -}
114ba9f41b7d1fe0b4c710691f7cd6c5
  happyReduction_24 ::
    forall {t4} {t1} {t2}.
    Main.HappyAbsSyn t1 -> Main.HappyAbsSyn t4 -> Main.HappyAbsSyn t2
  {- Arity: 2, Strictness: <L,U><S,1*U> -}
92fae933f7f5e2eaa66408c5ce259366
  happyReduction_25 ::
    forall {t4} {t1} {t2}.
    Main.HappyAbsSyn t1 -> Main.HappyAbsSyn t4 -> Main.HappyAbsSyn t2
  {- Arity: 2, Strictness: <L,U><S,1*U>,
     Unfolding: (\ @ t4
                   @ t1
                   @ t2
                   (happy_x_2 :: Main.HappyAbsSyn t1)
                   (happy_x_1 :: Main.HappyAbsSyn t4) ->
                 case happy_x_1
                        `cast`
                      (UnsafeCo representational (Main.HappyAbsSyn
                                                    t4) Lekser.Token) of wild {
                   DEFAULT -> Main.happyReduction_62 @ t2
                   Lekser.TensUnary happy_var_1
                   -> let {
                        lvl40 :: GHC.Types.Bool
                        = GHC.Base.eqString happy_var_1 Main.happyReduction_61
                      } in
                      (\ (ts :: Data.Map.Base.Map
                                  GHC.Base.String (Tensor.Restricted.Tensor GHC.Types.Double)) ->
                       case lvl40 of wild1 {
                         GHC.Types.False -> Main.happyReduction_60
                         GHC.Types.True
                         -> case happy_x_2
                                   `cast`
                                 (UnsafeCo representational (Main.HappyAbsSyn t1) (Data.Map.Base.Map
                                                                                     GHC.Base.String
                                                                                     (Tensor.Restricted.Tensor
                                                                                        GHC.Types.Double)
                                                                                   -> GHC.Base.Maybe
                                                                                        (Tensor.Restricted.Tensor
                                                                                           GHC.Types.Double)))
                                   ts of wild2 {
                              GHC.Base.Nothing
                              -> GHC.Base.Nothing @ (Tensor.Restricted.Tensor GHC.Types.Double)
                              GHC.Base.Just x
                              -> GHC.Base.Just
                                   @ (Tensor.Restricted.Tensor GHC.Types.Double)
                                   (Tensor.Restricted.$fMultilinearTensor2
                                      @ GHC.Types.Double
                                      x) } })
                        `cast`
                      (UnsafeCo representational (Data.Map.Base.Map
                                                    GHC.Base.String
                                                    (Tensor.Restricted.Tensor GHC.Types.Double)
                                                  -> GHC.Base.Maybe
                                                       (Tensor.Restricted.Tensor
                                                          GHC.Types.Double)) (Main.HappyAbsSyn
                                                                                t2)) }) -}
c8dd84d00874545a643ee98526f64c2e
  happyReduction_26 ::
    forall {t4} {t1}. Main.HappyAbsSyn t4 -> Main.HappyAbsSyn t1
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U>,
     Unfolding: InlineRule (0, True, True)
                Main.happyReduction_48
                  `cast`
                (forall (t4 :: <*>_N) (t1 :: <*>_N).
                 <Main.HappyAbsSyn t4>_R ->_R (Main.HappyAbsSyn <t4, t1>)_R) -}
21c5abb4ecf3f69399dd66d9b67400f7
  happyReduction_27 ::
    forall {t4} {t1} {t2} {t3}.
    Main.HappyAbsSyn t2
    -> Main.HappyAbsSyn t1
    -> Main.HappyAbsSyn t4
    -> Main.HappyAbsSyn t3
  {- Arity: 3, Strictness: <L,U><S,1*U><L,U>,
     Unfolding: (\ @ t4
                   @ t1
                   @ t2
                   @ t3
                   (happy_x_3 :: Main.HappyAbsSyn t2)
                   (happy_x_2 :: Main.HappyAbsSyn t1)
                   (happy_x_1 :: Main.HappyAbsSyn t4) ->
                 case happy_x_2
                        `cast`
                      (UnsafeCo representational (Main.HappyAbsSyn
                                                    t1) Lekser.Token) of wild {
                   DEFAULT -> Main.happyReduction_64 @ t3
                   Lekser.InfiksPowNum happy_var_2
                   -> (\ (ts :: Data.Map.Base.Map
                                  GHC.Base.String (Tensor.Restricted.Tensor GHC.Types.Double)) ->
                       case happy_var_2 of wild1 {
                         [] -> Main.happyReduction_63
                         : ds ds1
                         -> case ds of wild2 { GHC.Types.C# ds2 ->
                            case ds2 of ds3 {
                              DEFAULT -> Main.happyReduction_63
                              '^'#
                              -> case ds1 of wild3 {
                                   []
                                   -> case happy_x_1
                                             `cast`
                                           (UnsafeCo representational (Main.HappyAbsSyn
                                                                         t4) (Data.Map.Base.Map
                                                                                GHC.Base.String
                                                                                (Tensor.Restricted.Tensor
                                                                                   GHC.Types.Double)
                                                                              -> GHC.Base.Maybe
                                                                                   (Tensor.Restricted.Tensor
                                                                                      GHC.Types.Double)))
                                             ts of wild4 {
                                        GHC.Base.Nothing
                                        -> GHC.Base.Nothing
                                             @ (Tensor.Restricted.Tensor GHC.Types.Double)
                                        GHC.Base.Just x
                                        -> case happy_x_3
                                                  `cast`
                                                (UnsafeCo representational (Main.HappyAbsSyn
                                                                              t2) (Data.Map.Base.Map
                                                                                     GHC.Base.String
                                                                                     (Tensor.Restricted.Tensor
                                                                                        GHC.Types.Double)
                                                                                   -> GHC.Base.Maybe
                                                                                        (Tensor.Restricted.Tensor
                                                                                           GHC.Types.Double)))
                                                  ts of wild5 {
                                             GHC.Base.Nothing
                                             -> GHC.Base.Nothing
                                                  @ (Tensor.Restricted.Tensor GHC.Types.Double)
                                             GHC.Base.Just x1
                                             -> GHC.Base.Just
                                                  @ (Tensor.Restricted.Tensor GHC.Types.Double)
                                                  (Tensor.Restricted.$fFloatingTensor2
                                                     @ GHC.Types.Double
                                                     GHC.Float.$fFloatingDouble
                                                     (Tensor.Restricted.$fFloatingTensor26
                                                        @ GHC.Types.Double
                                                        GHC.Float.$fNumDouble
                                                        (Tensor.Restricted.$fFloatingTensor6
                                                           @ GHC.Types.Double
                                                           GHC.Float.$fFloatingDouble
                                                           x)
                                                        x1)) } }
                                   : ipv ipv1 -> Main.happyReduction_63 } } } })
                        `cast`
                      (UnsafeCo representational (Data.Map.Base.Map
                                                    GHC.Base.String
                                                    (Tensor.Restricted.Tensor GHC.Types.Double)
                                                  -> GHC.Base.Maybe
                                                       (Tensor.Restricted.Tensor
                                                          GHC.Types.Double)) (Main.HappyAbsSyn
                                                                                t3)) }) -}
222c48621d2a589d50f7e21ae23cc8d5
  happyReduction_28 ::
    forall {t4} {t1}. Main.HappyAbsSyn t4 -> Main.HappyAbsSyn t1
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U>,
     Unfolding: InlineRule (0, True, True)
                Main.happyReduction_48
                  `cast`
                (forall (t4 :: <*>_N) (t1 :: <*>_N).
                 <Main.HappyAbsSyn t4>_R ->_R (Main.HappyAbsSyn <t4, t1>)_R) -}
2381832a05bc132886ffe4fcc7332ab4
  happyReduction_29 ::
    forall {t} {t1} {t4} {t2}.
    t -> Main.HappyAbsSyn t4 -> t1 -> Main.HappyAbsSyn t2
  {- Arity: 3, HasNoCafRefs, Strictness: <L,A><S,1*U><L,A>,
     Unfolding: InlineRule (0, True, True)
                Main.happyReduction_65
                  `cast`
                (forall (t :: <*>_N) (t1 :: <*>_N) (t4 :: <*>_N) (t2 :: <*>_N).
                 <t>_R
                 ->_R <Main.HappyAbsSyn t4>_R
                 ->_R <t1>_R
                 ->_R (Main.HappyAbsSyn <t4, t2>)_R) -}
6cb79e0e2b7ca77befe679abd4fb546f
  happyReduction_3 ::
    forall {t4} {t1}. Main.HappyAbsSyn t4 -> Main.HappyAbsSyn t1
  {- Arity: 1, Strictness: <S,U><L,U><S,U>,
     Unfolding: InlineRule (0, True, True)
                Main.happyReduction_66
                  `cast`
                (forall (t4 :: <*>_N) (t1 :: <*>_N).
                 <Main.HappyAbsSyn t4>_R
                 ->_R Trans
                          (<Data.Map.Base.Map
                              GHC.Base.String (Tensor.Restricted.Tensor GHC.Types.Double)>_R
                           ->_R Sym (GHC.Types.N:IO[0]
                                         <Data.Map.Base.Map
                                            GHC.Base.String
                                            (Tensor.Restricted.Tensor GHC.Types.Double)>_R))
                          (UnsafeCo representational (Data.Map.Base.Map
                                                        GHC.Base.String
                                                        (Tensor.Restricted.Tensor GHC.Types.Double)
                                                      -> GHC.Types.IO
                                                           (Data.Map.Base.Map
                                                              GHC.Base.String
                                                              (Tensor.Restricted.Tensor
                                                                 GHC.Types.Double))) (Main.HappyAbsSyn
                                                                                        t1))) -}
13cbd8cb07b41a166eabf6f6a5df630f
  happyReduction_37 ::
    forall {t4}. Main.HappyAbsSyn t4 -> Main.HappyAbsSyn t4
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, True)
                (\ @ t4 (x :: Main.HappyAbsSyn t4) -> x) -}
ff94df48ea173fbcf4af286031a69d98
  happyReduction_38 :: forall {t4}. Main.HappyAbsSyn t4
  {- Strictness: x -}
a09875bdbc82cc5f9ee36349c9455a29
  happyReduction_39 :: forall {t4}. Main.HappyAbsSyn t4
  {- Strictness: x -}
01cfab7dc9e46bcd1272540d85460dca
  happyReduction_4 :: forall {t} {t4}. t -> Main.HappyAbsSyn t4
  {- Arity: 1, Strictness: <L,A>,
     Unfolding: InlineRule (0, True, True)
                Main.happyReduction_67
                  `cast`
                (forall (t :: <*>_N) (t4 :: <*>_N).
                 <t>_R
                 ->_R Trans
                          (<Data.Map.Base.Map
                              GHC.Base.String (Tensor.Restricted.Tensor GHC.Types.Double)>_R
                           ->_R Sym (GHC.Types.N:IO[0]
                                         <Data.Map.Base.Map
                                            GHC.Base.String
                                            (Tensor.Restricted.Tensor GHC.Types.Double)>_R))
                          (UnsafeCo representational (Data.Map.Base.Map
                                                        GHC.Base.String
                                                        (Tensor.Restricted.Tensor GHC.Types.Double)
                                                      -> GHC.Types.IO
                                                           (Data.Map.Base.Map
                                                              GHC.Base.String
                                                              (Tensor.Restricted.Tensor
                                                                 GHC.Types.Double))) (Main.HappyAbsSyn
                                                                                        t4))) -}
e0832728c055ea510024d4a09b0b9b76
  happyReduction_40 :: forall {t4}. Main.HappyAbsSyn t4
  {- Strictness: x -}
0940ffa0a919c5493c539fabc8c7800c
  happyReduction_41 :: forall {t4}. Main.HappyAbsSyn t4
  {- Strictness: x -}
b9c8d2fc2ed2ea2b1b03fd9b62c74057
  happyReduction_42 ::
    forall {t} {t4} {t1}.
    Main.HappyAbsSyn t4
    -> t
    -> Data.Map.Base.Map
         GHC.Base.String (Tensor.Restricted.Tensor GHC.Types.Double)
    -> GHC.Base.Maybe (Tensor.Restricted.Tensor GHC.Types.Double)
  {- Arity: 3, Strictness: <S,1*U><L,A><L,U>, Inline: INLINE[0],
     Unfolding: InlineRule (3, True, True)
                (\ @ t
                   @ t4
                   @ t1
                   (w :: Main.HappyAbsSyn t4)
                   (w1 :: t)
                   (w2 :: Data.Map.Base.Map
                            GHC.Base.String (Tensor.Restricted.Tensor GHC.Types.Double)) ->
                 Main.$whappyReduction_14 @ t @ t4 @ t1 w w2) -}
7a39298e516f01193514eef1246424ef
  happyReduction_43 :: Tensor.Restricted.Tensor GHC.Types.Double
  {- Unfolding: (Tensor.Restricted.$fFloatingTensor3
                   @ GHC.Types.Double
                   GHC.Float.$fNumDouble
                   Main.happyReduction_46
                   Main.happyReduction_44) -}
1c86d37976c5cc011e113d026402dc2e
  happyReduction_44 :: Tensor.Restricted.Tensor GHC.Types.Double
  {- HasNoCafRefs,
     Unfolding: (Tensor.Restricted.Scalar
                   @ GHC.Types.Double
                   Main.happyReduction_45) -}
992e71fc6853b149d8547a6720ab5134
  happyReduction_45 :: GHC.Types.Double
  {- HasNoCafRefs, Unfolding: (GHC.Types.D# 1.0##) -}
2bc6277c3a9ade767da0bab8de045149
  happyReduction_46 :: Tensor.Restricted.Tensor GHC.Types.Double
  {- HasNoCafRefs,
     Unfolding: (Tensor.Restricted.Scalar
                   @ GHC.Types.Double
                   Main.happyReduction_47) -}
96804c0dfe2b1577bacdc4df79fc409d
  happyReduction_47 :: GHC.Types.Double
  {- HasNoCafRefs, Unfolding: (GHC.Types.D# 0.0##) -}
51b56565b4fc9e77b1c8d13dd7806a7b
  happyReduction_48 ::
    forall {t4} {t1}. Main.HappyAbsSyn t4 -> Main.HappyAbsSyn t4
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, True)
                (\ @ t4 @ t1 (happy_x_1 :: Main.HappyAbsSyn t4) -> happy_x_1) -}
91ac12ea212832e29fc1f943d62ac478
  happyReduction_49 :: forall {t4}. Main.HappyAbsSyn t4
  {- Strictness: x -}
294c87077af9a5af03fa8a0a882ea53d
  happyReduction_5 :: forall {t} {t4}. t -> Main.HappyAbsSyn t4
  {- Arity: 1, Strictness: <L,A>,
     Unfolding: InlineRule (0, True, True)
                Main.happyReduction_69
                  `cast`
                (forall (t :: <*>_N) (t4 :: <*>_N).
                 <t>_R
                 ->_R Trans
                          (<Data.Map.Base.Map
                              GHC.Base.String (Tensor.Restricted.Tensor GHC.Types.Double)>_R
                           ->_R Sym (GHC.Types.N:IO[0]
                                         <Data.Map.Base.Map
                                            GHC.Base.String
                                            (Tensor.Restricted.Tensor GHC.Types.Double)>_R))
                          (UnsafeCo representational (Data.Map.Base.Map
                                                        GHC.Base.String
                                                        (Tensor.Restricted.Tensor GHC.Types.Double)
                                                      -> GHC.Types.IO
                                                           (Data.Map.Base.Map
                                                              GHC.Base.String
                                                              (Tensor.Restricted.Tensor
                                                                 GHC.Types.Double))) (Main.HappyAbsSyn
                                                                                        t4))) -}
8e1ec841e0bbcbc0b88b4128f8fd99f4
  happyReduction_50 ::
    GHC.Base.Maybe (Tensor.Restricted.Tensor GHC.Types.Double)
  {- Strictness: x -}
844418753c539bd2cea0bec9393dd654
  happyReduction_51 :: forall {t4}. Main.HappyAbsSyn t4
  {- Strictness: x -}
1ba1e1f87f91ac680389635408cb51a9
  happyReduction_52 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString#
                   "Generating tensor..."#) -}
c217fccb9bd7e52b5442b1c9989663cc
  happyReduction_53 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString#
                   "Generated! Saving session..."#) -}
357f383ee33f9b61d028066cb2e28721
  happyReduction_54 ::
    GHC.Prim.State# GHC.Prim.RealWorld
    -> (# GHC.Prim.State# GHC.Prim.RealWorld,
          GHC.IO.Handle.Types.Handle #)
  {- Arity: 1,
     Unfolding: (GHC.IO.Handle.FD.openBinaryFile1
                   Main.happyError'4
                   GHC.IO.IOMode.WriteMode) -}
5bc99ac410b49e9ee668d505fe9f4dec
  happyReduction_55 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "Variable unknown!"#) -}
bb22ad84d3ddf4e7d8a8442dbd8ee0ee
  happyReduction_56 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# " saved!"#) -}
f99fd3907d2e6d93e88a9cf557ac6491
  happyReduction_57 :: forall {t4}. Main.HappyAbsSyn t4
  {- Strictness: x -}
37cc2f1bcb220fa5e2687368afabef4c
  happyReduction_58 ::
    GHC.Base.Maybe (Tensor.Restricted.Tensor GHC.Types.Double)
  {- Strictness: x -}
f3dd9ee693ab18e7cc51e75fd7f24bf9
  happyReduction_59 :: forall {t4}. Main.HappyAbsSyn t4
  {- Strictness: x -}
2ffb0f00f3090348a22787000cccdb34
  happyReduction_6 :: forall {t} {t4}. t -> Main.HappyAbsSyn t4
  {- Arity: 1, Strictness: <L,A>,
     Unfolding: InlineRule (0, True, True)
                Main.happyReduction_71
                  `cast`
                (forall (t :: <*>_N) (t4 :: <*>_N).
                 <t>_R
                 ->_R Trans
                          (<Data.Map.Base.Map
                              GHC.Base.String (Tensor.Restricted.Tensor GHC.Types.Double)>_R
                           ->_R Sym (GHC.Types.N:IO[0]
                                         <Data.Map.Base.Map
                                            GHC.Base.String
                                            (Tensor.Restricted.Tensor GHC.Types.Double)>_R))
                          (UnsafeCo representational (Data.Map.Base.Map
                                                        GHC.Base.String
                                                        (Tensor.Restricted.Tensor GHC.Types.Double)
                                                      -> GHC.Types.IO
                                                           (Data.Map.Base.Map
                                                              GHC.Base.String
                                                              (Tensor.Restricted.Tensor
                                                                 GHC.Types.Double))) (Main.HappyAbsSyn
                                                                                        t4))) -}
9d58a761d4a23966e60f526c04a0f94b
  happyReduction_60 ::
    GHC.Base.Maybe (Tensor.Restricted.Tensor GHC.Types.Double)
  {- Strictness: x -}
929500c2196e9637a1081c9dca7e472a
  happyReduction_61 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "transpose"#) -}
46e1737fb799b86fe58dabbd55744c1c
  happyReduction_62 :: forall {t4}. Main.HappyAbsSyn t4
  {- Strictness: x -}
f155ed6cc25db32bf1f43df55bb0a4bb
  happyReduction_63 ::
    GHC.Base.Maybe (Tensor.Restricted.Tensor GHC.Types.Double)
  {- Strictness: x -}
17b5b5b7b0cf1dbae3cdd22b549be902
  happyReduction_64 :: forall {t4}. Main.HappyAbsSyn t4
  {- Strictness: x -}
8b77ab7033e155fc8f04bd9904b98842
  happyReduction_65 ::
    forall {t} {t1} {t4} {t2}.
    t -> Main.HappyAbsSyn t4 -> t1 -> Main.HappyAbsSyn t4
  {- Arity: 3, HasNoCafRefs, Strictness: <L,A><S,1*U><L,A>,
     Unfolding: InlineRule (3, True, True)
                (\ @ t
                   @ t1
                   @ t4
                   @ t2
                   (happy_x_3 :: t)
                   (happy_x_2 :: Main.HappyAbsSyn t4)
                   (happy_x_1 :: t1) ->
                 happy_x_2) -}
f7f4625a31119c33299ac0771c5b7736
  happyReduction_66 ::
    forall {t4} {t1}.
    Main.HappyAbsSyn t4
    -> Data.Map.Base.Map
         GHC.Base.String (Tensor.Restricted.Tensor GHC.Types.Double)
    -> GHC.Prim.State# GHC.Prim.RealWorld
    -> (# GHC.Prim.State# GHC.Prim.RealWorld,
          Data.Map.Base.Map
            GHC.Base.String (Tensor.Restricted.Tensor GHC.Types.Double) #)
  {- Arity: 3, Strictness: <S,U><L,U><S,U>,
     Unfolding: (\ @ t4
                   @ t1
                   (happy_x_1 :: Main.HappyAbsSyn t4)
                   (ts :: Data.Map.Base.Map
                            GHC.Base.String (Tensor.Restricted.Tensor GHC.Types.Double))
                   (s :: GHC.Prim.State# GHC.Prim.RealWorld)[OneShot] ->
                 case happy_x_1
                        `cast`
                      (UnsafeCo representational (Main.HappyAbsSyn t4) (Data.Map.Base.Map
                                                                          GHC.Base.String
                                                                          (Tensor.Restricted.Tensor
                                                                             GHC.Types.Double)
                                                                        -> GHC.Base.Maybe
                                                                             (Tensor.Restricted.Tensor
                                                                                GHC.Types.Double)))
                        ts of wild {
                   GHC.Base.Nothing
                   -> case GHC.IO.Handle.Text.hPutStr2
                             GHC.IO.Handle.FD.stdout
                             Main.happyReduction_55
                             GHC.Types.True
                             s of ds1 { (#,#) ipv ipv1 ->
                      (# ipv, ts #) }
                   GHC.Base.Just ipv
                   -> case GHC.IO.Handle.Text.hPutStr2
                             GHC.IO.Handle.FD.stdout
                             (Tensor.Restricted.$fShowTensor2
                                @ GHC.Types.Double
                                GHC.Float.$fShowDouble
                                ipv)
                             GHC.Types.True
                             s of ds1 { (#,#) ipv1 ipv2 ->
                      (# ipv1, ts #) } }) -}
e48cf7714d158341b6b65b543ddfa6f6
  happyReduction_67 ::
    forall {t} {t4}.
    t
    -> Data.Map.Base.Map
         GHC.Base.String (Tensor.Restricted.Tensor GHC.Types.Double)
    -> GHC.Prim.State# GHC.Prim.RealWorld
    -> (# GHC.Prim.State# GHC.Prim.RealWorld,
          Data.Map.Base.Map
            GHC.Base.String (Tensor.Restricted.Tensor GHC.Types.Double) #)
  {- Arity: 3, Strictness: <L,A>,
     Unfolding: InlineRule (1, True, True)
                (\ @ t
                   @ t4
                   (happy_x_1 :: t)
                   (eta :: Data.Map.Base.Map
                             GHC.Base.String (Tensor.Restricted.Tensor GHC.Types.Double))
                   (eta1 :: GHC.Prim.State# GHC.Prim.RealWorld)[OneShot] ->
                 Main.happyReduction_68 eta eta1) -}
19755394d83205b64909e0316d8a3d8e
  happyReduction_68 ::
    Data.Map.Base.Map
      GHC.Base.String (Tensor.Restricted.Tensor GHC.Types.Double)
    -> GHC.Prim.State# GHC.Prim.RealWorld
    -> (# GHC.Prim.State# GHC.Prim.RealWorld,
          Data.Map.Base.Map
            GHC.Base.String (Tensor.Restricted.Tensor GHC.Types.Double) #)
  {- Arity: 2, Strictness: <B,A><B,U>x,
     Unfolding: InlineRule (2, True, True)
                (\ (ts :: Data.Map.Base.Map
                            GHC.Base.String (Tensor.Restricted.Tensor GHC.Types.Double))
                   (eta :: GHC.Prim.State# GHC.Prim.RealWorld)[OneShot] ->
                 System.Exit.exitSuccess1
                   @ (Data.Map.Base.Map
                        GHC.Base.String (Tensor.Restricted.Tensor GHC.Types.Double))
                   eta) -}
a0941519891dce44a6fa1afc014bdd27
  happyReduction_69 ::
    forall {t} {t4}.
    t
    -> Data.Map.Base.Map
         GHC.Base.String (Tensor.Restricted.Tensor GHC.Types.Double)
    -> GHC.Prim.State# GHC.Prim.RealWorld
    -> (# GHC.Prim.State# GHC.Prim.RealWorld,
          Data.Map.Base.Map
            GHC.Base.String (Tensor.Restricted.Tensor GHC.Types.Double) #)
  {- Arity: 3, Strictness: <L,A>,
     Unfolding: InlineRule (1, True, True)
                (\ @ t
                   @ t4
                   (happy_x_1 :: t)
                   (eta :: Data.Map.Base.Map
                             GHC.Base.String (Tensor.Restricted.Tensor GHC.Types.Double))
                   (eta1 :: GHC.Prim.State# GHC.Prim.RealWorld)[OneShot] ->
                 Main.happyReduction_70 eta eta1) -}
98e6bddbfe5b438b7627ccfa50704062
  happyReduction_7 ::
    forall {t} {t4} {t1}.
    Main.HappyAbsSyn t4 -> t -> Main.HappyAbsSyn t1
  {- Arity: 2, Strictness: <S,1*U><L,A>, Inline: INLINE[0],
     Unfolding: InlineRule (2, True, True)
                (\ @ t @ t4 @ t1 (w :: Main.HappyAbsSyn t4) (w1 :: t) ->
                 Main.$whappyReduction_7 @ t @ t4 @ t1 w) -}
6e170f7d94c3ffb9e1202a7f698cf0b8
  happyReduction_70 ::
    Data.Map.Base.Map
      GHC.Base.String (Tensor.Restricted.Tensor GHC.Types.Double)
    -> GHC.Prim.State# GHC.Prim.RealWorld
    -> (# GHC.Prim.State# GHC.Prim.RealWorld,
          Data.Map.Base.Map
            GHC.Base.String (Tensor.Restricted.Tensor GHC.Types.Double) #)
  {- Arity: 2, Strictness: <L,U><S,U>,
     Unfolding: (\ (ts :: Data.Map.Base.Map
                            GHC.Base.String (Tensor.Restricted.Tensor GHC.Types.Double))
                   (s :: GHC.Prim.State# GHC.Prim.RealWorld)[OneShot] ->
                 case GHC.IO.Handle.Text.hPutStr2
                        GHC.IO.Handle.FD.stdout
                        (GHC.Show.showList__
                           @ [GHC.Types.Char]
                           GHC.Show.shows_$cshowList
                           (Data.Map.Base.keys1
                              @ (Tensor.Restricted.Tensor GHC.Types.Double)
                              @ [GHC.Types.Char]
                              (GHC.Types.[] @ [GHC.Types.Char])
                              ts)
                           (GHC.Types.[] @ GHC.Types.Char))
                        GHC.Types.True
                        s of ds1 { (#,#) ipv ipv1 ->
                 (# ipv, ts #) }) -}
b9b34e163ac0eaceb20ffb2b224192ce
  happyReduction_71 ::
    forall {t} {t4}.
    t
    -> Data.Map.Base.Map
         GHC.Base.String (Tensor.Restricted.Tensor GHC.Types.Double)
    -> GHC.Prim.State# GHC.Prim.RealWorld
    -> (# GHC.Prim.State# GHC.Prim.RealWorld,
          Data.Map.Base.Map
            GHC.Base.String (Tensor.Restricted.Tensor GHC.Types.Double) #)
  {- Arity: 3, Strictness: <L,A>,
     Unfolding: InlineRule (1, True, True)
                (\ @ t
                   @ t4
                   (happy_x_1 :: t)
                   (eta :: Data.Map.Base.Map
                             GHC.Base.String (Tensor.Restricted.Tensor GHC.Types.Double))
                   (eta1 :: GHC.Prim.State# GHC.Prim.RealWorld)[OneShot] ->
                 Main.happyReduction_72 eta eta1) -}
af31912b5b493b80d704ac097d11d712
  happyReduction_72 ::
    Data.Map.Base.Map
      GHC.Base.String (Tensor.Restricted.Tensor GHC.Types.Double)
    -> GHC.Prim.State# GHC.Prim.RealWorld
    -> (# GHC.Prim.State# GHC.Prim.RealWorld,
          Data.Map.Base.Map
            GHC.Base.String (Tensor.Restricted.Tensor GHC.Types.Double) #)
  {- Arity: 2, Strictness: <L,A><S,U>, Inline: INLINE[0],
     Unfolding: InlineRule (2, True, True)
                (\ (w :: Data.Map.Base.Map
                           GHC.Base.String (Tensor.Restricted.Tensor GHC.Types.Double))
                   (w1 :: GHC.Prim.State# GHC.Prim.RealWorld)[OneShot] ->
                 Main.$wlvl w1) -}
5ac82ab47003fb8ed113607afe1c4b6e
  happyReduction_73 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString#
                   "Variable bindings cleared!"#) -}
7779d4369085d3e33501ccb418614918
  happyReduction_74 ::
    GHC.IO.Handle.Types.Handle
    -> GHC.Prim.State# GHC.Prim.RealWorld
    -> (# GHC.Prim.State# GHC.Prim.RealWorld, () #)
  {- Arity: 2,
     Unfolding: (\ (hdl :: GHC.IO.Handle.Types.Handle)[OneShot]
                   (eta1 :: GHC.Prim.State# GHC.Prim.RealWorld)[OneShot] ->
                 Data.ByteString.Lazy.appendFile2
                   hdl
                   Main.happyReduction_75
                   eta1) -}
83d84bfcc1e74bdad7a42172137367e7
  happyReduction_75 :: Data.ByteString.Lazy.Internal.ByteString
  {- Unfolding: (Codec.Compression.Zlib.Internal.foldCompressStreamWithInput
                   @ Data.ByteString.Lazy.Internal.ByteString
                   Data.ByteString.Lazy.Internal.$WChunk
                   Data.ByteString.Lazy.Internal.Empty
                   Codec.Compression.GZip.compress1
                   Main.happyReduction_76) -}
c65ded95f7998f00c0650804c760f107
  happyReduction_76 :: Data.ByteString.Lazy.Internal.ByteString
  {- Unfolding: (Data.ByteString.Builder.toLazyByteString
                   Main.happyReduction_77) -}
8663eb0fa308ca9db5127f4846d03abe
  happyReduction_77 :: Data.ByteString.Builder.Internal.Builder
  {- Unfolding: (case Data.Binary.Class.$w$cput18
                        @ [GHC.Types.Char]
                        @ (Tensor.Restricted.Tensor GHC.Types.Double)
                        Data.Binary.Class.$fBinaryVersion_$s$fBinary[]
                        Main.$s$fBinaryMap_$s$fBinaryTensor
                        (Data.Map.Base.Tip
                           @ GHC.Base.String
                           @ (Tensor.Restricted.Tensor
                                GHC.Types.Double)) of ww { (#,#) ww1 ww2 ->
                 ww2 }) -}
cde2ed0fc8ae55bb97d80148b54fe92a
  happyReduction_78 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# " deleted!"#) -}
ee88debef1f2a8f691126ee0f2db3660
  happyReduction_79 :: forall {t4}. Main.HappyAbsSyn t4
  {- Strictness: x -}
7d46f90ad363dd5f0238ca210829b3ed
  happyReduction_8 ::
    forall {t4}.
    Main.HappyStk (Main.HappyAbsSyn t4)
    -> Main.HappyStk (Main.HappyAbsSyn t4)
  {- Arity: 1,
     Strictness: <S(LS(SS(LS(SS)))),1*U(A,1*U(1*U,1*U(A,1*U(1*U,1*U(A,U)))))>m,
     Inline: INLINE[0],
     Unfolding: InlineRule (1, True, False)
                (\ @ t4 (w :: Main.HappyStk (Main.HappyAbsSyn t4)) ->
                 case w of ww { Main.HappyStk ww1 ww2 ->
                 case ww2 of ww3 { Main.HappyStk ww4 ww5 ->
                 case ww5 of ww6 { Main.HappyStk ww7 ww8 ->
                 case ww8 of ww9 { Main.HappyStk ww10 ww11 ->
                 case ww11 of ww12 { Main.HappyStk ww13 ww14 ->
                 case ww10
                        `cast`
                      (UnsafeCo representational (Main.HappyAbsSyn
                                                    t4) Lekser.Token) of wild {
                   DEFAULT
                   -> case Main.happyReduction_81
                      ret_ty (Main.HappyStk (Main.HappyAbsSyn t4))
                      of {}
                   Lekser.Index happy_var_2
                   -> case ww4
                             `cast`
                           (UnsafeCo representational (Main.HappyAbsSyn
                                                         t4) Lekser.Token) of wild1 {
                        DEFAULT
                        -> case Main.happyReduction_80
                           ret_ty (Main.HappyStk (Main.HappyAbsSyn t4))
                           of {}
                        Lekser.Natural happy_var_4
                        -> Main.HappyStk
                             @ (Main.HappyAbsSyn t4)
                             (Tensor.Index.$WContravariant happy_var_4 happy_var_2)
                               `cast`
                             (UnsafeCo representational Tensor.Index.TIndex (Main.HappyAbsSyn
                                                                               t4))
                             ww14 } } } } } } }) -}
e935fce7c41c1135b28907c88e842863
  happyReduction_80 ::
    forall {t4}. Main.HappyStk (Main.HappyAbsSyn t4)
  {- Strictness: x -}
6096b50ec1ff47f67edae62163979c4b
  happyReduction_81 ::
    forall {t4}. Main.HappyStk (Main.HappyAbsSyn t4)
  {- Strictness: x -}
ac0a299cce2bde1396a6673cb24238a8
  happyReduction_82 ::
    forall {t4}. Main.HappyStk (Main.HappyAbsSyn t4)
  {- Strictness: x -}
7b3e6d281407497063d0a0e1367c8616
  happyReduction_83 ::
    forall {t4}. Main.HappyStk (Main.HappyAbsSyn t4)
  {- Strictness: x -}
cb5d506197078dbe491bc2f0cf9bde29
  happyReduction_9 ::
    forall {t4}.
    Main.HappyStk (Main.HappyAbsSyn t4)
    -> Main.HappyStk (Main.HappyAbsSyn t4)
  {- Arity: 1,
     Strictness: <S(LS(SS(LS(SS)))),1*U(A,1*U(1*U,1*U(A,1*U(1*U,1*U(A,U)))))>m,
     Inline: INLINE[0],
     Unfolding: InlineRule (1, True, False)
                (\ @ t4 (w :: Main.HappyStk (Main.HappyAbsSyn t4)) ->
                 case w of ww { Main.HappyStk ww1 ww2 ->
                 case ww2 of ww3 { Main.HappyStk ww4 ww5 ->
                 case ww5 of ww6 { Main.HappyStk ww7 ww8 ->
                 case ww8 of ww9 { Main.HappyStk ww10 ww11 ->
                 case ww11 of ww12 { Main.HappyStk ww13 ww14 ->
                 case ww10
                        `cast`
                      (UnsafeCo representational (Main.HappyAbsSyn
                                                    t4) Lekser.Token) of wild {
                   DEFAULT
                   -> case Main.happyReduction_83
                      ret_ty (Main.HappyStk (Main.HappyAbsSyn t4))
                      of {}
                   Lekser.Index happy_var_2
                   -> case ww4
                             `cast`
                           (UnsafeCo representational (Main.HappyAbsSyn
                                                         t4) Lekser.Token) of wild1 {
                        DEFAULT
                        -> case Main.happyReduction_82
                           ret_ty (Main.HappyStk (Main.HappyAbsSyn t4))
                           of {}
                        Lekser.Natural happy_var_4
                        -> Main.HappyStk
                             @ (Main.HappyAbsSyn t4)
                             (Tensor.Index.$WCovariant happy_var_4 happy_var_2)
                               `cast`
                             (UnsafeCo representational Tensor.Index.TIndex (Main.HappyAbsSyn
                                                                               t4))
                             ww14 } } } } } } }) -}
a1483593ec11707b7e9ab2d3bda12775
  happyReturn :: forall a. a -> GHC.Types.IO a
  {- Arity: 2, HasNoCafRefs, Strictness: <L,U><S,U>,
     Unfolding: InlineRule (0, True, True)
                GHC.Base.returnIO1
                  `cast`
                (forall (a :: <*>_N). <a>_R ->_R Sym (GHC.Types.N:IO[0] <a>_R)) -}
85e64801ad5a69bb8b5cbc32ab4f3a1e
  happyReturn1 :: forall a b. a -> b -> GHC.Types.IO a
  {- Arity: 3, HasNoCafRefs, Strictness: <L,U><L,A><S,U>,
     Unfolding: InlineRule (0, True, True)
                Main.happyReturn2
                  `cast`
                (forall (a :: <*>_N) (b :: <*>_N).
                 <a>_R ->_R <b>_R ->_R Sym (GHC.Types.N:IO[0] <a>_R)) -}
cf0cebcc3696ce50819469394f9cb7a7
  happyReturn2 ::
    forall {a} {b}.
    a
    -> b
    -> GHC.Prim.State# GHC.Prim.RealWorld
    -> (# GHC.Prim.State# GHC.Prim.RealWorld, a #)
  {- Arity: 3, HasNoCafRefs, Strictness: <L,U><L,A><S,U>,
     Unfolding: InlineRule (3, True, True)
                (\ @ a
                   @ b
                   (a1 :: a)
                   (tks :: b)
                   (s :: GHC.Prim.State# GHC.Prim.RealWorld)[OneShot] ->
                 (# s, a1 #)) -}
a5f399439d15dd2dfda272d6f68664f3
  happySeq :: forall {a} {b}. a -> b -> b
  {- Arity: 2, HasNoCafRefs, Strictness: <L,A><S,1*U>,
     Unfolding: InlineRule (0, True, True) Main.happyDontSeq -}
6213e158a966ec6b97930152e61ddbc6
  happyShift ::
    GHC.Prim.Int#
    -> GHC.Prim.Int#
    -> Lekser.Token
    -> GHC.Prim.Int#
    -> Main.Happy_IntList
    -> Main.HappyStk
         (Main.HappyAbsSyn
            (Data.Map.Base.Map
               GHC.Base.String (Tensor.Restricted.Tensor GHC.Types.Double)
             -> GHC.Types.IO
                  (Data.Map.Base.Map
                     GHC.Base.String (Tensor.Restricted.Tensor GHC.Types.Double))))
    -> [Lekser.Token]
    -> GHC.Types.IO
         (Main.HappyAbsSyn
            (Data.Map.Base.Map
               GHC.Base.String (Tensor.Restricted.Tensor GHC.Types.Double)
             -> GHC.Types.IO
                  (Data.Map.Base.Map
                     GHC.Base.String (Tensor.Restricted.Tensor GHC.Types.Double))))
  {- Arity: 6, Strictness: <S,U><S,1*U><L,U><L,U><L,U><L,U(U,U)>,
     Inline: NOINLINE -}
15e3c19934604e49d663d0b0dd558d4e
  happySpecReduce_0 ::
    GHC.Prim.Int#
    -> Main.HappyAbsSyn
         (Data.Map.Base.Map
            GHC.Base.String (Tensor.Restricted.Tensor GHC.Types.Double)
          -> GHC.Types.IO
               (Data.Map.Base.Map
                  GHC.Base.String (Tensor.Restricted.Tensor GHC.Types.Double)))
    -> GHC.Prim.Int#
    -> Lekser.Token
    -> GHC.Prim.Int#
    -> Main.Happy_IntList
    -> Main.HappyStk
         (Main.HappyAbsSyn
            (Data.Map.Base.Map
               GHC.Base.String (Tensor.Restricted.Tensor GHC.Types.Double)
             -> GHC.Types.IO
                  (Data.Map.Base.Map
                     GHC.Base.String (Tensor.Restricted.Tensor GHC.Types.Double))))
    -> [Lekser.Token]
    -> GHC.Types.IO
         (Main.HappyAbsSyn
            (Data.Map.Base.Map
               GHC.Base.String (Tensor.Restricted.Tensor GHC.Types.Double)
             -> GHC.Types.IO
                  (Data.Map.Base.Map
                     GHC.Base.String (Tensor.Restricted.Tensor GHC.Types.Double))))
  {- Arity: 7,
     Strictness: <L,U><L,U><S,1*U><L,U><S,U><L,U><L,U(U,U)>,
     Inline: NOINLINE -}
a665cf2471677c747105a6210e64b6e5
  happySpecReduce_1 ::
    GHC.Prim.Int#
    -> (Main.HappyAbsSyn
          (Data.Map.Base.Map
             GHC.Base.String (Tensor.Restricted.Tensor GHC.Types.Double)
           -> GHC.Types.IO
                (Data.Map.Base.Map
                   GHC.Base.String (Tensor.Restricted.Tensor GHC.Types.Double)))
        -> Main.HappyAbsSyn
             (Data.Map.Base.Map
                GHC.Base.String (Tensor.Restricted.Tensor GHC.Types.Double)
              -> GHC.Types.IO
                   (Data.Map.Base.Map
                      GHC.Base.String (Tensor.Restricted.Tensor GHC.Types.Double))))
    -> GHC.Prim.Int#
    -> Lekser.Token
    -> GHC.Prim.Int#
    -> Main.Happy_IntList
    -> Main.HappyStk
         (Main.HappyAbsSyn
            (Data.Map.Base.Map
               GHC.Base.String (Tensor.Restricted.Tensor GHC.Types.Double)
             -> GHC.Types.IO
                  (Data.Map.Base.Map
                     GHC.Base.String (Tensor.Restricted.Tensor GHC.Types.Double))))
    -> [Lekser.Token]
    -> GHC.Types.IO
         (Main.HappyAbsSyn
            (Data.Map.Base.Map
               GHC.Base.String (Tensor.Restricted.Tensor GHC.Types.Double)
             -> GHC.Types.IO
                  (Data.Map.Base.Map
                     GHC.Base.String (Tensor.Restricted.Tensor GHC.Types.Double))))
  {- Arity: 7,
     Strictness: <L,U><L,1*C1(U)><S,1*U><L,U><L,U><L,U(U,U)><L,U(U,U)>,
     Inline: NOINLINE -}
d4c0659b155cecb602a7ea035f046cea
  happySpecReduce_2 ::
    GHC.Prim.Int#
    -> (Main.HappyAbsSyn
          (Data.Map.Base.Map
             GHC.Base.String (Tensor.Restricted.Tensor GHC.Types.Double)
           -> GHC.Types.IO
                (Data.Map.Base.Map
                   GHC.Base.String (Tensor.Restricted.Tensor GHC.Types.Double)))
        -> Main.HappyAbsSyn
             (Data.Map.Base.Map
                GHC.Base.String (Tensor.Restricted.Tensor GHC.Types.Double)
              -> GHC.Types.IO
                   (Data.Map.Base.Map
                      GHC.Base.String (Tensor.Restricted.Tensor GHC.Types.Double)))
        -> Main.HappyAbsSyn
             (Data.Map.Base.Map
                GHC.Base.String (Tensor.Restricted.Tensor GHC.Types.Double)
              -> GHC.Types.IO
                   (Data.Map.Base.Map
                      GHC.Base.String (Tensor.Restricted.Tensor GHC.Types.Double))))
    -> GHC.Prim.Int#
    -> Lekser.Token
    -> GHC.Prim.Int#
    -> Main.Happy_IntList
    -> Main.HappyStk
         (Main.HappyAbsSyn
            (Data.Map.Base.Map
               GHC.Base.String (Tensor.Restricted.Tensor GHC.Types.Double)
             -> GHC.Types.IO
                  (Data.Map.Base.Map
                     GHC.Base.String (Tensor.Restricted.Tensor GHC.Types.Double))))
    -> [Lekser.Token]
    -> GHC.Types.IO
         (Main.HappyAbsSyn
            (Data.Map.Base.Map
               GHC.Base.String (Tensor.Restricted.Tensor GHC.Types.Double)
             -> GHC.Types.IO
                  (Data.Map.Base.Map
                     GHC.Base.String (Tensor.Restricted.Tensor GHC.Types.Double))))
  {- Arity: 7,
     Strictness: <L,U><L,1*C1(C1(U))><S,1*U><L,U><L,U><L,U(U,U(U,U))><L,U(U,U(U,U))>,
     Inline: NOINLINE -}
eedeaee776f2b391141e9f15e129c9f3
  happySpecReduce_3 ::
    GHC.Prim.Int#
    -> (Main.HappyAbsSyn
          (Data.Map.Base.Map
             GHC.Base.String (Tensor.Restricted.Tensor GHC.Types.Double)
           -> GHC.Types.IO
                (Data.Map.Base.Map
                   GHC.Base.String (Tensor.Restricted.Tensor GHC.Types.Double)))
        -> Main.HappyAbsSyn
             (Data.Map.Base.Map
                GHC.Base.String (Tensor.Restricted.Tensor GHC.Types.Double)
              -> GHC.Types.IO
                   (Data.Map.Base.Map
                      GHC.Base.String (Tensor.Restricted.Tensor GHC.Types.Double)))
        -> Main.HappyAbsSyn
             (Data.Map.Base.Map
                GHC.Base.String (Tensor.Restricted.Tensor GHC.Types.Double)
              -> GHC.Types.IO
                   (Data.Map.Base.Map
                      GHC.Base.String (Tensor.Restricted.Tensor GHC.Types.Double)))
        -> Main.HappyAbsSyn
             (Data.Map.Base.Map
                GHC.Base.String (Tensor.Restricted.Tensor GHC.Types.Double)
              -> GHC.Types.IO
                   (Data.Map.Base.Map
                      GHC.Base.String (Tensor.Restricted.Tensor GHC.Types.Double))))
    -> GHC.Prim.Int#
    -> Lekser.Token
    -> GHC.Prim.Int#
    -> Main.Happy_IntList
    -> Main.HappyStk
         (Main.HappyAbsSyn
            (Data.Map.Base.Map
               GHC.Base.String (Tensor.Restricted.Tensor GHC.Types.Double)
             -> GHC.Types.IO
                  (Data.Map.Base.Map
                     GHC.Base.String (Tensor.Restricted.Tensor GHC.Types.Double))))
    -> [Lekser.Token]
    -> GHC.Types.IO
         (Main.HappyAbsSyn
            (Data.Map.Base.Map
               GHC.Base.String (Tensor.Restricted.Tensor GHC.Types.Double)
             -> GHC.Types.IO
                  (Data.Map.Base.Map
                     GHC.Base.String (Tensor.Restricted.Tensor GHC.Types.Double))))
  {- Arity: 7,
     Strictness: <L,U><L,1*C1(C1(C1(U)))><S,1*U><L,U><L,U><L,U(U,U(U,U(U,U)))><L,U(U,U(U,U(U,U)))>,
     Inline: NOINLINE -}
10c6463e0d61b0d7d2e388775167da52
  happyTable :: Main.HappyAddr
  {- HasNoCafRefs, Strictness: m, Inline: NOINLINE -}
d8dd0669df4334b17d849cac7a667ea6
  happyTcHack :: forall a. GHC.Prim.Int# -> a -> a
  {- Arity: 2, HasNoCafRefs, Strictness: <L,A><S,1*U>,
     Inline: INLINE (sat-args=2),
     Unfolding: InlineRule (2, False, True)
                (\ @ a (x :: GHC.Prim.Int#) (y :: a) -> y) -}
f42086923a18420b829c06e2afdd4c51
  happyThen ::
    forall a b.
    GHC.Types.IO a -> (a -> GHC.Types.IO b) -> GHC.Types.IO b
  {- Arity: 3, HasNoCafRefs,
     Strictness: <C(S(SL)),1*C1(U(U,U))><L,1*C1(C1(U(U,U)))><S,U>,
     Unfolding: InlineRule (0, True, True)
                GHC.Base.bindIO1
                  `cast`
                (forall (a :: <*>_N) (b :: <*>_N).
                 <GHC.Types.IO a>_R
                 ->_R <a -> GHC.Types.IO b>_R
                 ->_R Sym (GHC.Types.N:IO[0] <b>_R)) -}
b0bdeb8951dc301a26e2db9dce1771cc
  happyThen1 ::
    forall {(m :: * -> *)} {b} {t} {t1}.
    GHC.Base.Monad m =>
    m t -> (t -> t1 -> m b) -> t1 -> m b
  {- Arity: 4, HasNoCafRefs,
     Strictness: <S(LC(C(S))LLL),1*U(A,1*C1(C1(U)),A,A,A)><L,U><L,C(C1(U))><L,U>,
     Unfolding: InlineRule (4, True, False)
                (\ @ (m :: * -> *)
                   @ b
                   @ t
                   @ t1
                   ($dMonad :: GHC.Base.Monad m)
                   (m1 :: m t)
                   (k :: t -> t1 -> m b)
                   (tks :: t1) ->
                 GHC.Base.>>= @ m $dMonad @ t @ b m1 (\ (a :: t) -> k a tks)) -}
4b5f9796a507c6a6999ae90ae3c32c65
  happy_n_nonterms :: GHC.Types.Int
  {- HasNoCafRefs, Strictness: m, Unfolding: (GHC.Types.I# 11#) -}
57cfff52fda768ebd27c787ac887173e
  happy_n_terms :: GHC.Types.Int
  {- HasNoCafRefs, Strictness: m, Unfolding: (GHC.Types.I# 62#) -}
f39f7fd06780f9d5ab886b3200f21f63
  indexShortOffAddr ::
    Main.HappyAddr -> GHC.Prim.Int# -> GHC.Prim.Int#
  {- Arity: 2, HasNoCafRefs, Strictness: <S(S),1*U(U)><S,U>,
     Unfolding: InlineRule (2, True, False)
                (\ (ds :: Main.HappyAddr) (off :: GHC.Prim.Int#) ->
                 case ds of wild { Main.HappyA# arr ->
                 let {
                   off' :: GHC.Prim.Int# = GHC.Prim.*# off 2#
                 } in
                 case GHC.Prim.indexCharOffAddr# arr off' of wild1 { DEFAULT ->
                 case GHC.Prim.indexCharOffAddr#
                        arr
                        (GHC.Prim.+# off' 1#) of wild2 { DEFAULT ->
                 GHC.Prim.narrow16Int#
                   (GHC.Prim.word2Int#
                      (GHC.Prim.or#
                         (GHC.Prim.uncheckedShiftL#
                            (GHC.Prim.int2Word# (GHC.Prim.ord# wild2))
                            8#)
                         (GHC.Prim.int2Word# (GHC.Prim.ord# wild1)))) } } }) -}
6592e5f1ee59ae875857b2e97c22340e
  main :: forall a. GHC.Types.IO a
  {- Arity: 1, Strictness: <S,U>,
     Unfolding: InlineRule (0, True, True)
                Main.main1
                  `cast`
                (forall (a :: <*>_N). Sym (GHC.Types.N:IO[0] <a>_R)) -}
e92d9f5f3180f92b89ad81b82fbab521
  main1 ::
    forall {a}.
    GHC.Prim.State# GHC.Prim.RealWorld
    -> (# GHC.Prim.State# GHC.Prim.RealWorld, a #)
  {- Arity: 1, Strictness: <S,U>,
     Unfolding: (\ @ a
                   (s :: GHC.Prim.State# GHC.Prim.RealWorld)[OneShot] ->
                 case GHC.IO.Handle.Text.hPutStr2
                        GHC.IO.Handle.FD.stdout
                        Main.main10
                        GHC.Types.True
                        s of ds1 { (#,#) ipv ipv1 ->
                 case GHC.IO.Handle.Internals.wantWritableHandle1
                        @ ()
                        GHC.IO.Handle.hFlush2
                        GHC.IO.Handle.FD.stdout
                        GHC.IO.Handle.Internals.flushWriteBuffer1
                          `cast`
                        (<GHC.IO.Handle.Types.Handle__>_R
                         ->_R Sym (GHC.Types.N:IO[0] <()>_R))
                        ipv of ds2 { (#,#) ipv2 ipv3 ->
                 case GHC.Prim.catch#
                        @ GHC.Types.Bool
                        @ GHC.Exception.SomeException
                        Main.main8 `cast` (GHC.Types.N:IO[0] <GHC.Types.Bool>_R)
                        System.Directory.doesDirectoryExist2
                        ipv2 of ds3 { (#,#) ipv4 ipv5 ->
                 case ipv5 of wild {
                   GHC.Types.False
                   -> Main.happyError'2
                        @ a
                        (Data.Map.Base.Tip
                           @ GHC.Base.String
                           @ (Tensor.Restricted.Tensor GHC.Types.Double))
                        ipv4
                   GHC.Types.True
                   -> case GHC.IO.Handle.Text.hPutStr2
                             GHC.IO.Handle.FD.stdout
                             Main.main7
                             GHC.Types.True
                             ipv4 of ds4 { (#,#) ipv6 ipv7 ->
                      case GHC.IO.Handle.Internals.wantWritableHandle1
                             @ ()
                             GHC.IO.Handle.hFlush2
                             GHC.IO.Handle.FD.stdout
                             GHC.IO.Handle.Internals.flushWriteBuffer1
                               `cast`
                             (<GHC.IO.Handle.Types.Handle__>_R
                              ->_R Sym (GHC.Types.N:IO[0] <()>_R))
                             ipv6 of ds5 { (#,#) ipv8 ipv9 ->
                      case GHC.IO.Handle.FD.openBinaryFile1
                             Main.happyError'4
                             GHC.IO.IOMode.ReadMode
                             ipv8 of ds6 { (#,#) ipv10 ipv11 ->
                      case Data.ByteString.Lazy.getContents2
                             ipv11
                             ipv10 of ds7 { (#,#) ipv12 ipv13 ->
                      case Data.Binary.Get.runGetOrFail1
                             @ (Data.Map.Base.Map
                                  GHC.Base.String (Tensor.Restricted.Tensor GHC.Types.Double))
                             Main.main4
                             (Codec.Compression.Zlib.Internal.foldDecompressStreamWithInput
                                @ Data.ByteString.Lazy.Internal.ByteString
                                Data.ByteString.Lazy.Internal.$WChunk
                                Codec.Compression.Zlib.Internal.decompress2
                                Codec.Compression.Zlib.Internal.decompress1
                                Codec.Compression.GZip.decompress1
                                (case Main.$wgo1 0# ipv13 of ww { DEFAULT -> ipv13 })) of wild1 {
                        Data.Either.Left x
                        -> case x of wild2 { (,,) ds ds8 msg ->
                           case GHC.IO.Handle.Text.hPutStr2
                                  GHC.IO.Handle.FD.stdout
                                  (GHC.Base.++ @ GHC.Types.Char msg Main.main3)
                                  GHC.Types.True
                                  ipv12 of ds9 { (#,#) ipv14 ipv15 ->
                           Main.happyError'2
                             @ a
                             (Data.Map.Base.Tip
                                @ GHC.Base.String
                                @ (Tensor.Restricted.Tensor GHC.Types.Double))
                             ipv14 } }
                        Data.Either.Right y
                        -> case y of wild2 { (,,) ds ds8 ts ->
                           case GHC.IO.Handle.Text.hPutStr2
                                  GHC.IO.Handle.FD.stdout
                                  Main.main2
                                  GHC.Types.True
                                  ipv12 of ds9 { (#,#) ipv14 ipv15 ->
                           Main.happyError'2 @ a ts ipv14 } } } } } } } } } } }) -}
1ad93ae78e909aa655e35b7bc755a6d7
  main10 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString#
                   "Welcome to Glorious NeuroL Interpreter 0.1!"#) -}
efae1cef52ea5eacb0ac80b17557bf44
  main11 ::
    GHC.Prim.State# GHC.Prim.RealWorld
    -> (# GHC.Prim.State# GHC.Prim.RealWorld, GHC.Prim.Any #)
  {- Arity: 1,
     Unfolding: (GHC.TopHandler.runMainIO1
                   @ GHC.Prim.Any
                   (Main.main1 @ GHC.Prim.Any)
                     `cast`
                   (Sym (GHC.Types.N:IO[0] <GHC.Prim.Any>_R))) -}
7b5b47a985a7f71797f312c2e36dff0b
  main2 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString#
                   "Session read!\n\
                   \Please type a command now..."#) -}
e087c7339649bb890e6e5668000d929a
  main3 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString#
                   " Starting from clear session.\n\
                   \Please type a command now..."#) -}
4bfa7a16950902ca62dcdeee3a778a13
  main4 ::
    Data.Binary.Get.Decoder
      (Data.Map.Base.Map
         GHC.Base.String (Tensor.Restricted.Tensor GHC.Types.Double))
  {- Unfolding: (Data.Binary.Get.$wpoly_go
                   @ (Data.Map.Base.Map
                        GHC.Base.String (Tensor.Restricted.Tensor GHC.Types.Double))
                   Main.main5
                   0#) -}
74893115df59799b00176b3264f394c5
  main5 ::
    Data.Binary.Get.Internal.Decoder
      (Data.Map.Base.Map
         GHC.Base.String (Tensor.Restricted.Tensor GHC.Types.Double))
  {- Unfolding: (Data.Binary.Get.Internal.runGetIncremental1
                   @ (Data.Map.Base.Map
                        GHC.Base.String (Tensor.Restricted.Tensor GHC.Types.Double))
                   Main.main6) -}
3bff5082f883aacb0683448210a48135
  main6 ::
    Data.Binary.Get.Internal.Decoder
      (Data.Map.Base.Map
         GHC.Base.String (Tensor.Restricted.Tensor GHC.Types.Double))
  {- Unfolding: ((Data.Binary.Class.$fBinaryMap_$cget
                    @ [GHC.Types.Char]
                    @ (Tensor.Restricted.Tensor GHC.Types.Double)
                    Data.Binary.Class.$fBinaryVersion_$s$fBinary[]
                    Main.$s$fBinaryMap_$s$fBinaryTensor)
                   `cast`
                 (Data.Binary.Get.Internal.N:Get[0]
                      <Data.Map.Base.Map
                         GHC.Base.String (Tensor.Restricted.Tensor GHC.Types.Double)>_R)
                   @ (Data.Map.Base.Map
                        GHC.Base.String (Tensor.Restricted.Tensor GHC.Types.Double))
                   Data.ByteString.empty
                   (Data.Binary.Get.Internal.$WDone
                      @ (Data.Map.Base.Map
                           GHC.Base.String (Tensor.Restricted.Tensor GHC.Types.Double)))) -}
2817025bcb2a66539fff15a02445d013
  main7 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString#
                   "Reading saved session..."#) -}
559e33790c3d72dd7532fdb610d6af3d
  main8 :: GHC.Types.IO GHC.Types.Bool
  {- Unfolding: (GHC.Magic.lazy
                   @ (GHC.Types.IO GHC.Types.Bool)
                   Main.main9 `cast` (Sym (GHC.Types.N:IO[0] <GHC.Types.Bool>_R))) -}
74d3c352c38874d218bec218cd94a3f8
  main9 ::
    GHC.Prim.State# GHC.Prim.RealWorld
    -> (# GHC.Prim.State# GHC.Prim.RealWorld, GHC.Types.Bool #)
  {- Arity: 1,
     Unfolding: (System.Directory.doesDirectoryExist5
                   @ GHC.Types.Bool
                   System.Directory.doesFileExist3
                   Main.happyError'4
                   System.Directory.doesFileExist2
                     `cast`
                   (<GHC.Ptr.Ptr System.Posix.Internals.CStat>_R
                    ->_R Sym (GHC.Types.N:IO[0] <GHC.Types.Bool>_R))) -}
9f289e92cdc6a977127ed941c9bf3100
  neurol ::
    [Lekser.Token]
    -> GHC.Types.IO
         (Data.Map.Base.Map
            GHC.Base.String (Tensor.Restricted.Tensor GHC.Types.Double)
          -> GHC.Types.IO
               (Data.Map.Base.Map
                  GHC.Base.String (Tensor.Restricted.Tensor GHC.Types.Double)))
  {- Arity: 2, Strictness: <S,1*U><S,U>,
     Unfolding: InlineRule (0, True, True)
                Main.neurol1
                  `cast`
                (<[Lekser.Token]>_R
                 ->_R Sym (GHC.Types.N:IO[0]
                               <Data.Map.Base.Map
                                  GHC.Base.String (Tensor.Restricted.Tensor GHC.Types.Double)
                                -> GHC.Types.IO
                                     (Data.Map.Base.Map
                                        GHC.Base.String
                                        (Tensor.Restricted.Tensor GHC.Types.Double))>_R)) -}
7c5783a65cb184f5aed86d8df9984b2b
  neurol1 ::
    [Lekser.Token]
    -> GHC.Prim.State# GHC.Prim.RealWorld
    -> (# GHC.Prim.State# GHC.Prim.RealWorld,
          Data.Map.Base.Map
            GHC.Base.String (Tensor.Restricted.Tensor GHC.Types.Double)
          -> GHC.Types.IO
               (Data.Map.Base.Map
                  GHC.Base.String (Tensor.Restricted.Tensor GHC.Types.Double)) #)
  {- Arity: 2, Strictness: <S,1*U><S,U>,
     Unfolding: InlineRule (2, True, False)
                (\ (tks :: [Lekser.Token])
                   (s :: GHC.Prim.State# GHC.Prim.RealWorld)[OneShot] ->
                 case (Main.happyNewToken
                         0#
                         (Main.notHappyAtAll @ Main.Happy_IntList)
                         (Main.notHappyAtAll
                            @ (Main.HappyStk
                                 (Main.HappyAbsSyn
                                    (Data.Map.Base.Map
                                       GHC.Base.String (Tensor.Restricted.Tensor GHC.Types.Double)
                                     -> GHC.Types.IO
                                          (Data.Map.Base.Map
                                             GHC.Base.String
                                             (Tensor.Restricted.Tensor GHC.Types.Double))))))
                         tks)
                        `cast`
                      (GHC.Types.N:IO[0]
                           <Main.HappyAbsSyn
                              (Data.Map.Base.Map
                                 GHC.Base.String (Tensor.Restricted.Tensor GHC.Types.Double)
                               -> GHC.Types.IO
                                    (Data.Map.Base.Map
                                       GHC.Base.String
                                       (Tensor.Restricted.Tensor GHC.Types.Double)))>_R)
                        s of ds1 { (#,#) ipv ipv1 ->
                 (# ipv,
                    ipv1
                      `cast`
                    (UnsafeCo representational (Main.HappyAbsSyn
                                                  (Data.Map.Base.Map
                                                     GHC.Base.String
                                                     (Tensor.Restricted.Tensor GHC.Types.Double)
                                                   -> GHC.Types.IO
                                                        (Data.Map.Base.Map
                                                           GHC.Base.String
                                                           (Tensor.Restricted.Tensor
                                                              GHC.Types.Double)))) (Data.Map.Base.Map
                                                                                      GHC.Base.String
                                                                                      (Tensor.Restricted.Tensor
                                                                                         GHC.Types.Double)
                                                                                    -> GHC.Types.IO
                                                                                         (Data.Map.Base.Map
                                                                                            GHC.Base.String
                                                                                            (Tensor.Restricted.Tensor
                                                                                               GHC.Types.Double)))) #) }) -}
4b497ed867fd2bd6f78fcb64a6edfff6
  notHappyAtAll :: forall a. a
  {- Strictness: x -}
e7aec735519307e410afd7a58853499a
  parseError :: forall a. [Lekser.Token] -> GHC.Types.IO a
  {- Arity: 2, Strictness: <L,1*U><S,U>,
     Unfolding: InlineRule (0, True, True)
                Main.happyError'1
                  `cast`
                (forall (a :: <*>_N).
                 <[Lekser.Token]>_R ->_R Sym (GHC.Types.N:IO[0] <a>_R)) -}
02d9993476bcfab4002efa87070aab17
  repl ::
    forall a.
    Data.Map.Base.Map
      GHC.Base.String (Tensor.Restricted.Tensor GHC.Types.Double)
    -> GHC.Types.IO a
  {- Arity: 2, Strictness: <L,U><S,U>,
     Unfolding: InlineRule (0, True, True)
                Main.happyError'2
                  `cast`
                (forall (a :: <*>_N).
                 <Data.Map.Base.Map
                    GHC.Base.String (Tensor.Restricted.Tensor GHC.Types.Double)>_R
                 ->_R Sym (GHC.Types.N:IO[0] <a>_R)) -}
"SPEC/Main $fBinaryMap @ [Char] @ (Tensor Double)" [ALWAYS] forall ($dBinary :: Data.Binary.Class.Binary
                                                                                  [GHC.Types.Char])
                                                                   ($dBinary1 :: Data.Binary.Class.Binary
                                                                                   (Tensor.Restricted.Tensor
                                                                                      GHC.Types.Double))
  Data.Binary.Class.$fBinaryMap @ [GHC.Types.Char]
                                @ (Tensor.Restricted.Tensor GHC.Types.Double)
                                $dBinary
                                $dBinary1
  = Main.$s$fBinaryMap
"SPEC/Main $fBinaryTensor @ Double" [ALWAYS] forall ($dBinary :: Data.Binary.Class.Binary
                                                                   GHC.Types.Double)
  Tensor.Restricted.$fBinaryTensor @ GHC.Types.Double $dBinary
  = Main.$s$fBinaryMap_$s$fBinaryTensor
vectorised variables:
vectorised tycons:
vectorised reused tycons:
parallel variables:
parallel tycons:
trusted: none
require own pkg trusted: False

