
==================== FINAL INTERFACE ====================
2017-03-06 22:11:46.9599359 UTC

interface Multilinear-0.1.0.0-E9ARM2QGVFX7aqrS3x5JFU:Multilinear.Tensor 8002
  interface hash: 3887c86295d933dbdacf1f0dc4984595
  ABI hash: ec0c190286c02bbdeed9b7defc03ab15
  export-list hash: a0cc13e3e01a90df490ad6accfa6e176
  orphan hash: 693e9af84d3dfcc71e640e005bdc5e2e
  flag hash: d421a442bac5348a67fd3f91398c6034
  sig of: Nothing
  used TH splices: False
  where
exports:
  Multilinear.Tensor.el
  Multilinear.Tensor.lowIndices
  Multilinear.Tensor.upIndices
  Multilinear.Tensor.T{Multilinear.Tensor.T}
module dependencies:
package dependencies: base-4.9.1.0* ghc-prim-0.5.0.0
                      integer-gmp-1.0.0.1
orphans: base-4.9.1.0:GHC.Base base-4.9.1.0:GHC.Float
family instance modules: base-4.9.1.0:Control.Applicative
                         base-4.9.1.0:Data.Either base-4.9.1.0:Data.Functor.Const
                         base-4.9.1.0:Data.Monoid base-4.9.1.0:Data.Type.Equality
                         base-4.9.1.0:GHC.Generics base-4.9.1.0:GHC.IO.Exception
                         base-4.9.1.0:GHC.TypeLits
import  -/  base-4.9.1.0:Data.Foldable 254e836c2d813d34e47feb29bb8d40ed
import  -/  base-4.9.1.0:GHC.Base 4caea1123ecf4b46e27cbccd6d279377
import  -/  base-4.9.1.0:GHC.Err 20faef8829fd13c027d0ee2213637534
import  -/  base-4.9.1.0:GHC.List d11eb227c1c6fbfd89bb781d72eaea0d
import  -/  base-4.9.1.0:GHC.Num 38b8aac8807c096c7f3ca3c1eff02939
import  -/  base-4.9.1.0:GHC.Real b88ae4a48c079652623073a5bbf5c9b0
import  -/  base-4.9.1.0:Prelude 74b3e204395920329f6de9d97206abe9
import  -/  ghc-prim-0.5.0.0:GHC.Classes 16d48e012d23eaef9bca91ccdd572c02
db07a1302b70b910763cd3f09e138e88
  $fNumT ::
    (GHC.Num.Num a, GHC.Real.Integral i) =>
    GHC.Num.Num (Multilinear.Tensor.T a i)
  DFunId
  {- Arity: 2,
     Strictness: <L,U(C(C1(U)),C(C1(U)),C(C1(U)),A,C(U),C(U),C(U))><L,U(U,U,U,U,U,U,U,U,U)>m,
     Unfolding: DFun: @ a
                      @ i
                      ($dNum :: GHC.Num.Num a)
                      ($dIntegral :: GHC.Real.Integral i).
                  @ (Multilinear.Tensor.T a i)
                  (Multilinear.Tensor.$fNumT9 @ a @ i $dNum $dIntegral)
                  (Multilinear.Tensor.$fNumT8 @ a @ i $dNum $dIntegral)
                  (Multilinear.Tensor.$fNumT7 @ a @ i $dNum $dIntegral)
                  (Multilinear.Tensor.$fNumT_$cnegate @ a @ i $dNum $dIntegral)
                  (Multilinear.Tensor.$fNumT3 @ a @ i $dNum $dIntegral)
                  (Multilinear.Tensor.$fNumT2 @ a @ i $dNum $dIntegral)
                  (Multilinear.Tensor.$fNumT1 @ a @ i $dNum $dIntegral) -}
db07a1302b70b910763cd3f09e138e88
  $fNumT1 ::
    (GHC.Num.Num a, GHC.Real.Integral i) =>
    GHC.Integer.Type.Integer -> Multilinear.Tensor.T a i
  {- Arity: 3, HasNoCafRefs,
     Strictness: <L,1*U(A,A,A,A,A,A,1*C1(U))><L,U><S,1*U>m,
     Inline: INLINE[0],
     Unfolding: InlineRule (3, True, False)
                (\ @ a
                   @ i
                   (w :: GHC.Num.Num a)
                   (w1 :: GHC.Real.Integral i)
                   (w2 :: GHC.Integer.Type.Integer) ->
                 case w2 of i1 { DEFAULT ->
                 let {
                   lvl13 :: a = GHC.Num.fromInteger @ a w i1
                 } in
                 Multilinear.Tensor.T
                   @ a
                   @ i
                   w1
                   (GHC.Types.[] @ GHC.Types.Char, GHC.Types.[] @ i)
                   (GHC.Types.[] @ GHC.Types.Char, GHC.Types.[] @ i)
                   (\ (ds :: [i]) (ds1 :: [i]) ->
                    case ds of ds2 { DEFAULT ->
                    case ds1 of ds3 { DEFAULT -> lvl13 } }) }) -}
db07a1302b70b910763cd3f09e138e88
  $fNumT10 :: Multilinear.Tensor.T a i
  {- Strictness: x -}
db07a1302b70b910763cd3f09e138e88
  $fNumT2 ::
    (GHC.Num.Num a, GHC.Real.Integral i) =>
    Multilinear.Tensor.T a i -> Multilinear.Tensor.T a i
  {- Arity: 3, HasNoCafRefs,
     Strictness: <L,U(A,A,A,A,A,C(U),A)><L,U><S(LSSS),1*U(A,U,U,C(C1(U)))>m,
     Inline: INLINE[0],
     Unfolding: InlineRule (3, True, False)
                (\ @ a
                   @ i
                   (w :: GHC.Num.Num a)
                   (w1 :: GHC.Real.Integral i)
                   (w2 :: Multilinear.Tensor.T a i) ->
                 case w2 of ww { Multilinear.Tensor.T ww1 ww2 ww3 ww4 ->
                 Multilinear.Tensor.T
                   @ a
                   @ i
                   w1
                   ww2
                   ww3
                   (\ (ul :: [i]) (dl :: [i]) ->
                    case ul of ul1 { DEFAULT ->
                    case dl of dl1 { DEFAULT ->
                    GHC.Num.signum @ a w (ww4 ul1 dl1) } }) }) -}
db07a1302b70b910763cd3f09e138e88
  $fNumT3 ::
    (GHC.Num.Num a, GHC.Real.Integral i) =>
    Multilinear.Tensor.T a i -> Multilinear.Tensor.T a i
  {- Arity: 3, HasNoCafRefs,
     Strictness: <L,U(A,A,A,A,C(U),A,A)><L,U><S(LSSS),1*U(A,U,U,C(C1(U)))>m,
     Inline: INLINE[0],
     Unfolding: InlineRule (3, True, False)
                (\ @ a
                   @ i
                   (w :: GHC.Num.Num a)
                   (w1 :: GHC.Real.Integral i)
                   (w2 :: Multilinear.Tensor.T a i) ->
                 case w2 of ww { Multilinear.Tensor.T ww1 ww2 ww3 ww4 ->
                 Multilinear.Tensor.T
                   @ a
                   @ i
                   w1
                   ww2
                   ww3
                   (\ (ul :: [i]) (dl :: [i]) ->
                    case ul of ul1 { DEFAULT ->
                    case dl of dl1 { DEFAULT ->
                    GHC.Num.abs @ a w (ww4 ul1 dl1) } }) }) -}
db07a1302b70b910763cd3f09e138e88
  $fNumT4 ::
    (GHC.Num.Num a, GHC.Real.Integral i) =>
    Multilinear.Tensor.T a i -> Multilinear.Tensor.T a i
  {- Arity: 3,
     Strictness: <L,U(A,C(C1(U)),A,A,A,A,1*C1(U))><L,U(U,U,U,U,U,U,U,U,U)><S(LS(SS)S(SS)S),1*U(A,U(1*U,1*U),U(1*U,1*U),C(C1(U)))>m,
     Inline: INLINE[0],
     Unfolding: InlineRule (3, True, False)
                (\ @ a
                   @ i
                   (w :: GHC.Num.Num a)
                   (w1 :: GHC.Real.Integral i)
                   (w2 :: Multilinear.Tensor.T a i) ->
                 case w2 of ww { Multilinear.Tensor.T ww1 ww2 ww3 ww4 ->
                 case ww2 of ww5 { (,) ww6 ww7 ->
                 case ww3 of ww8 { (,) ww9 ww10 ->
                 case Multilinear.Tensor.$wds
                        @ a
                        @ i
                        w
                        w1
                        ww6
                        ww7
                        ww9
                        ww10
                        ww4 of ww11 { (#,,,#) ww12 ww13 ww14 ww15 ->
                 Multilinear.Tensor.T @ a @ i ww12 ww13 ww14 ww15 } } } }) -}
db07a1302b70b910763cd3f09e138e88
  $fNumT5 :: Multilinear.Tensor.T a i
  {- Strictness: x -}
9e1b0d5daa5aea7b091160bafbddb2f7
  $fNumT6 :: GHC.Integer.Type.Integer
  {- HasNoCafRefs, Unfolding: (0) -}
db07a1302b70b910763cd3f09e138e88
  $fNumT7 ::
    (GHC.Num.Num a, GHC.Real.Integral i) =>
    Multilinear.Tensor.T a i
    -> Multilinear.Tensor.T a i -> Multilinear.Tensor.T a i
  {- Arity: 4, HasNoCafRefs,
     Strictness: <L,U(A,A,C(C1(U)),A,A,A,A)><L,U><S(LSSS),1*U(A,U(U,1*U),U(U,1*U),C(C1(U)))><S(LSSS),1*U(A,U(1*U,1*U),U(1*U,1*U),C(C1(U)))>m,
     Inline: INLINE[0],
     Unfolding: InlineRule (4, True, False)
                (\ @ a
                   @ i
                   (w :: GHC.Num.Num a)
                   (w1 :: GHC.Real.Integral i)
                   (w2 :: Multilinear.Tensor.T a i)
                   (w3 :: Multilinear.Tensor.T a i) ->
                 case w2 of ww { Multilinear.Tensor.T ww1 ww2 ww3 ww4 ->
                 case ww2 of ww5 { (,) ww6 ww7 ->
                 case ww3 of ww8 { (,) ww9 ww10 ->
                 case w3 of ww11 { Multilinear.Tensor.T ww12 ww13 ww14 ww15 ->
                 case ww13 of ww16 { (,) ww17 ww18 ->
                 case ww14 of ww19 { (,) ww20 ww21 ->
                 case Multilinear.Tensor.$wds2
                        @ a
                        @ i
                        w
                        w1
                        ww6
                        ww7
                        ww9
                        ww10
                        ww4
                        ww17
                        ww18
                        ww20
                        ww21
                        ww15 of ww22 { (#,,,#) ww23 ww24 ww25 ww26 ->
                 Multilinear.Tensor.T @ a @ i ww23 ww24 ww25 ww26 } } } } } } }) -}
db07a1302b70b910763cd3f09e138e88
  $fNumT8 ::
    (GHC.Num.Num a, GHC.Real.Integral i) =>
    Multilinear.Tensor.T a i
    -> Multilinear.Tensor.T a i -> Multilinear.Tensor.T a i
  {- Arity: 4,
     Strictness: <L,U(A,C(C1(U)),A,A,A,A,A)><L,U(U,U,U,U,U,U,U,U,U)><S(LS(SS)S(SS)S),1*U(A,U(U,U),U(U,U),C(C1(U)))><S(LS(SS)S(SS)S),1*U(A,U(1*U,1*U),U(1*U,1*U),C(C1(U)))>m,
     Inline: INLINE[0],
     Unfolding: InlineRule (4, True, False)
                (\ @ a
                   @ i
                   (w :: GHC.Num.Num a)
                   (w1 :: GHC.Real.Integral i)
                   (w2 :: Multilinear.Tensor.T a i)
                   (w3 :: Multilinear.Tensor.T a i) ->
                 case w2 of ww { Multilinear.Tensor.T ww1 ww2 ww3 ww4 ->
                 case ww2 of ww5 { (,) ww6 ww7 ->
                 case ww3 of ww8 { (,) ww9 ww10 ->
                 case w3 of ww11 { Multilinear.Tensor.T ww12 ww13 ww14 ww15 ->
                 case ww13 of ww16 { (,) ww17 ww18 ->
                 case ww14 of ww19 { (,) ww20 ww21 ->
                 case Multilinear.Tensor.$wds1
                        @ a
                        @ i
                        w
                        w1
                        ww6
                        ww7
                        ww9
                        ww10
                        ww4
                        ww17
                        ww18
                        ww20
                        ww21
                        ww15 of ww22 { (#,,,#) ww23 ww24 ww25 ww26 ->
                 Multilinear.Tensor.T @ a @ i ww23 ww24 ww25 ww26 } } } } } } }) -}
db07a1302b70b910763cd3f09e138e88
  $fNumT9 ::
    (GHC.Num.Num a, GHC.Real.Integral i) =>
    Multilinear.Tensor.T a i
    -> Multilinear.Tensor.T a i -> Multilinear.Tensor.T a i
  {- Arity: 4,
     Strictness: <L,U(C(C1(U)),A,A,A,A,A,A)><L,U(U,U,U,U,U,U,U,U,U)><S(LS(SS)S(SS)S),1*U(A,U(U,U),U(U,U),C(C1(U)))><S(LS(SS)S(SS)S),1*U(A,U(1*U,1*U),U(1*U,1*U),C(C1(U)))>m,
     Inline: INLINE[0],
     Unfolding: InlineRule (4, True, False)
                (\ @ a
                   @ i
                   (w :: GHC.Num.Num a)
                   (w1 :: GHC.Real.Integral i)
                   (w2 :: Multilinear.Tensor.T a i)
                   (w3 :: Multilinear.Tensor.T a i) ->
                 case w2 of ww { Multilinear.Tensor.T ww1 ww2 ww3 ww4 ->
                 case ww2 of ww5 { (,) ww6 ww7 ->
                 case ww3 of ww8 { (,) ww9 ww10 ->
                 case w3 of ww11 { Multilinear.Tensor.T ww12 ww13 ww14 ww15 ->
                 case ww13 of ww16 { (,) ww17 ww18 ->
                 case ww14 of ww19 { (,) ww20 ww21 ->
                 case Multilinear.Tensor.$wds3
                        @ a
                        @ i
                        w
                        w1
                        ww6
                        ww7
                        ww9
                        ww10
                        ww4
                        ww17
                        ww18
                        ww20
                        ww21
                        ww15 of ww22 { (#,,,#) ww23 ww24 ww25 ww26 ->
                 Multilinear.Tensor.T @ a @ i ww23 ww24 ww25 ww26 } } } } } } }) -}
db07a1302b70b910763cd3f09e138e88
  $fNumT_$cnegate ::
    (GHC.Num.Num a, GHC.Real.Integral i) =>
    Multilinear.Tensor.T a i -> Multilinear.Tensor.T a i
  {- Arity: 3,
     Strictness: <L,U(A,C(C1(U)),A,A,A,A,1*C1(U))><L,U(U,U,U,U,U,U,U,U,U)><S(LS(SS)S(SS)S),1*U(A,U(1*U,1*U),U(1*U,1*U),C(C1(U)))>m,
     Unfolding: InlineRule (0, True, True) Multilinear.Tensor.$fNumT4 -}
b7bc1405df4bf88a57bf3d2502e5dd8b
  $tc'T :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   17432937748411218507##
                   15547260522013430427##
                   Multilinear.Tensor.$trModule
                   Multilinear.Tensor.$tc'T1) -}
57709b36138055d25dffcb1df85a2b96
  $tc'T1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "'T"#) -}
41999e5fa181876a88623d70bd354978
  $tcT :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   4174154251826045021##
                   3864233149767757940##
                   Multilinear.Tensor.$trModule
                   Multilinear.Tensor.$tcT1) -}
1c3039982384f460b1674c959a94a361
  $tcT1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "T"#) -}
740a9f88a128fa3b9f698f7d317b1013
  $trModule :: GHC.Types.Module
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.Module
                   Multilinear.Tensor.$trModule2
                   Multilinear.Tensor.$trModule1) -}
5e3069510f3f997bd952796db525b688
  $trModule1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "Multilinear.Tensor"#) -}
c02d74ece54831f0c019ca8f0edf7987
  $trModule2 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS
                   "Multilinear-0.1.0.0-E9ARM2QGVFX7aqrS3x5JFU"#) -}
db07a1302b70b910763cd3f09e138e88
  $wds ::
    (GHC.Num.Num a, GHC.Real.Integral i) =>
    GHC.Base.String
    -> [i]
    -> GHC.Base.String
    -> [i]
    -> ([i] -> [i] -> a)
    -> (# GHC.Real.Integral i, (GHC.Base.String, [i]),
          (GHC.Base.String, [i]), [i] -> [i] -> a #)
  {- Arity: 7,
     Strictness: <L,U(A,C(C1(U)),A,A,A,A,1*C1(U))><L,U(U,U,U,U,U,U,U,U,U)><S,1*U><S,1*U><S,1*U><S,1*U><S,C(C1(U))>,
     Inline: [0],
     Unfolding: (\ @ a
                   @ i
                   (w :: GHC.Num.Num a)
                   (w1 :: GHC.Real.Integral i)
                   (ww :: GHC.Base.String)
                   (ww1 :: [i])
                   (ww2 :: GHC.Base.String)
                   (ww3 :: [i])
                   (ww4 :: [i] -> [i] -> a) ->
                 let {
                   lvl13 :: a = GHC.Num.fromInteger @ a w Multilinear.Tensor.$fNumT6
                 } in
                 Multilinear.Tensor.$wds1
                   @ a
                   @ i
                   w
                   w1
                   (GHC.Types.[] @ GHC.Types.Char)
                   (GHC.Types.[] @ i)
                   (GHC.Types.[] @ GHC.Types.Char)
                   (GHC.Types.[] @ i)
                   (\ (ds :: [i]) (ds1 :: [i])[OneShot] ->
                    case ds of ds2 { DEFAULT -> case ds1 of ds3 { DEFAULT -> lvl13 } })
                   ww
                   ww1
                   ww2
                   ww3
                   ww4) -}
db07a1302b70b910763cd3f09e138e88
  $wds1 ::
    (GHC.Num.Num a, GHC.Real.Integral i) =>
    GHC.Base.String
    -> [i]
    -> GHC.Base.String
    -> [i]
    -> ([i] -> [i] -> a)
    -> GHC.Base.String
    -> [i]
    -> GHC.Base.String
    -> [i]
    -> ([i] -> [i] -> a)
    -> (# GHC.Real.Integral i, (GHC.Base.String, [i]),
          (GHC.Base.String, [i]), [i] -> [i] -> a #)
  {- Arity: 12,
     Strictness: <L,U(A,C(C1(U)),A,A,A,A,A)><L,U(U,U,U,U,U,U,U,U,U)><S,U><S,U><S,U><S,U><S,C(C1(U))><S,1*U><S,1*U><S,1*U><S,1*U><S,C(C1(U))>,
     Inline: [0],
     Unfolding: (\ @ a
                   @ i
                   (w :: GHC.Num.Num a)
                   (w1 :: GHC.Real.Integral i)
                   (ww :: GHC.Base.String)
                   (ww1 :: [i])
                   (ww2 :: GHC.Base.String)
                   (ww3 :: [i])
                   (ww4 :: [i] -> [i] -> a)
                   (ww5 :: GHC.Base.String)
                   (ww6 :: [i])
                   (ww7 :: GHC.Base.String)
                   (ww8 :: [i])
                   (ww9 :: [i] -> [i] -> a) ->
                 case GHC.Base.eqString ww ww5 of wild {
                   GHC.Types.False
                   -> case Multilinear.Tensor.$fNumT5
                      ret_ty (# GHC.Real.Integral i, (GHC.Base.String, [i]),
                                (GHC.Base.String, [i]), [i] -> [i] -> a #)
                      of {}
                   GHC.Types.True
                   -> let {
                        $dReal :: GHC.Real.Real i = GHC.Real.$p1Integral @ i w1
                      } in
                      let {
                        $dOrd :: GHC.Classes.Ord i = GHC.Real.$p2Real @ i $dReal
                      } in
                      let {
                        $dEq :: GHC.Classes.Eq i = GHC.Classes.$p1Ord @ i $dOrd
                      } in
                      case GHC.Classes.$fEq[]_$c== @ i $dEq ww1 ww6 of wild1 {
                        GHC.Types.False
                        -> case Multilinear.Tensor.$fNumT5
                           ret_ty (# GHC.Real.Integral i, (GHC.Base.String, [i]),
                                     (GHC.Base.String, [i]), [i] -> [i] -> a #)
                           of {}
                        GHC.Types.True
                        -> case GHC.Base.eqString ww2 ww7 of wild2 {
                             GHC.Types.False
                             -> case Multilinear.Tensor.$fNumT5
                                ret_ty (# GHC.Real.Integral i, (GHC.Base.String, [i]),
                                          (GHC.Base.String, [i]), [i] -> [i] -> a #)
                                of {}
                             GHC.Types.True
                             -> case GHC.Classes.$fEq[]_$c== @ i $dEq ww3 ww8 of wild3 {
                                  GHC.Types.False
                                  -> case Multilinear.Tensor.$fNumT5
                                     ret_ty (# GHC.Real.Integral i, (GHC.Base.String, [i]),
                                               (GHC.Base.String, [i]), [i] -> [i] -> a #)
                                     of {}
                                  GHC.Types.True
                                  -> (# w1, (ww, ww1), (ww2, ww3),
                                        \ (ul :: [i]) (dl :: [i]) ->
                                        case ul of ul1 { DEFAULT ->
                                        case dl of dl1 { DEFAULT ->
                                        GHC.Num.-
                                          @ a
                                          w
                                          (ww4 ul1 dl1)
                                          (ww9 ul1 dl1) } } #) } } } }) -}
af7dda3feaca945ca45f4c486d4148ac
  $wds2 ::
    (GHC.Num.Num a, GHC.Real.Integral i) =>
    GHC.Base.String
    -> [i]
    -> GHC.Base.String
    -> [i]
    -> ([i] -> [i] -> a)
    -> GHC.Base.String
    -> [i]
    -> GHC.Base.String
    -> [i]
    -> ([i] -> [i] -> a)
    -> (# GHC.Real.Integral i, (GHC.Base.String, [i]),
          (GHC.Base.String, [i]), [i] -> [i] -> a #)
  {- Arity: 12, HasNoCafRefs,
     Strictness: <L,U(A,A,C(C1(U)),A,A,A,A)><L,U><L,U><L,1*U><L,U><L,1*U><S,C(C1(U))><L,1*U><L,1*U><L,1*U><L,1*U><S,C(C1(U))>,
     Inline: [0],
     Unfolding: (\ @ a
                   @ i
                   (w :: GHC.Num.Num a)
                   (w1 :: GHC.Real.Integral i)
                   (ww :: GHC.Base.String)
                   (ww1 :: [i])
                   (ww2 :: GHC.Base.String)
                   (ww3 :: [i])
                   (ww4 :: [i] -> [i] -> a)
                   (ww5 :: GHC.Base.String)
                   (ww6 :: [i])
                   (ww7 :: GHC.Base.String)
                   (ww8 :: [i])
                   (ww9 :: [i] -> [i] -> a) ->
                 let {
                   lvl13 :: GHC.Types.Int
                   = case GHC.List.$wlenAcc
                            @ GHC.Types.Char
                            ww2
                            0# of ww10 { DEFAULT ->
                     GHC.Types.I# ww10 }
                 } in
                 let {
                   lvl14 :: GHC.Types.Int
                   = case GHC.List.$wlenAcc
                            @ GHC.Types.Char
                            ww
                            0# of ww10 { DEFAULT ->
                     GHC.Types.I# ww10 }
                 } in
                 let {
                   lvl15 :: GHC.Types.Bool
                   = case lvl14 of wild1 { GHC.Types.I# y ->
                     GHC.Prim.tagToEnum# @ GHC.Types.Bool (GHC.Prim.<# 0# y) }
                 } in
                 let {
                   lvl16 :: GHC.Types.Bool
                   = case lvl13 of wild1 { GHC.Types.I# y ->
                     GHC.Prim.tagToEnum# @ GHC.Types.Bool (GHC.Prim.<# 0# y) }
                 } in
                 (# w1,
                    (GHC.Base.++ @ GHC.Types.Char ww ww5, GHC.Base.++ @ i ww1 ww6),
                    (GHC.Base.++ @ GHC.Types.Char ww2 ww7, GHC.Base.++ @ i ww3 ww8),
                    \ (ul :: [i]) (dl :: [i]) ->
                    case ul of ul1 { DEFAULT ->
                    case dl of dl1 { DEFAULT ->
                    GHC.Num.*
                      @ a
                      w
                      (ww4
                         (case lvl15 of wild {
                            GHC.Types.False -> GHC.Types.[] @ i
                            GHC.Types.True
                            -> case lvl14 of ww10 { GHC.Types.I# ww11 ->
                               GHC.List.$wunsafeTake @ i ww11 ul1 } })
                         (case lvl16 of wild {
                            GHC.Types.False -> GHC.Types.[] @ i
                            GHC.Types.True
                            -> case lvl13 of ww10 { GHC.Types.I# ww11 ->
                               GHC.List.$wunsafeTake @ i ww11 dl1 } }))
                      (ww9
                         (case lvl14 of wild { GHC.Types.I# x ->
                          case GHC.Prim.tagToEnum#
                                 @ GHC.Types.Bool
                                 (GHC.Prim.<=# x 0#) of wild1 {
                            GHC.Types.False -> Multilinear.Tensor.$wunsafeDrop1 @ i x ul1
                            GHC.Types.True -> ul1 } })
                         (case lvl13 of wild { GHC.Types.I# x ->
                          case GHC.Prim.tagToEnum#
                                 @ GHC.Types.Bool
                                 (GHC.Prim.<=# x 0#) of wild1 {
                            GHC.Types.False -> Multilinear.Tensor.$wunsafeDrop @ i x dl1
                            GHC.Types.True -> dl1 } })) } } #)) -}
db07a1302b70b910763cd3f09e138e88
  $wds3 ::
    (GHC.Num.Num a, GHC.Real.Integral i) =>
    GHC.Base.String
    -> [i]
    -> GHC.Base.String
    -> [i]
    -> ([i] -> [i] -> a)
    -> GHC.Base.String
    -> [i]
    -> GHC.Base.String
    -> [i]
    -> ([i] -> [i] -> a)
    -> (# GHC.Real.Integral i, (GHC.Base.String, [i]),
          (GHC.Base.String, [i]), [i] -> [i] -> a #)
  {- Arity: 12,
     Strictness: <L,U(C(C1(U)),A,A,A,A,A,A)><L,U(U,U,U,U,U,U,U,U,U)><S,U><S,U><S,U><S,U><S,C(C1(U))><S,1*U><S,1*U><S,1*U><S,1*U><S,C(C1(U))>,
     Inline: [0],
     Unfolding: (\ @ a
                   @ i
                   (w :: GHC.Num.Num a)
                   (w1 :: GHC.Real.Integral i)
                   (ww :: GHC.Base.String)
                   (ww1 :: [i])
                   (ww2 :: GHC.Base.String)
                   (ww3 :: [i])
                   (ww4 :: [i] -> [i] -> a)
                   (ww5 :: GHC.Base.String)
                   (ww6 :: [i])
                   (ww7 :: GHC.Base.String)
                   (ww8 :: [i])
                   (ww9 :: [i] -> [i] -> a) ->
                 case GHC.Base.eqString ww ww5 of wild {
                   GHC.Types.False
                   -> case Multilinear.Tensor.$fNumT10
                      ret_ty (# GHC.Real.Integral i, (GHC.Base.String, [i]),
                                (GHC.Base.String, [i]), [i] -> [i] -> a #)
                      of {}
                   GHC.Types.True
                   -> let {
                        $dReal :: GHC.Real.Real i = GHC.Real.$p1Integral @ i w1
                      } in
                      let {
                        $dOrd :: GHC.Classes.Ord i = GHC.Real.$p2Real @ i $dReal
                      } in
                      let {
                        $dEq :: GHC.Classes.Eq i = GHC.Classes.$p1Ord @ i $dOrd
                      } in
                      case GHC.Classes.$fEq[]_$c== @ i $dEq ww1 ww6 of wild1 {
                        GHC.Types.False
                        -> case Multilinear.Tensor.$fNumT10
                           ret_ty (# GHC.Real.Integral i, (GHC.Base.String, [i]),
                                     (GHC.Base.String, [i]), [i] -> [i] -> a #)
                           of {}
                        GHC.Types.True
                        -> case GHC.Base.eqString ww2 ww7 of wild2 {
                             GHC.Types.False
                             -> case Multilinear.Tensor.$fNumT10
                                ret_ty (# GHC.Real.Integral i, (GHC.Base.String, [i]),
                                          (GHC.Base.String, [i]), [i] -> [i] -> a #)
                                of {}
                             GHC.Types.True
                             -> case GHC.Classes.$fEq[]_$c== @ i $dEq ww3 ww8 of wild3 {
                                  GHC.Types.False
                                  -> case Multilinear.Tensor.$fNumT10
                                     ret_ty (# GHC.Real.Integral i, (GHC.Base.String, [i]),
                                               (GHC.Base.String, [i]), [i] -> [i] -> a #)
                                     of {}
                                  GHC.Types.True
                                  -> (# w1, (ww, ww1), (ww2, ww3),
                                        \ (ul :: [i]) (dl :: [i]) ->
                                        case ul of ul1 { DEFAULT ->
                                        case dl of dl1 { DEFAULT ->
                                        GHC.Num.+
                                          @ a
                                          w
                                          (ww4 ul1 dl1)
                                          (ww9 ul1 dl1) } } #) } } } }) -}
d5a55d781a14e283a1e3d2a66af7eaf8
  $wunsafeDrop :: GHC.Prim.Int# -> [a1] -> [a1]
  {- Arity: 2, HasNoCafRefs, Strictness: <L,1*U><S,1*U>,
     Inline: [0] -}
ca496058629f97bb77aa85d8e43f53ed
  $wunsafeDrop1 :: GHC.Prim.Int# -> [a1] -> [a1]
  {- Arity: 2, HasNoCafRefs, Strictness: <L,1*U><S,1*U>,
     Inline: [0] -}
db07a1302b70b910763cd3f09e138e88
  type role T representational nominal
  data T a i where
    T :: GHC.Real.Integral i =>
         !(GHC.Base.String, [i]) -> !(GHC.Base.String, [i])
         -> !([i] -> [i] -> a) -> T a i
6219cc244b3404a5fe351ec2c7c93c66
  el :: Multilinear.Tensor.T a i -> [i] -> [i] -> a
  {- Arity: 1, HasNoCafRefs, Strictness: <S(LLLS),1*U(A,A,A,U)>,
     Unfolding: InlineRule (1, True, False)
                (\ @ a @ i (ds :: Multilinear.Tensor.T a i) ->
                 case ds of wild { Multilinear.Tensor.T $dIntegral ds1 ds2 f ->
                 f }) -}
49831918a7c3f3e563a3397de63ab6b1
  lowIndices :: Multilinear.Tensor.T a i -> [(GHC.Types.Char, i)]
  {- Arity: 1, HasNoCafRefs,
     Strictness: <S(LLS(SL)L),1*U(A,A,U(1*U,1*U),A)>,
     Unfolding: InlineRule (1, True, False)
                (\ @ a @ i (ds :: Multilinear.Tensor.T a i) ->
                 case ds of wild { Multilinear.Tensor.T $dIntegral ds1 ds2 ds3 ->
                 case ds2 of wild1 { (,) ds4 dsize ->
                 GHC.Base.build
                   @ (GHC.Types.Char, i)
                   (\ @ b1
                      (c :: (GHC.Types.Char, i) -> b1 -> b1)[OneShot]
                      (n :: b1)[OneShot] ->
                    GHC.List.foldr2
                      @ GHC.Types.Char
                      @ i
                      @ b1
                      (GHC.List.zipFB @ GHC.Types.Char @ i @ b1 @ b1 c)
                      n
                      ds4
                      dsize) } }) -}
8420763adc4451f7069137f499267c46
  upIndices :: Multilinear.Tensor.T a i -> [(GHC.Types.Char, i)]
  {- Arity: 1, HasNoCafRefs,
     Strictness: <S(LS(SL)LL),1*U(A,U(1*U,1*U),A,A)>,
     Unfolding: InlineRule (1, True, False)
                (\ @ a @ i (ds :: Multilinear.Tensor.T a i) ->
                 case ds of wild { Multilinear.Tensor.T $dIntegral ds1 ds2 ds3 ->
                 case ds1 of wild1 { (,) us usize ->
                 GHC.Base.build
                   @ (GHC.Types.Char, i)
                   (\ @ b1
                      (c :: (GHC.Types.Char, i) -> b1 -> b1)[OneShot]
                      (n :: b1)[OneShot] ->
                    GHC.List.foldr2
                      @ GHC.Types.Char
                      @ i
                      @ b1
                      (GHC.List.zipFB @ GHC.Types.Char @ i @ b1 @ b1 c)
                      n
                      us
                      usize) } }) -}
instance [safe] GHC.Num.Num [Multilinear.Tensor.T]
  = Multilinear.Tensor.$fNumT
vectorised variables:
vectorised tycons:
vectorised reused tycons:
parallel variables:
parallel tycons:
trusted: safe
require own pkg trusted: False

