
==================== FINAL INTERFACE ====================
2017-03-04 20:24:45.9007363 UTC

interface Tensor-0.1.0.0-DFCluZsp6XcFZvvYzC4IXO:Tensor.Multilinear [orphan module] 8002
  interface hash: 3b16a9f49571db799b7f73e9324a9678
  ABI hash: faef532e05bf106652a91c7f432b3e0d
  export-list hash: 5f2e64a5c5abcd2222c69361cb54c252
  orphan hash: 477143017ec586518cf139c30887ad99
  flag hash: 60264da2687d437fc89049ac88238af8
  sig of: Nothing
  used TH splices: False
  where
exports:
  Tensor.Multilinear.Multilinear{Tensor.Multilinear.!*}
  Tensor.Multilinear.Tensor{Tensor.Multilinear.!==! Tensor.Multilinear.++ Tensor.Multilinear.concat Tensor.Multilinear.elems Tensor.Multilinear.equiv Tensor.Multilinear.fromList Tensor.Multilinear.generate Tensor.Multilinear.indices Tensor.Multilinear.order Tensor.Multilinear.rename Tensor.Multilinear.transpose Tensor.Multilinear.transpose1}
module dependencies: Tensor.Index
package dependencies: array-0.5.1.1@array-0.5.1.1 base-4.9.1.0*
                      binary-0.8.3.0@binary-0.8.3.0
                      bytestring-0.10.8.1@bytestring-0.10.8.1
                      containers-0.5.7.1@containers-0.5.7.1
                      deepseq-1.4.2.0@deepseq-1.4.2.0 ghc-prim-0.5.0.0
                      integer-gmp-1.0.0.1
orphans: base-4.9.1.0:GHC.Base base-4.9.1.0:GHC.Float
         binary-0.8.3.0@binary-0.8.3.0:Data.Binary.Generic
         bytestring-0.10.8.1@bytestring-0.10.8.1:Data.ByteString.Builder
family instance modules: base-4.9.1.0:Control.Applicative
                         base-4.9.1.0:Data.Complex base-4.9.1.0:Data.Either
                         base-4.9.1.0:Data.Functor.Const base-4.9.1.0:Data.Functor.Identity
                         base-4.9.1.0:Data.List.NonEmpty base-4.9.1.0:Data.Monoid
                         base-4.9.1.0:Data.Semigroup base-4.9.1.0:Data.Type.Equality
                         base-4.9.1.0:Data.Version base-4.9.1.0:Data.Void
                         base-4.9.1.0:GHC.Exts base-4.9.1.0:GHC.Generics
                         base-4.9.1.0:GHC.IO.Exception base-4.9.1.0:GHC.TypeLits
                         containers-0.5.7.1@containers-0.5.7.1:Data.IntMap.Base
                         containers-0.5.7.1@containers-0.5.7.1:Data.IntSet.Base
                         containers-0.5.7.1@containers-0.5.7.1:Data.Map.Base
                         containers-0.5.7.1@containers-0.5.7.1:Data.Sequence
                         containers-0.5.7.1@containers-0.5.7.1:Data.Set.Base
import  -/  Tensor.Index 07f27efab3d1cfa67eed4164f96ccb59
  exports: 93aea9d3f957c99d65d21a678155e4ef
  TIndex a2751c210a03e448893a9623f7f2d356
import  -/  base-4.9.1.0:Data.Functor 682cc832c233b71cec70179490a08631
import  -/  base-4.9.1.0:GHC.Base 4caea1123ecf4b46e27cbccd6d279377
import  -/  base-4.9.1.0:GHC.Num 38b8aac8807c096c7f3ca3c1eff02939
import  -/  base-4.9.1.0:Prelude 74b3e204395920329f6de9d97206abe9
import  -/  integer-gmp-1.0.0.1:GHC.Integer.Type 5e60b761569ee353529e98a36b72df11
fixities infixl 8 !*, infixl 6 !==!, infixl 3 ++
95e79c724504be39bf06cdf448399328
  $dm!==! :: Tensor.Multilinear.Tensor t => t -> t -> GHC.Types.Bool
  {- Arity: 3, HasNoCafRefs,
     Strictness: <S(LLLLLLLC(C(S))LLLLL),1*U(A,A,A,A,A,A,A,1*C1(C1(U)),A,A,A,A,A)><S,1*U><S,1*U>,
     Unfolding: InlineRule (3, True, False)
                (\ @ t
                   ($dTensor :: Tensor.Multilinear.Tensor t)
                   (t1 :: t)
                   (t2 :: t) ->
                 case t1 of t4 { DEFAULT ->
                 case t2 of t5 { DEFAULT ->
                 Tensor.Multilinear.equiv @ t $dTensor t4 t5 } }) -}
1f8ab616f4df89e1183564ce3f108840
  $dm++ ::
    Tensor.Multilinear.Tensor t => Tensor.Index.TIndex -> t -> t -> t
  {- Arity: 1, HasNoCafRefs,
     Strictness: <S(LLLLLLLLLLLSL),U(A,A,A,A,A,A,A,A,A,A,A,U,A)>,
     Unfolding: InlineRule (0, True, True) Tensor.Multilinear.concat -}
e6e5c838f3ba6fcb0652abbb67a2cf8b
  $fMultilinearDoubleDouble ::
    Tensor.Multilinear.Multilinear GHC.Types.Double GHC.Types.Double
  DFunId
  {- HasNoCafRefs, Strictness: m,
     Unfolding: DFun:.
                  @ GHC.Types.Double
                  @ GHC.Types.Double
                  GHC.Float.$fNumDouble
                  Tensor.Multilinear.$fMultilinearDoubleDouble_$c!* -}
1bfb77d45ac0d708873117e95609bf7b
  $fMultilinearDoubleDouble_$c!* ::
    GHC.Types.Double -> GHC.Types.Double -> GHC.Types.Double
  {- Arity: 2, HasNoCafRefs, Strictness: <S(S),1*U(U)><S(S),1*U(U)>m,
     Unfolding: InlineRule (2, True, False)
                (\ (x :: GHC.Types.Double) (y :: GHC.Types.Double) ->
                 case x of x1 { GHC.Types.D# ipv ->
                 case y of y1 { GHC.Types.D# ipv1 ->
                 GHC.Types.D# (GHC.Prim.*## ipv ipv1) } }) -}
e6e5c838f3ba6fcb0652abbb67a2cf8b
  $fMultilinearFloatFloat ::
    Tensor.Multilinear.Multilinear GHC.Types.Float GHC.Types.Float
  DFunId
  {- HasNoCafRefs, Strictness: m,
     Unfolding: DFun:.
                  @ GHC.Types.Float
                  @ GHC.Types.Float
                  GHC.Float.$fNumFloat
                  Tensor.Multilinear.$fMultilinearFloatFloat_$c!* -}
9fb1f20ba5dd12de697f128be04e303b
  $fMultilinearFloatFloat_$c!* ::
    GHC.Types.Float -> GHC.Types.Float -> GHC.Types.Float
  {- Arity: 2, HasNoCafRefs, Strictness: <S(S),1*U(U)><S(S),1*U(U)>m,
     Unfolding: InlineRule (2, True, False)
                (\ (x :: GHC.Types.Float) (y :: GHC.Types.Float) ->
                 case x of x1 { GHC.Types.F# ipv ->
                 case y of y1 { GHC.Types.F# ipv1 ->
                 GHC.Types.F# (GHC.Prim.timesFloat# ipv ipv1) } }) -}
e6e5c838f3ba6fcb0652abbb67a2cf8b
  $fMultilinearIntInt ::
    Tensor.Multilinear.Multilinear GHC.Types.Int GHC.Types.Int
  DFunId
  {- HasNoCafRefs, Strictness: m,
     Unfolding: DFun:.
                  @ GHC.Types.Int
                  @ GHC.Types.Int
                  GHC.Num.$fNumInt
                  Tensor.Multilinear.$fMultilinearIntInt_$c!* -}
a4ccf545322dfcf9952c6a7a59161bb0
  $fMultilinearIntInt_$c!* ::
    GHC.Types.Int -> GHC.Types.Int -> GHC.Types.Int
  {- Arity: 2, HasNoCafRefs, Strictness: <S(S),1*U(U)><S(S),1*U(U)>m,
     Unfolding: InlineRule (2, True, False)
                (\ (x :: GHC.Types.Int) (y :: GHC.Types.Int) ->
                 case x of x1 { GHC.Types.I# ipv ->
                 case y of y1 { GHC.Types.I# ipv1 ->
                 GHC.Types.I# (GHC.Prim.*# ipv ipv1) } }) -}
e6e5c838f3ba6fcb0652abbb67a2cf8b
  $fMultilinearIntegerInteger ::
    Tensor.Multilinear.Multilinear
      GHC.Integer.Type.Integer GHC.Integer.Type.Integer
  DFunId
  {- Strictness: m,
     Unfolding: DFun:.
                  @ GHC.Integer.Type.Integer
                  @ GHC.Integer.Type.Integer
                  GHC.Num.$fNumInteger
                  Tensor.Multilinear.$fMultilinearIntegerInteger_$c!* -}
06bf2f29b1e5d2336686ac51e5dc967c
  $fMultilinearIntegerInteger_$c!* ::
    GHC.Integer.Type.Integer
    -> GHC.Integer.Type.Integer -> GHC.Integer.Type.Integer
  {- Arity: 2, Strictness: <S,1*U><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ (x :: GHC.Integer.Type.Integer)
                   (y :: GHC.Integer.Type.Integer) ->
                 case x of x1 { DEFAULT ->
                 case y of y1 { DEFAULT ->
                 GHC.Integer.Type.timesInteger x1 y1 } }) -}
e6e5c838f3ba6fcb0652abbb67a2cf8b
  $fMultilinearWordWord ::
    Tensor.Multilinear.Multilinear GHC.Types.Word GHC.Types.Word
  DFunId
  {- HasNoCafRefs, Strictness: m,
     Unfolding: DFun:.
                  @ GHC.Types.Word
                  @ GHC.Types.Word
                  GHC.Num.$fNumWord
                  Tensor.Multilinear.$fMultilinearWordWord_$c!* -}
ee1cd8333c146b7bd00e203e2ddbc6e2
  $fMultilinearWordWord_$c!* ::
    GHC.Types.Word -> GHC.Types.Word -> GHC.Types.Word
  {- Arity: 2, HasNoCafRefs, Strictness: <S(S),1*U(U)><S(S),1*U(U)>m,
     Unfolding: InlineRule (2, True, False)
                (\ (x :: GHC.Types.Word) (y :: GHC.Types.Word) ->
                 case x of x1 { GHC.Types.W# ipv ->
                 case y of y1 { GHC.Types.W# ipv1 ->
                 GHC.Types.W# (GHC.Prim.timesWord# ipv ipv1) } }) -}
e6e5c838f3ba6fcb0652abbb67a2cf8b
  $fMultilinear[][] ::
    GHC.Num.Num a => Tensor.Multilinear.Multilinear [a] [[a]]
  DFunId
  {- Arity: 1, HasNoCafRefs,
     Strictness: <L,U(C(C1(U)),A,C(C(U)),C(U),C(U),C(U),C(U))>m,
     Unfolding: DFun: @ a ($dNum :: GHC.Num.Num a).
                  @ [a]
                  @ [[a]]
                  (Tensor.Multilinear.$fNum[] @ a $dNum)
                  (Tensor.Multilinear.$fMultilinear[][]_$c!* @ a $dNum) -}
922d726c20c785d26826f79ecbae79e2
  $fMultilinear[][]1 :: GHC.Num.Num a => [a] -> [a] -> [[a]]
  {- Arity: 3, HasNoCafRefs,
     Strictness: <L,U(A,A,C(C(U)),A,A,A,A)><S,1*U><S,1*U>m2,
     Inline: INLINE[0],
     Unfolding: InlineRule (3, True, False)
                (\ @ a (w :: GHC.Num.Num a) (w1 :: [a]) (w2 :: [a]) ->
                 case w1 of wild {
                   []
                   -> case w2 of l { DEFAULT ->
                      GHC.Types.: @ [a] l (GHC.Types.[] @ [a]) }
                   : ipv ipv1
                   -> case w2 of wild1 {
                        [] -> GHC.Types.: @ [a] wild (GHC.Types.[] @ [a])
                        : ipv2 ipv3
                        -> GHC.Types.:
                             @ [a]
                             (GHC.Base.map @ a @ a (GHC.Num.* @ a w ipv) wild1)
                             (case Tensor.Multilinear.$fMultilinear[][]_$s$wds
                                     @ a
                                     ipv2
                                     ipv3
                                     ipv1
                                     w of ww { (#,#) ww1 ww2 ->
                              GHC.Types.: @ [a] ww1 ww2 }) } }) -}
22d585f3bc19205b98d9771cad559e70
  $fMultilinear[][]_$c!* :: GHC.Num.Num a => [a] -> [a] -> [[a]]
  {- Arity: 3, HasNoCafRefs,
     Strictness: <L,U(A,A,C(C(U)),A,A,A,A)><S,1*U><S,1*U>m2,
     Unfolding: InlineRule (0, True, True)
                Tensor.Multilinear.$fMultilinear[][]1 -}
6a3abd4786e5111176f44acf1bbb5e2f
  $fMultilinear[][]_$s$wds ::
    a -> [a] -> [a] -> GHC.Num.Num a => (# [a], [[a]] #)
  {- Arity: 4, HasNoCafRefs,
     Strictness: <L,U><L,U><S,1*U><L,U(A,A,C(C(U)),A,A,A,A)> -}
4df662e9bf27868495338f54dbb588f5
  $fNum[] :: GHC.Num.Num a => GHC.Num.Num [a]
  DFunId
  {- Arity: 1, HasNoCafRefs,
     Strictness: <L,U(C(C1(U)),A,C(C1(U)),C(U),C(U),C(U),C(U))>m,
     Unfolding: DFun: @ a ($dNum :: GHC.Num.Num a).
                  @ [a]
                  (Tensor.Multilinear.$fNum[]_$c+ @ a $dNum)
                  (Tensor.Multilinear.$fNum[]_$c- @ a $dNum)
                  (Tensor.Multilinear.$fNum[]_$c* @ a $dNum)
                  (Tensor.Multilinear.$fNum[]4 @ a $dNum)
                  (Tensor.Multilinear.$fNum[]3 @ a $dNum)
                  (Tensor.Multilinear.$fNum[]2 @ a $dNum)
                  (Tensor.Multilinear.$fNum[]1 @ a $dNum) -}
0f4b5d15bb178962c3878cb5cf0e39e9
  $fNum[]1 :: GHC.Num.Num a => GHC.Integer.Type.Integer -> [a]
  {- Arity: 2, HasNoCafRefs,
     Strictness: <L,1*U(A,A,A,A,A,A,1*C1(U))><S,1*U>m2,
     Unfolding: InlineRule (2, True, False)
                (\ @ a ($dNum :: GHC.Num.Num a) (x :: GHC.Integer.Type.Integer) ->
                 case x of x1 { DEFAULT ->
                 GHC.Types.:
                   @ a
                   (GHC.Num.fromInteger @ a $dNum x1)
                   (GHC.Types.[] @ a) }) -}
eb99701053d3d2cc3fcf616a5f9408b1
  $fNum[]2 :: GHC.Num.Num a => [a] -> [a]
  {- Arity: 2, HasNoCafRefs,
     Strictness: <L,1*U(A,A,A,A,A,1*C(U),A)><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ @ a ($dNum :: GHC.Num.Num a) (eta :: [a]) ->
                 GHC.Base.build
                   @ a
                   (\ @ b1 (c :: a -> b1 -> b1)[OneShot] (n :: b1)[OneShot] ->
                    GHC.Base.foldr
                      @ a
                      @ b1
                      (GHC.Base.mapFB @ a @ b1 @ a c (GHC.Num.signum @ a $dNum))
                      n
                      eta)) -}
a80ea6cc629f65e5f8913c4b6f13152f
  $fNum[]3 :: GHC.Num.Num a => [a] -> [a]
  {- Arity: 2, HasNoCafRefs,
     Strictness: <L,1*U(A,A,A,A,1*C(U),A,A)><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ @ a ($dNum :: GHC.Num.Num a) (eta :: [a]) ->
                 GHC.Base.build
                   @ a
                   (\ @ b1 (c :: a -> b1 -> b1)[OneShot] (n :: b1)[OneShot] ->
                    GHC.Base.foldr
                      @ a
                      @ b1
                      (GHC.Base.mapFB @ a @ b1 @ a c (GHC.Num.abs @ a $dNum))
                      n
                      eta)) -}
b9244814db1225c42bd76a98203bc5c1
  $fNum[]4 :: GHC.Num.Num a => [a] -> [a]
  {- Arity: 2, HasNoCafRefs,
     Strictness: <L,1*U(A,A,A,1*C(U),A,A,A)><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ @ a ($dNum :: GHC.Num.Num a) (eta :: [a]) ->
                 GHC.Base.build
                   @ a
                   (\ @ b1 (c :: a -> b1 -> b1)[OneShot] (n :: b1)[OneShot] ->
                    GHC.Base.foldr
                      @ a
                      @ b1
                      (GHC.Base.mapFB @ a @ b1 @ a c (GHC.Num.negate @ a $dNum))
                      n
                      eta)) -}
11ea26ead4dd1d6eeeb6adf376b394c4
  $fNum[]5 :: GHC.Num.Num a => [a] -> [a] -> [a]
  {- Arity: 3, HasNoCafRefs,
     Strictness: <L,U(A,A,C(C1(U)),A,A,A,A)><S,1*U><S,1*U> -}
94fd606c150206cb33e93317d5c1d990
  $fNum[]6 :: GHC.Num.Num a => [a] -> [a] -> [a]
  {- Arity: 3, HasNoCafRefs,
     Strictness: <L,U(C(C1(U)),A,A,1*C(U),A,A,A)><S,1*U><S,1*U>,
     Unfolding: InlineRule (3, True, False)
                (\ @ a ($dNum :: GHC.Num.Num a) (eta :: [a]) (eta1 :: [a]) ->
                 Tensor.Multilinear.$fNum[]7
                   @ a
                   $dNum
                   eta
                   (Tensor.Multilinear.$fNum[]4 @ a $dNum eta1)) -}
3e3bf591e642abde3aeb2e0968230968
  $fNum[]7 :: GHC.Num.Num a => [a] -> [a] -> [a]
  {- Arity: 3, HasNoCafRefs,
     Strictness: <L,U(C(C1(U)),A,A,A,A,A,A)><S,1*U><S,1*U> -}
6d75fc8e5eb27cdb4c1dcf5148617135
  $fNum[]_$c* :: GHC.Num.Num a => [a] -> [a] -> [a]
  {- Arity: 3, HasNoCafRefs,
     Strictness: <L,U(A,A,C(C1(U)),A,A,A,A)><S,1*U><S,1*U>,
     Unfolding: InlineRule (0, True, True)
                Tensor.Multilinear.$fNum[]5 -}
759d3d54cc2690729673c8b82ba0b763
  $fNum[]_$c+ :: GHC.Num.Num a => [a] -> [a] -> [a]
  {- Arity: 3, HasNoCafRefs,
     Strictness: <L,U(C(C1(U)),A,A,A,A,A,A)><S,1*U><S,1*U>,
     Unfolding: InlineRule (0, True, True)
                Tensor.Multilinear.$fNum[]7 -}
241f16d6d45a5c086e36437d2fdb10a2
  $fNum[]_$c- :: GHC.Num.Num a => [a] -> [a] -> [a]
  {- Arity: 3, HasNoCafRefs,
     Strictness: <L,U(C(C1(U)),A,A,1*C(U),A,A,A)><S,1*U><S,1*U>,
     Unfolding: InlineRule (0, True, True)
                Tensor.Multilinear.$fNum[]6 -}
933eda1f82fd2a80086f13d78109e452
  $tc'C:Multilinear :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   3889372177757736580##
                   6361378256231745271##
                   Tensor.Multilinear.$trModule
                   Tensor.Multilinear.$tc'C:Multilinear1) -}
7b75f01259dbabf8acc84b6fd2a1a16b
  $tc'C:Multilinear1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "'C:Multilinear"#) -}
9826b7383edb2d19b8644bae61db8d57
  $tc'C:Tensor :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   22620775384304457##
                   15170313187536007019##
                   Tensor.Multilinear.$trModule
                   Tensor.Multilinear.$tc'C:Tensor1) -}
f0f99f05971efe3f9840647c962f20b9
  $tc'C:Tensor1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "'C:Tensor"#) -}
78de2e94101e9b9508b711fd8f57beec
  $tcMultilinear :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   6945867800443666694##
                   16697401487042495866##
                   Tensor.Multilinear.$trModule
                   Tensor.Multilinear.$tcMultilinear1) -}
e084ad94dd29585884a68c51bf86a183
  $tcMultilinear1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "Multilinear"#) -}
6a5e7876f10c30a0ab15017dd5642ee5
  $tcTensor :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   12914112907430251777##
                   6729450261079208136##
                   Tensor.Multilinear.$trModule
                   Tensor.Multilinear.$tcTensor1) -}
dbf721862c974444c6c955c21a966237
  $tcTensor1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "Tensor"#) -}
5c72bdc1de8fc4b0e05566b1524dd7fc
  $trModule :: GHC.Types.Module
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.Module
                   Tensor.Multilinear.$trModule2
                   Tensor.Multilinear.$trModule1) -}
ef87682a78daa3c0c2d7c2d6259acdcb
  $trModule1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "Tensor.Multilinear"#) -}
a9e619e8e7440f245a9bd829ca9d561d
  $trModule2 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS
                   "Tensor-0.1.0.0-DFCluZsp6XcFZvvYzC4IXO"#) -}
e6e5c838f3ba6fcb0652abbb67a2cf8b
  class GHC.Num.Num t => Multilinear t u where
    (!*) :: t -> t -> u
    {-# MINIMAL (!*) #-}
af8e6ccab27070ed0473f0479a3ecc79
  class GHC.Num.Num t => Tensor t where
    generate :: Tensor.Index.TIndex -> (GHC.Types.Int -> t) -> t
    fromList :: Tensor.Index.TIndex -> [a] -> t
    order :: t -> (GHC.Types.Int, GHC.Types.Int)
    elems :: t -> GHC.Types.Int
    indices :: t -> [Tensor.Index.TIndex]
    rename :: t -> GHC.Base.String -> GHC.Base.String -> t
    equiv :: t -> t -> GHC.Types.Bool
    (!==!) :: t -> t -> GHC.Types.Bool
    transpose :: t -> t
    transpose1 :: t -> t
    concat :: Tensor.Index.TIndex -> t -> t -> t
    (++) :: Tensor.Index.TIndex -> t -> t -> t
    {-# MINIMAL generate, fromList, order, elems, indices, rename,
                equiv, transpose, transpose1, concat #-}
instance [safe] Tensor.Multilinear.Multilinear [GHC.Types.Double,
                                                GHC.Types.Double]
  = Tensor.Multilinear.$fMultilinearDoubleDouble
instance [safe] Tensor.Multilinear.Multilinear [GHC.Types.Float,
                                                GHC.Types.Float]
  = Tensor.Multilinear.$fMultilinearFloatFloat
instance [safe] Tensor.Multilinear.Multilinear [GHC.Types.Int,
                                                GHC.Types.Int]
  = Tensor.Multilinear.$fMultilinearIntInt
instance [safe] Tensor.Multilinear.Multilinear [GHC.Integer.Type.Integer,
                                                GHC.Integer.Type.Integer]
  = Tensor.Multilinear.$fMultilinearIntegerInteger
instance [safe] Tensor.Multilinear.Multilinear [GHC.Types.Word,
                                                GHC.Types.Word]
  = Tensor.Multilinear.$fMultilinearWordWord
instance [safe] Tensor.Multilinear.Multilinear [[], []]
  = Tensor.Multilinear.$fMultilinear[][]
instance [safe] GHC.Num.Num [[]] = Tensor.Multilinear.$fNum[]
vectorised variables:
vectorised tycons:
vectorised reused tycons:
parallel variables:
parallel tycons:
trusted: safe
require own pkg trusted: False

