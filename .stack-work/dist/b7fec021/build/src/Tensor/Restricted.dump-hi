
==================== FINAL INTERFACE ====================
2017-01-18 20:16:57.8088076 UTC

interface Tensor-0.1.0.0-K5QdifOX00t2w9C27ImRWh:Tensor.Restricted 8001
  interface hash: d059dc75ede6837ef5e7147a531b4a3f
  ABI hash: 77c62fd08cbd093b6fbf31f6d01553ff
  export-list hash: 5577c0352c81e85e54556bf6635ffc29
  orphan hash: 693e9af84d3dfcc71e640e005bdc5e2e
  flag hash: 11c1d53d86ff1fc48fbbf191e9636203
  sig of: Nothing
  used TH splices: False
  where
exports:
  Tensor.Restricted._dot
  Tensor.Restricted.commonIndex
  Tensor.Restricted.kr
  Tensor.Restricted.kr3
  Tensor.Restricted.kr4
  Tensor.Restricted.switchInd
  Tensor.Restricted.switchInd'
  Tensor.Restricted.Tensor{Tensor.Restricted.Err Tensor.Restricted.Scalar Tensor.Restricted.Tensor errMsg scalarVal tensorData tensorIndex}
module dependencies: Tensor.Index Tensor.Multilinear
package dependencies: array-0.5.1.1@array-0.5.1.1 base-4.9.0.0*
                      binary-0.8.3.0@binary-0.8.3.0*
                      bytestring-0.10.8.1@bytestring-0.10.8.1
                      containers-0.5.7.1@containers-0.5.7.1
                      deepseq-1.4.2.0@deepseq-1.4.2.0 ghc-prim-0.5.0.0
                      integer-gmp-1.0.0.1
orphans: base-4.9.0.0:GHC.Base base-4.9.0.0:GHC.Float
         binary-0.8.3.0@binary-0.8.3.0:Data.Binary.Generic
         bytestring-0.10.8.1@bytestring-0.10.8.1:Data.ByteString.Builder
family instance modules: base-4.9.0.0:Control.Applicative
                         base-4.9.0.0:Data.Complex base-4.9.0.0:Data.Either
                         base-4.9.0.0:Data.Functor.Const base-4.9.0.0:Data.Functor.Identity
                         base-4.9.0.0:Data.List.NonEmpty base-4.9.0.0:Data.Monoid
                         base-4.9.0.0:Data.Semigroup base-4.9.0.0:Data.Type.Equality
                         base-4.9.0.0:Data.Version base-4.9.0.0:Data.Void
                         base-4.9.0.0:GHC.Exts base-4.9.0.0:GHC.Generics
                         base-4.9.0.0:GHC.IO.Exception base-4.9.0.0:GHC.TypeLits
                         containers-0.5.7.1@containers-0.5.7.1:Data.IntMap.Base
                         containers-0.5.7.1@containers-0.5.7.1:Data.IntSet.Base
                         containers-0.5.7.1@containers-0.5.7.1:Data.Map.Base
                         containers-0.5.7.1@containers-0.5.7.1:Data.Sequence
                         containers-0.5.7.1@containers-0.5.7.1:Data.Set.Base
import  -/  Tensor.Index 6bdc44f3d1849d0934612a9de4da6cc7
  exports: 3e404e500ff97a25d44a7567729a4ffe
  !=! 21cbcdd3bcb65f4efd82eb790d1c7ae5
  Contravariant 8c9c623965a045d09a43ac66045ac543
  Covariant 67a937141d096efbea881e08092a4c8e
  Indifferent db8f02b2f4eb753a9673f59305d7e370
  TIndex 2caa73acff6840ac777cf2a549dfd2e0
  indexCount 8c1a7fd557f5a4bf923f8ae431425619
  indexName e29c6ed4fb462258344a89fd7fd1bc42
import  -/  Tensor.Multilinear 300bb48a7ab08cf6176b08c588ef5d7b
  exports: 26f481e4d611bea5f7dc5876a98cf5e8
  !* 3ba90cb600a38b880e103cfc7992afca
  Multilinear 188043c18cfd402ee9da44ff088dc397
  elems 42d9fec06bb2ceeb6921463afd692e57
  generate 63a9582ae8cfef046a4e9a3f445dcd8b
  indices b4552ed7c262962fe78e4ec3cd7feddd
  order fef52b02ff43631029562fb267247b7b
  rename 6831e2b2fb8932f6b769c10e8c62557c
  transpose e9a48daf622abc1b841dc35db7be170b
import  -/  base-4.9.0.0:Control.Monad b6b2f076948b5e8acd6d95beb4d22bfc
import  -/  base-4.9.0.0:Data.Foldable 3cbed01c922be29649c33015287c82ca
import  -/  base-4.9.0.0:Data.Functor 67cebb006c069ea73adcd2d468cdb0dc
import  -/  base-4.9.0.0:Data.List d711f98b49ef5d33e5b3d404631ed073
import  -/  base-4.9.0.0:Data.Maybe 086a84053ef7f7810663b5f03b7ec3f7
import  -/  base-4.9.0.0:GHC.Base dd8044a8d640eee51828c17c476a6ba7
import  -/  base-4.9.0.0:GHC.Float a46e197015eefaa013d7004e58481c54
import  -/  base-4.9.0.0:GHC.List 47d436dfb7454bb1883fb4d943e3f389
import  -/  base-4.9.0.0:GHC.Num f0aed3315b3ed1b330b71fc4148a5581
import  -/  base-4.9.0.0:GHC.Real 011de9ca3282ad24a84e4e15f974f98e
import  -/  base-4.9.0.0:GHC.Show 0b5845243cb2ec62b57dd6963d276ec6
import  -/  base-4.9.0.0:Prelude 2d9cd8b0ec3d728f62b734df888d2e34
import  -/  binary-0.8.3.0@binary-0.8.3.0:Data.Binary 6874ec1640b9c9e26e0b523287f2c847
import  -/  binary-0.8.3.0@binary-0.8.3.0:Data.Binary.Class 8597f8b1c2ab4e12727292e0fd7fcc19
import  -/  binary-0.8.3.0@binary-0.8.3.0:Data.Binary.Get.Internal 2e7605525151d1d4905dbc0c729d189c
import  -/  ghc-prim-0.5.0.0:GHC.Classes 16d48e012d23eaef9bca91ccdd572c02
c597b80271b7834390e27f13cb520dc7
  (!*!) ::
    GHC.Num.Num a =>
    Tensor.Restricted.Tensor a
    -> Tensor.Restricted.Tensor a -> Tensor.Restricted.Tensor a
  {- Arity: 3,
     Strictness: <L,U(C(U),A,C(U),A,A,A,C(U))><S,1*U><S,1*U> -}
c597b80271b7834390e27f13cb520dc7
  $fBinaryTensor ::
    Data.Binary.Class.Binary a =>
    Data.Binary.Class.Binary (Tensor.Restricted.Tensor a)
  DFunId
  {- Arity: 1, Strictness: <L,U(C(U(U,U)),U,A)>m,
     Unfolding: DFun: @ a ($dBinary :: Data.Binary.Class.Binary a).
                  @ (Tensor.Restricted.Tensor a)
                  (Tensor.Restricted.$fBinaryTensor_$cput @ a $dBinary)
                  (Tensor.Restricted.$fBinaryTensor_$cget @ a $dBinary)
                  (Tensor.Restricted.$fBinaryTensor_$cputList @ a $dBinary) -}
c597b80271b7834390e27f13cb520dc7
  $fBinaryTensor1 ::
    Data.Binary.Class.Binary a =>
    [Tensor.Restricted.Tensor a] -> Data.Binary.Put.Put
  {- Arity: 1, Strictness: <L,U(C(U(U,U)),U,A)> -}
c597b80271b7834390e27f13cb520dc7
  $fBinaryTensor2 ::
    Data.Binary.Class.Binary a =>
    Data.Binary.Get.Internal.Get (Tensor.Restricted.Tensor a)
  {- Arity: 1, Strictness: <L,U(C(U(U,U)),U,A)> -}
c597b80271b7834390e27f13cb520dc7
  $fBinaryTensor_$cget ::
    Data.Binary.Class.Binary a =>
    Data.Binary.Get.Internal.Get (Tensor.Restricted.Tensor a)
  {- Arity: 1, Strictness: <L,U(C(U(U,U)),U,A)>,
     Unfolding: InlineRule (0, True, True)
                Tensor.Restricted.$fBinaryTensor2 -}
c597b80271b7834390e27f13cb520dc7
  $fBinaryTensor_$cput ::
    Data.Binary.Class.Binary a =>
    Tensor.Restricted.Tensor a -> Data.Binary.Put.Put
  {- Arity: 2, Strictness: <L,U(C(U(U,U)),U,A)><S,1*U>m,
     Inline: INLINE[0],
     Unfolding: InlineRule (2, True, False)
                (\ @ a
                   (w :: Data.Binary.Class.Binary a)
                   (w1 :: Tensor.Restricted.Tensor a) ->
                 case Tensor.Restricted.$w$cput @ a w w1 of ww { (#,#) ww1 ww2 ->
                 (Data.Binary.Put.PairS @ () ww1 ww2)
                   `cast`
                 (Sym (Data.Binary.Put.N:PutM[0]) <()>_N) }) -}
c597b80271b7834390e27f13cb520dc7
  $fBinaryTensor_$cputList ::
    Data.Binary.Class.Binary a =>
    [Tensor.Restricted.Tensor a] -> Data.Binary.Put.Put
  {- Arity: 1, Strictness: <L,U(C(U(U,U)),U,A)>,
     Unfolding: InlineRule (0, True, True)
                Tensor.Restricted.$fBinaryTensor1 -}
c597b80271b7834390e27f13cb520dc7
  $fEqTensor ::
    GHC.Classes.Eq a => GHC.Classes.Eq (Tensor.Restricted.Tensor a)
  DFunId
  {- Arity: 1, HasNoCafRefs, Strictness: <L,U(C(C1(U)),A)>m,
     Unfolding: DFun: @ a ($dEq :: GHC.Classes.Eq a).
                  @ (Tensor.Restricted.Tensor a)
                  (Tensor.Restricted.$fEqTensor_$c== @ a $dEq)
                  (Tensor.Restricted.$fEqTensor_$c/= @ a $dEq) -}
c597b80271b7834390e27f13cb520dc7
  $fEqTensor1 ::
    GHC.Classes.Eq a =>
    Tensor.Restricted.Tensor a
    -> Tensor.Restricted.Tensor a -> GHC.Types.Bool
  {- Arity: 3, HasNoCafRefs,
     Strictness: <L,U(C(C1(U)),A)><S,1*U><S,1*U> -}
c597b80271b7834390e27f13cb520dc7
  $fEqTensor2 ::
    GHC.Classes.Eq a =>
    Tensor.Restricted.Tensor a
    -> Tensor.Restricted.Tensor a -> GHC.Types.Bool
  {- Arity: 1, HasNoCafRefs, Strictness: <L,U(C(C1(U)),A)> -}
c597b80271b7834390e27f13cb520dc7
  $fEqTensor_$c/= ::
    GHC.Classes.Eq a =>
    Tensor.Restricted.Tensor a
    -> Tensor.Restricted.Tensor a -> GHC.Types.Bool
  {- Arity: 3, HasNoCafRefs,
     Strictness: <L,U(C(C1(U)),A)><S,1*U><S,1*U>,
     Unfolding: InlineRule (0, True, True)
                Tensor.Restricted.$fEqTensor1 -}
c597b80271b7834390e27f13cb520dc7
  $fEqTensor_$c== ::
    GHC.Classes.Eq a =>
    Tensor.Restricted.Tensor a
    -> Tensor.Restricted.Tensor a -> GHC.Types.Bool
  {- Arity: 1, HasNoCafRefs, Strictness: <L,U(C(C1(U)),A)>,
     Unfolding: InlineRule (0, True, True)
                Tensor.Restricted.$fEqTensor2 -}
c597b80271b7834390e27f13cb520dc7
  $fFloatingTensor ::
    GHC.Float.Floating a =>
    GHC.Float.Floating (Tensor.Restricted.Tensor a)
  DFunId
  {- Arity: 1,
     Strictness: <L,U(U(U(U,U,U,U,U,U,U),U,U,U),1*U,C(U),C(U),A,A,A,C(U),C(U),A,C(U),C(U),C(U),C(U),C(U),A,C(U),C(U),C(U),A,A,A,A)>,
     Unfolding: DFun: @ a ($dFloating :: GHC.Float.Floating a).
                  @ (Tensor.Restricted.Tensor a)
                  (Tensor.Restricted.$fFloatingTensor32 @ a $dFloating)
                  (Tensor.Restricted.$fFloatingTensor31 @ a $dFloating)
                  (Tensor.Restricted.$fFloatingTensor_$cexp @ a $dFloating)
                  (Tensor.Restricted.$fFloatingTensor_$clog @ a $dFloating)
                  (Tensor.Restricted.$fFloatingTensor_$csqrt @ a $dFloating)
                  (Tensor.Restricted.$fFloatingTensor_$c** @ a $dFloating)
                  (Tensor.Restricted.$fFloatingTensor_$clogBase @ a $dFloating)
                  (Tensor.Restricted.$fFloatingTensor_$csin @ a $dFloating)
                  (Tensor.Restricted.$fFloatingTensor_$ccos @ a $dFloating)
                  (Tensor.Restricted.$fFloatingTensor_$ctan @ a $dFloating)
                  (Tensor.Restricted.$fFloatingTensor_$casin @ a $dFloating)
                  (Tensor.Restricted.$fFloatingTensor_$cacos @ a $dFloating)
                  (Tensor.Restricted.$fFloatingTensor_$catan @ a $dFloating)
                  (Tensor.Restricted.$fFloatingTensor_$csinh @ a $dFloating)
                  (Tensor.Restricted.$fFloatingTensor_$ccosh @ a $dFloating)
                  (Tensor.Restricted.$fFloatingTensor_$ctanh @ a $dFloating)
                  (Tensor.Restricted.$fFloatingTensor_$casinh @ a $dFloating)
                  (Tensor.Restricted.$fFloatingTensor_$cacosh @ a $dFloating)
                  (Tensor.Restricted.$fFloatingTensor_$catanh @ a $dFloating)
                  (Tensor.Restricted.$fFloatingTensor_$clog1p @ a $dFloating)
                  (Tensor.Restricted.$fFloatingTensor_$cexpm1 @ a $dFloating)
                  (Tensor.Restricted.$fFloatingTensor_$clog1pexp @ a $dFloating)
                  (Tensor.Restricted.$fFloatingTensor_$clog1mexp @ a $dFloating) -}
c597b80271b7834390e27f13cb520dc7
  $fFloatingTensor1 ::
    GHC.Float.Floating a =>
    Tensor.Restricted.Tensor a -> Tensor.Restricted.Tensor a
  {- Arity: 2,
     Strictness: <S(S(S(LLLLLLC(S))LLL)LLLLLLLLLLLLLLLLLLLLLL),U(U(U(U,U,U,U,U,U,U),U,U,U),A,C(U),C(U),A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A)><S,1*U>,
     Unfolding: (\ @ a
                   ($dFloating :: GHC.Float.Floating a)
                   (eta :: Tensor.Restricted.Tensor a) ->
                 let {
                   $dNum :: GHC.Real.Fractional a
                   = GHC.Float.$p1Floating @ a $dFloating
                 } in
                 let {
                   $dNum1 :: GHC.Num.Num a = GHC.Real.$p1Fractional @ a $dNum
                 } in
                 case GHC.Num.fromInteger
                        @ a
                        $dNum1
                        Tensor.Restricted.$fFloatingTensor8 of dt1 { DEFAULT ->
                 Tensor.Restricted.$fFloatingTensor4
                   @ a
                   $dFloating
                   (Tensor.Restricted.$fFloatingTensor3
                      @ a
                      $dNum1
                      (Tensor.Restricted.Scalar @ a dt1)
                      (Tensor.Restricted.$fFloatingTensor2 @ a $dFloating eta)) }) -}
c597b80271b7834390e27f13cb520dc7
  $fFloatingTensor10 ::
    GHC.Float.Floating a =>
    Tensor.Restricted.Tensor a -> Tensor.Restricted.Tensor a
  {- Arity: 2,
     Strictness: <S(SLLLLLLLLLLLLLLLLLLLLLL),U(1*U,A,C(U),A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A)><S,1*U>,
     Unfolding: (\ @ a
                   ($dFloating :: GHC.Float.Floating a)
                   (eta :: Tensor.Restricted.Tensor a) ->
                 let {
                   $dFractional :: GHC.Real.Fractional a
                   = GHC.Float.$p1Floating @ a $dFloating
                 } in
                 let {
                   $dNum :: GHC.Num.Num a = GHC.Real.$p1Fractional @ a $dFractional
                 } in
                 case GHC.Num.fromInteger
                        @ a
                        $dNum
                        Tensor.Restricted.$fFloatingTensor7 of dt1 { DEFAULT ->
                 Tensor.Restricted.$fFloatingTensor3
                   @ a
                   $dNum
                   (Tensor.Restricted.$fFloatingTensor2 @ a $dFloating eta)
                   (Tensor.Restricted.Scalar @ a dt1) }) -}
c597b80271b7834390e27f13cb520dc7
  $fFloatingTensor11 ::
    GHC.Float.Floating a =>
    Tensor.Restricted.Tensor a -> Tensor.Restricted.Tensor a
  {- Arity: 2, HasNoCafRefs,
     Strictness: <L,U(A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,C(U),A,A,A,A)><S,1*U> -}
c597b80271b7834390e27f13cb520dc7
  $fFloatingTensor12 ::
    GHC.Float.Floating a =>
    Tensor.Restricted.Tensor a -> Tensor.Restricted.Tensor a
  {- Arity: 2, HasNoCafRefs,
     Strictness: <L,U(A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,C(U),A,A,A,A,A)><S,1*U> -}
c597b80271b7834390e27f13cb520dc7
  $fFloatingTensor13 ::
    GHC.Float.Floating a =>
    Tensor.Restricted.Tensor a -> Tensor.Restricted.Tensor a
  {- Arity: 2, HasNoCafRefs,
     Strictness: <L,U(A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,C(U),A,A,A,A,A,A)><S,1*U> -}
c597b80271b7834390e27f13cb520dc7
  $fFloatingTensor14 ::
    GHC.Float.Floating a =>
    Tensor.Restricted.Tensor a -> Tensor.Restricted.Tensor a
  {- Arity: 2,
     Strictness: <L,U(1*U(A,C(U),A,A),A,A,A,A,A,A,A,A,A,A,A,A,C(U),C(U),A,A,A,A,A,A,A,A)><S,U>,
     Unfolding: (\ @ a
                   ($dFloating :: GHC.Float.Floating a)
                   (eta :: Tensor.Restricted.Tensor a) ->
                 Tensor.Restricted.$fFloatingTensor17
                   @ a
                   (GHC.Float.$p1Floating @ a $dFloating)
                   (Tensor.Restricted.$fFloatingTensor16 @ a $dFloating eta)
                   (Tensor.Restricted.$fFloatingTensor15 @ a $dFloating eta)) -}
c597b80271b7834390e27f13cb520dc7
  $fFloatingTensor15 ::
    GHC.Float.Floating a =>
    Tensor.Restricted.Tensor a -> Tensor.Restricted.Tensor a
  {- Arity: 2, HasNoCafRefs,
     Strictness: <L,U(A,A,A,A,A,A,A,A,A,A,A,A,A,A,C(U),A,A,A,A,A,A,A,A)><S,1*U> -}
c597b80271b7834390e27f13cb520dc7
  $fFloatingTensor16 ::
    GHC.Float.Floating a =>
    Tensor.Restricted.Tensor a -> Tensor.Restricted.Tensor a
  {- Arity: 2, HasNoCafRefs,
     Strictness: <L,U(A,A,A,A,A,A,A,A,A,A,A,A,A,C(U),A,A,A,A,A,A,A,A,A)><S,1*U> -}
c597b80271b7834390e27f13cb520dc7
  $fFloatingTensor17 ::
    GHC.Real.Fractional a =>
    Tensor.Restricted.Tensor a
    -> Tensor.Restricted.Tensor a -> Tensor.Restricted.Tensor a
  {- Arity: 3, Strictness: <L,U(A,C(U),A,A)><S,1*U><S,1*U> -}
c597b80271b7834390e27f13cb520dc7
  $fFloatingTensor18 ::
    GHC.Float.Floating a =>
    Tensor.Restricted.Tensor a -> Tensor.Restricted.Tensor a
  {- Arity: 2, HasNoCafRefs,
     Strictness: <L,U(A,A,A,A,A,A,A,A,A,A,A,A,C(U),A,A,A,A,A,A,A,A,A,A)><S,1*U> -}
c597b80271b7834390e27f13cb520dc7
  $fFloatingTensor19 ::
    GHC.Float.Floating a =>
    Tensor.Restricted.Tensor a -> Tensor.Restricted.Tensor a
  {- Arity: 2, HasNoCafRefs,
     Strictness: <L,U(A,A,A,A,A,A,A,A,A,A,A,C(U),A,A,A,A,A,A,A,A,A,A,A)><S,1*U> -}
c597b80271b7834390e27f13cb520dc7
  $fFloatingTensor2 ::
    GHC.Float.Floating a =>
    Tensor.Restricted.Tensor a -> Tensor.Restricted.Tensor a
  {- Arity: 2, HasNoCafRefs,
     Strictness: <L,U(A,A,C(U),A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A)><S,1*U> -}
c597b80271b7834390e27f13cb520dc7
  $fFloatingTensor20 ::
    GHC.Float.Floating a =>
    Tensor.Restricted.Tensor a -> Tensor.Restricted.Tensor a
  {- Arity: 2, HasNoCafRefs,
     Strictness: <L,U(A,A,A,A,A,A,A,A,A,A,C(U),A,A,A,A,A,A,A,A,A,A,A,A)><S,1*U> -}
c597b80271b7834390e27f13cb520dc7
  $fFloatingTensor21 ::
    GHC.Float.Floating a =>
    Tensor.Restricted.Tensor a -> Tensor.Restricted.Tensor a
  {- Arity: 2,
     Strictness: <L,U(1*U(A,C(U),A,A),A,A,A,A,A,A,C(U),C(U),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><S,U>,
     Unfolding: (\ @ a
                   ($dFloating :: GHC.Float.Floating a)
                   (eta :: Tensor.Restricted.Tensor a) ->
                 Tensor.Restricted.$fFloatingTensor17
                   @ a
                   (GHC.Float.$p1Floating @ a $dFloating)
                   (Tensor.Restricted.$fFloatingTensor23 @ a $dFloating eta)
                   (Tensor.Restricted.$fFloatingTensor22 @ a $dFloating eta)) -}
c597b80271b7834390e27f13cb520dc7
  $fFloatingTensor22 ::
    GHC.Float.Floating a =>
    Tensor.Restricted.Tensor a -> Tensor.Restricted.Tensor a
  {- Arity: 2, HasNoCafRefs,
     Strictness: <L,U(A,A,A,A,A,A,A,A,C(U),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><S,1*U> -}
c597b80271b7834390e27f13cb520dc7
  $fFloatingTensor23 ::
    GHC.Float.Floating a =>
    Tensor.Restricted.Tensor a -> Tensor.Restricted.Tensor a
  {- Arity: 2, HasNoCafRefs,
     Strictness: <L,U(A,A,A,A,A,A,A,C(U),A,A,A,A,A,A,A,A,A,A,A,A,A,A,A)><S,1*U> -}
c597b80271b7834390e27f13cb520dc7
  $fFloatingTensor24 ::
    GHC.Float.Floating a =>
    Tensor.Restricted.Tensor a
    -> Tensor.Restricted.Tensor a -> Tensor.Restricted.Tensor a
  {- Arity: 3,
     Strictness: <L,U(1*U(A,C(U),A,A),A,A,C(U),A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A)><S,1*U><S,1*U>,
     Unfolding: (\ @ a
                   ($dFloating :: GHC.Float.Floating a)
                   (eta :: Tensor.Restricted.Tensor a)
                   (eta1 :: Tensor.Restricted.Tensor a) ->
                 Tensor.Restricted.$fFloatingTensor17
                   @ a
                   (GHC.Float.$p1Floating @ a $dFloating)
                   (Tensor.Restricted.$fFloatingTensor6 @ a $dFloating eta1)
                   (Tensor.Restricted.$fFloatingTensor6 @ a $dFloating eta)) -}
c597b80271b7834390e27f13cb520dc7
  $fFloatingTensor25 ::
    GHC.Float.Floating a =>
    Tensor.Restricted.Tensor a
    -> Tensor.Restricted.Tensor a -> Tensor.Restricted.Tensor a
  {- Arity: 3,
     Strictness: <L,U(1*U(1*U(C(U),A,C(U),A,A,A,C(U)),A,A,A),A,C(U),C(U),A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A)><S,1*U><S,1*U>,
     Unfolding: (\ @ a
                   ($dFloating :: GHC.Float.Floating a)
                   (eta :: Tensor.Restricted.Tensor a)
                   (eta1 :: Tensor.Restricted.Tensor a) ->
                 Tensor.Restricted.$fFloatingTensor2
                   @ a
                   $dFloating
                   (Tensor.Restricted.$fFloatingTensor26
                      @ a
                      (GHC.Real.$p1Fractional @ a (GHC.Float.$p1Floating @ a $dFloating))
                      (Tensor.Restricted.$fFloatingTensor6 @ a $dFloating eta)
                      eta1)) -}
c597b80271b7834390e27f13cb520dc7
  $fFloatingTensor26 ::
    GHC.Num.Num a =>
    Tensor.Restricted.Tensor a
    -> Tensor.Restricted.Tensor a -> Tensor.Restricted.Tensor a
  {- Arity: 3,
     Strictness: <L,U(C(U),A,C(U),A,A,A,C(U))><S,1*U><S,1*U>,
     Unfolding: (\ @ a
                   ($dNum :: GHC.Num.Num a)
                   (ds2 :: Tensor.Restricted.Tensor a)
                   (ds3 :: Tensor.Restricted.Tensor a) ->
                 case ds2 of wild {
                   DEFAULT
                   -> case ds3 of wild1 {
                        DEFAULT
                        -> case wild of wild2 {
                             Tensor.Restricted.Tensor ds4 ds5
                             -> case wild1 of wild3 {
                                  Tensor.Restricted.Tensor ds6 ds7
                                  -> case Tensor.Restricted.commonIndex
                                            @ a
                                            wild2
                                            wild3 of cmi { DEFAULT ->
                                     Tensor.Restricted.!*!
                                       @ a
                                       $dNum
                                       (Tensor.Restricted.switchInd' @ a wild2 cmi)
                                       (Tensor.Restricted.switchInd' @ a wild3 cmi) }
                                  Tensor.Restricted.Err ipv -> wild3 }
                             Tensor.Restricted.Err msg -> wild2 }
                        Tensor.Restricted.Scalar x2
                        -> Tensor.Restricted.$fFloatingTensor27
                             @ a
                             @ a
                             (\ (ds4 :: a) -> GHC.Num.* @ a $dNum ds4 x2)
                             wild }
                   Tensor.Restricted.Scalar x1
                   -> case ds3 of wild1 {
                        DEFAULT
                        -> Tensor.Restricted.$fFloatingTensor27
                             @ a
                             @ a
                             (GHC.Num.* @ a $dNum x1)
                             wild1
                        Tensor.Restricted.Scalar x2
                        -> case GHC.Num.* @ a $dNum x1 x2 of dt1 { DEFAULT ->
                           Tensor.Restricted.Scalar @ a dt1 } } }) -}
c597b80271b7834390e27f13cb520dc7
  $fFloatingTensor27 ::
    (a -> b)
    -> Tensor.Restricted.Tensor a -> Tensor.Restricted.Tensor b
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U> -}
c597b80271b7834390e27f13cb520dc7
  $fFloatingTensor28 ::
    GHC.Float.Floating a =>
    Tensor.Restricted.Tensor a -> Tensor.Restricted.Tensor a
  {- Arity: 2,
     Strictness: <S(S(LLLC(S))LLLLLLLLLLLLLLLLLLLLLL),U(U(U(C(U),A,C(U),A,A,A,C(U)),A,A,1*C1(U)),A,C(U),C(U),A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A)><S,1*U>,
     Unfolding: (\ @ a
                   ($dFloating :: GHC.Float.Floating a)
                   (eta :: Tensor.Restricted.Tensor a) ->
                 case GHC.Real.fromRational
                        @ a
                        (GHC.Float.$p1Floating @ a $dFloating)
                        Tensor.Restricted.$fFloatingTensor29 of dt1 { DEFAULT ->
                 Tensor.Restricted.$fFloatingTensor25
                   @ a
                   $dFloating
                   eta
                   (Tensor.Restricted.Scalar @ a dt1) }) -}
37e9e8a9c9898bccd7eb91f42da9dbf6
  $fFloatingTensor29 :: GHC.Real.Ratio GHC.Integer.Type.Integer
  {- HasNoCafRefs,
     Unfolding: (GHC.Real.:%
                   @ GHC.Integer.Type.Integer
                   Tensor.Restricted.$fFloatingTensor7
                   Tensor.Restricted.$fFloatingTensor30) -}
c597b80271b7834390e27f13cb520dc7
  $fFloatingTensor3 ::
    GHC.Num.Num a =>
    Tensor.Restricted.Tensor a
    -> Tensor.Restricted.Tensor a -> Tensor.Restricted.Tensor a
  {- Arity: 3,
     Strictness: <L,U(A,C(C1(U)),A,A,A,A,A)><S,1*U><S,1*U> -}
f205f168a1d013ffa4590e612dd7a461
  $fFloatingTensor30 :: GHC.Integer.Type.Integer
  {- HasNoCafRefs, Unfolding: (2) -}
c597b80271b7834390e27f13cb520dc7
  $fFloatingTensor31 ::
    GHC.Float.Floating a => Tensor.Restricted.Tensor a
  {- Arity: 1, HasNoCafRefs,
     Strictness: <S(LSLLLLLLLLLLLLLLLLLLLLL),1*U(A,1*U,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A)>m1,
     Unfolding: InlineRule (1, True, False)
                (\ @ a ($dFloating :: GHC.Float.Floating a) ->
                 case GHC.Float.pi @ a $dFloating of dt1 { DEFAULT ->
                 Tensor.Restricted.Scalar @ a dt1 }) -}
c597b80271b7834390e27f13cb520dc7
  $fFloatingTensor32 ::
    GHC.Float.Floating a =>
    GHC.Real.Fractional (Tensor.Restricted.Tensor a)
  {- Arity: 1,
     Strictness: <L,1*U(1*U(U(C(U),C(C1(U)),C(U),A,C(U),C(U),C(U)),C(U),A,C(U)),A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A)>m,
     Unfolding: InlineRule (1, True, False)
                (\ @ a ($dFloating :: GHC.Float.Floating a) ->
                 Tensor.Restricted.$fFractionalTensor
                   @ a
                   (GHC.Float.$p1Floating @ a $dFloating)) -}
c597b80271b7834390e27f13cb520dc7
  $fFloatingTensor4 ::
    GHC.Float.Floating a =>
    Tensor.Restricted.Tensor a -> Tensor.Restricted.Tensor a
  {- Arity: 2,
     Strictness: <S(SLLLLLLLLLLLLLLLLLLLLLL),U(1*U,A,A,C(U),A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A)><S,1*U>,
     Unfolding: (\ @ a
                   ($dFloating :: GHC.Float.Floating a)
                   (eta :: Tensor.Restricted.Tensor a) ->
                 let {
                   $dFractional :: GHC.Real.Fractional a
                   = GHC.Float.$p1Floating @ a $dFloating
                 } in
                 let {
                   $dNum :: GHC.Num.Num a = GHC.Real.$p1Fractional @ a $dFractional
                 } in
                 case GHC.Num.fromInteger
                        @ a
                        $dNum
                        Tensor.Restricted.$fFloatingTensor7 of dt1 { DEFAULT ->
                 Tensor.Restricted.$fFloatingTensor6
                   @ a
                   $dFloating
                   (Tensor.Restricted.$fFloatingTensor5
                      @ a
                      $dNum
                      (Tensor.Restricted.Scalar @ a dt1)
                      eta) }) -}
c597b80271b7834390e27f13cb520dc7
  $fFloatingTensor5 ::
    GHC.Num.Num a =>
    Tensor.Restricted.Tensor a
    -> Tensor.Restricted.Tensor a -> Tensor.Restricted.Tensor a
  {- Arity: 3, Strictness: <L,U(C(U),A,A,A,A,A,A)><S,1*U><S,1*U> -}
c597b80271b7834390e27f13cb520dc7
  $fFloatingTensor6 ::
    GHC.Float.Floating a =>
    Tensor.Restricted.Tensor a -> Tensor.Restricted.Tensor a
  {- Arity: 2, HasNoCafRefs,
     Strictness: <L,U(A,A,A,C(U),A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A)><S,1*U> -}
f266a53a30455531a28befec5e9ec98b
  $fFloatingTensor7 :: GHC.Integer.Type.Integer
  {- HasNoCafRefs, Unfolding: (1) -}
dcbf224ee6e0ef1be0883f4d4c629f39
  $fFloatingTensor8 :: GHC.Integer.Type.Integer
  {- HasNoCafRefs, Unfolding: (0) -}
c597b80271b7834390e27f13cb520dc7
  $fFloatingTensor9 ::
    GHC.Float.Floating a =>
    Tensor.Restricted.Tensor a -> Tensor.Restricted.Tensor a
  {- Arity: 2,
     Strictness: <S(SLLLLLLLLLLLLLLLLLLLLLL),U(U,A,C(U),C(U),A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A)><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ @ a
                   ($dFloating :: GHC.Float.Floating a)
                   (eta :: Tensor.Restricted.Tensor a) ->
                 Tensor.Restricted.$fFloatingTensor4
                   @ a
                   $dFloating
                   (Tensor.Restricted.$fFloatingTensor2 @ a $dFloating eta)) -}
c597b80271b7834390e27f13cb520dc7
  $fFloatingTensor_$c** ::
    GHC.Float.Floating a =>
    Tensor.Restricted.Tensor a
    -> Tensor.Restricted.Tensor a -> Tensor.Restricted.Tensor a
  {- Arity: 3,
     Strictness: <L,U(1*U(1*U(C(U),A,C(U),A,A,A,C(U)),A,A,A),A,C(U),C(U),A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A)><S,1*U><S,1*U>,
     Unfolding: InlineRule (0, True, True)
                Tensor.Restricted.$fFloatingTensor25 -}
c597b80271b7834390e27f13cb520dc7
  $fFloatingTensor_$cacos ::
    GHC.Float.Floating a =>
    Tensor.Restricted.Tensor a -> Tensor.Restricted.Tensor a
  {- Arity: 2, HasNoCafRefs,
     Strictness: <L,U(A,A,A,A,A,A,A,A,A,A,A,C(U),A,A,A,A,A,A,A,A,A,A,A)><S,1*U>,
     Unfolding: InlineRule (0, True, True)
                Tensor.Restricted.$fFloatingTensor19 -}
c597b80271b7834390e27f13cb520dc7
  $fFloatingTensor_$cacosh ::
    GHC.Float.Floating a =>
    Tensor.Restricted.Tensor a -> Tensor.Restricted.Tensor a
  {- Arity: 2, HasNoCafRefs,
     Strictness: <L,U(A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,C(U),A,A,A,A,A)><S,1*U>,
     Unfolding: InlineRule (0, True, True)
                Tensor.Restricted.$fFloatingTensor12 -}
c597b80271b7834390e27f13cb520dc7
  $fFloatingTensor_$casin ::
    GHC.Float.Floating a =>
    Tensor.Restricted.Tensor a -> Tensor.Restricted.Tensor a
  {- Arity: 2, HasNoCafRefs,
     Strictness: <L,U(A,A,A,A,A,A,A,A,A,A,C(U),A,A,A,A,A,A,A,A,A,A,A,A)><S,1*U>,
     Unfolding: InlineRule (0, True, True)
                Tensor.Restricted.$fFloatingTensor20 -}
c597b80271b7834390e27f13cb520dc7
  $fFloatingTensor_$casinh ::
    GHC.Float.Floating a =>
    Tensor.Restricted.Tensor a -> Tensor.Restricted.Tensor a
  {- Arity: 2, HasNoCafRefs,
     Strictness: <L,U(A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,C(U),A,A,A,A,A,A)><S,1*U>,
     Unfolding: InlineRule (0, True, True)
                Tensor.Restricted.$fFloatingTensor13 -}
c597b80271b7834390e27f13cb520dc7
  $fFloatingTensor_$catan ::
    GHC.Float.Floating a =>
    Tensor.Restricted.Tensor a -> Tensor.Restricted.Tensor a
  {- Arity: 2, HasNoCafRefs,
     Strictness: <L,U(A,A,A,A,A,A,A,A,A,A,A,A,C(U),A,A,A,A,A,A,A,A,A,A)><S,1*U>,
     Unfolding: InlineRule (0, True, True)
                Tensor.Restricted.$fFloatingTensor18 -}
c597b80271b7834390e27f13cb520dc7
  $fFloatingTensor_$catanh ::
    GHC.Float.Floating a =>
    Tensor.Restricted.Tensor a -> Tensor.Restricted.Tensor a
  {- Arity: 2, HasNoCafRefs,
     Strictness: <L,U(A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,C(U),A,A,A,A)><S,1*U>,
     Unfolding: InlineRule (0, True, True)
                Tensor.Restricted.$fFloatingTensor11 -}
c597b80271b7834390e27f13cb520dc7
  $fFloatingTensor_$ccos ::
    GHC.Float.Floating a =>
    Tensor.Restricted.Tensor a -> Tensor.Restricted.Tensor a
  {- Arity: 2, HasNoCafRefs,
     Strictness: <L,U(A,A,A,A,A,A,A,A,C(U),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><S,1*U>,
     Unfolding: InlineRule (0, True, True)
                Tensor.Restricted.$fFloatingTensor22 -}
c597b80271b7834390e27f13cb520dc7
  $fFloatingTensor_$ccosh ::
    GHC.Float.Floating a =>
    Tensor.Restricted.Tensor a -> Tensor.Restricted.Tensor a
  {- Arity: 2, HasNoCafRefs,
     Strictness: <L,U(A,A,A,A,A,A,A,A,A,A,A,A,A,A,C(U),A,A,A,A,A,A,A,A)><S,1*U>,
     Unfolding: InlineRule (0, True, True)
                Tensor.Restricted.$fFloatingTensor15 -}
c597b80271b7834390e27f13cb520dc7
  $fFloatingTensor_$cexp ::
    GHC.Float.Floating a =>
    Tensor.Restricted.Tensor a -> Tensor.Restricted.Tensor a
  {- Arity: 2, HasNoCafRefs,
     Strictness: <L,U(A,A,C(U),A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A)><S,1*U>,
     Unfolding: InlineRule (0, True, True)
                Tensor.Restricted.$fFloatingTensor2 -}
c597b80271b7834390e27f13cb520dc7
  $fFloatingTensor_$cexpm1 ::
    GHC.Float.Floating a =>
    Tensor.Restricted.Tensor a -> Tensor.Restricted.Tensor a
  {- Arity: 2,
     Strictness: <S(SLLLLLLLLLLLLLLLLLLLLLL),U(1*U,A,C(U),A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A)><S,1*U>,
     Unfolding: InlineRule (0, True, True)
                Tensor.Restricted.$fFloatingTensor10 -}
c597b80271b7834390e27f13cb520dc7
  $fFloatingTensor_$clog ::
    GHC.Float.Floating a =>
    Tensor.Restricted.Tensor a -> Tensor.Restricted.Tensor a
  {- Arity: 2, HasNoCafRefs,
     Strictness: <L,U(A,A,A,C(U),A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A)><S,1*U>,
     Unfolding: InlineRule (0, True, True)
                Tensor.Restricted.$fFloatingTensor6 -}
c597b80271b7834390e27f13cb520dc7
  $fFloatingTensor_$clog1mexp ::
    GHC.Float.Floating a =>
    Tensor.Restricted.Tensor a -> Tensor.Restricted.Tensor a
  {- Arity: 2,
     Strictness: <S(S(S(LLLLLLC(S))LLL)LLLLLLLLLLLLLLLLLLLLLL),U(U(U(U,U,U,U,U,U,U),U,U,U),A,C(U),C(U),A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A)><S,1*U>,
     Unfolding: InlineRule (0, True, True)
                Tensor.Restricted.$fFloatingTensor1 -}
c597b80271b7834390e27f13cb520dc7
  $fFloatingTensor_$clog1p ::
    GHC.Float.Floating a =>
    Tensor.Restricted.Tensor a -> Tensor.Restricted.Tensor a
  {- Arity: 2,
     Strictness: <S(SLLLLLLLLLLLLLLLLLLLLLL),U(1*U,A,A,C(U),A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A)><S,1*U>,
     Unfolding: InlineRule (0, True, True)
                Tensor.Restricted.$fFloatingTensor4 -}
c597b80271b7834390e27f13cb520dc7
  $fFloatingTensor_$clog1pexp ::
    GHC.Float.Floating a =>
    Tensor.Restricted.Tensor a -> Tensor.Restricted.Tensor a
  {- Arity: 2,
     Strictness: <S(SLLLLLLLLLLLLLLLLLLLLLL),U(U,A,C(U),C(U),A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A)><S,1*U>,
     Unfolding: InlineRule (0, True, True)
                Tensor.Restricted.$fFloatingTensor9 -}
c597b80271b7834390e27f13cb520dc7
  $fFloatingTensor_$clogBase ::
    GHC.Float.Floating a =>
    Tensor.Restricted.Tensor a
    -> Tensor.Restricted.Tensor a -> Tensor.Restricted.Tensor a
  {- Arity: 3,
     Strictness: <L,U(1*U(A,C(U),A,A),A,A,C(U),A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A)><S,1*U><S,1*U>,
     Unfolding: InlineRule (0, True, True)
                Tensor.Restricted.$fFloatingTensor24 -}
c597b80271b7834390e27f13cb520dc7
  $fFloatingTensor_$csin ::
    GHC.Float.Floating a =>
    Tensor.Restricted.Tensor a -> Tensor.Restricted.Tensor a
  {- Arity: 2, HasNoCafRefs,
     Strictness: <L,U(A,A,A,A,A,A,A,C(U),A,A,A,A,A,A,A,A,A,A,A,A,A,A,A)><S,1*U>,
     Unfolding: InlineRule (0, True, True)
                Tensor.Restricted.$fFloatingTensor23 -}
c597b80271b7834390e27f13cb520dc7
  $fFloatingTensor_$csinh ::
    GHC.Float.Floating a =>
    Tensor.Restricted.Tensor a -> Tensor.Restricted.Tensor a
  {- Arity: 2, HasNoCafRefs,
     Strictness: <L,U(A,A,A,A,A,A,A,A,A,A,A,A,A,C(U),A,A,A,A,A,A,A,A,A)><S,1*U>,
     Unfolding: InlineRule (0, True, True)
                Tensor.Restricted.$fFloatingTensor16 -}
c597b80271b7834390e27f13cb520dc7
  $fFloatingTensor_$csqrt ::
    GHC.Float.Floating a =>
    Tensor.Restricted.Tensor a -> Tensor.Restricted.Tensor a
  {- Arity: 2,
     Strictness: <S(S(LLLC(S))LLLLLLLLLLLLLLLLLLLLLL),U(U(U(C(U),A,C(U),A,A,A,C(U)),A,A,1*C1(U)),A,C(U),C(U),A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A)><S,1*U>,
     Unfolding: InlineRule (0, True, True)
                Tensor.Restricted.$fFloatingTensor28 -}
c597b80271b7834390e27f13cb520dc7
  $fFloatingTensor_$ctan ::
    GHC.Float.Floating a =>
    Tensor.Restricted.Tensor a -> Tensor.Restricted.Tensor a
  {- Arity: 2,
     Strictness: <L,U(1*U(A,C(U),A,A),A,A,A,A,A,A,C(U),C(U),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><S,U>,
     Unfolding: InlineRule (0, True, True)
                Tensor.Restricted.$fFloatingTensor21 -}
c597b80271b7834390e27f13cb520dc7
  $fFloatingTensor_$ctanh ::
    GHC.Float.Floating a =>
    Tensor.Restricted.Tensor a -> Tensor.Restricted.Tensor a
  {- Arity: 2,
     Strictness: <L,U(1*U(A,C(U),A,A),A,A,A,A,A,A,A,A,A,A,A,A,C(U),C(U),A,A,A,A,A,A,A,A)><S,U>,
     Unfolding: InlineRule (0, True, True)
                Tensor.Restricted.$fFloatingTensor14 -}
c597b80271b7834390e27f13cb520dc7
  $fFractionalTensor ::
    GHC.Real.Fractional a =>
    GHC.Real.Fractional (Tensor.Restricted.Tensor a)
  DFunId
  {- Arity: 1,
     Strictness: <L,U(U(C(U),C(C1(U)),C(U),A,C(U),C(U),C(U)),C(U),A,C(U))>m,
     Unfolding: DFun: @ a ($dFractional :: GHC.Real.Fractional a).
                  @ (Tensor.Restricted.Tensor a)
                  (Tensor.Restricted.$fFractionalTensor3 @ a $dFractional)
                  (Tensor.Restricted.$fFractionalTensor_$c/ @ a $dFractional)
                  (Tensor.Restricted.$fFractionalTensor_$crecip @ a $dFractional)
                  (Tensor.Restricted.$fFractionalTensor1 @ a $dFractional) -}
c597b80271b7834390e27f13cb520dc7
  $fFractionalTensor1 ::
    GHC.Real.Fractional a =>
    GHC.Real.Rational -> Tensor.Restricted.Tensor a
  {- Arity: 2, HasNoCafRefs,
     Strictness: <S(LLLC(S)),1*U(A,A,A,1*C1(U))><S(SS),1*U(U,U)>m1,
     Unfolding: InlineRule (2, True, False)
                (\ @ a
                   ($dFractional :: GHC.Real.Fractional a)
                   (x1 :: GHC.Real.Rational) ->
                 case x1 of x2 { GHC.Real.:% ipv ipv1 ->
                 case GHC.Real.fromRational @ a $dFractional x2 of dt1 { DEFAULT ->
                 Tensor.Restricted.Scalar @ a dt1 } }) -}
c597b80271b7834390e27f13cb520dc7
  $fFractionalTensor2 ::
    GHC.Real.Fractional a =>
    Tensor.Restricted.Tensor a -> Tensor.Restricted.Tensor a
  {- Arity: 2,
     Strictness: <S(S(LLLLLLC(S))LLL),U(1*U(A,A,A,A,A,A,1*C1(U)),C(U),A,A)><S,1*U>,
     Unfolding: (\ @ a
                   ($dFractional :: GHC.Real.Fractional a)
                   (eta :: Tensor.Restricted.Tensor a) ->
                 case GHC.Num.fromInteger
                        @ a
                        (GHC.Real.$p1Fractional @ a $dFractional)
                        Tensor.Restricted.$fFloatingTensor7 of dt1 { DEFAULT ->
                 Tensor.Restricted.$fFloatingTensor17
                   @ a
                   $dFractional
                   (Tensor.Restricted.Scalar @ a dt1)
                   eta }) -}
c597b80271b7834390e27f13cb520dc7
  $fFractionalTensor3 ::
    GHC.Real.Fractional a => GHC.Num.Num (Tensor.Restricted.Tensor a)
  {- Arity: 1,
     Strictness: <L,1*U(1*U(C(U),C(C1(U)),C(U),A,C(U),C(U),C(U)),A,A,A)>m,
     Unfolding: InlineRule (1, True, False)
                (\ @ a ($dFractional :: GHC.Real.Fractional a) ->
                 Tensor.Restricted.$fNumTensor
                   @ a
                   (GHC.Real.$p1Fractional @ a $dFractional)) -}
c597b80271b7834390e27f13cb520dc7
  $fFractionalTensor_$c/ ::
    GHC.Real.Fractional a =>
    Tensor.Restricted.Tensor a
    -> Tensor.Restricted.Tensor a -> Tensor.Restricted.Tensor a
  {- Arity: 3, Strictness: <L,U(A,C(U),A,A)><S,1*U><S,1*U>,
     Unfolding: InlineRule (0, True, True)
                Tensor.Restricted.$fFloatingTensor17 -}
c597b80271b7834390e27f13cb520dc7
  $fFractionalTensor_$crecip ::
    GHC.Real.Fractional a =>
    Tensor.Restricted.Tensor a -> Tensor.Restricted.Tensor a
  {- Arity: 2,
     Strictness: <S(S(LLLLLLC(S))LLL),U(1*U(A,A,A,A,A,A,1*C1(U)),C(U),A,A)><S,1*U>,
     Unfolding: InlineRule (0, True, True)
                Tensor.Restricted.$fFractionalTensor2 -}
c597b80271b7834390e27f13cb520dc7
  $fFunctorTensor :: GHC.Base.Functor Tensor.Restricted.Tensor
  DFunId
  {- HasNoCafRefs, Strictness: m,
     Unfolding: DFun:.
                  @ Tensor.Restricted.Tensor
                  Tensor.Restricted.$fFloatingTensor27
                  Tensor.Restricted.$fFunctorTensor1 -}
c597b80271b7834390e27f13cb520dc7
  $fFunctorTensor1 ::
    a -> Tensor.Restricted.Tensor b -> Tensor.Restricted.Tensor a
  {- Arity: 2, HasNoCafRefs, Strictness: <L,U><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ @ a @ b (eta :: a) (eta1 :: Tensor.Restricted.Tensor b) ->
                 Tensor.Restricted.$fFloatingTensor27
                   @ b
                   @ a
                   (\ (ds2 :: b) -> eta)
                   eta1) -}
c597b80271b7834390e27f13cb520dc7
  $fMultilinearTensor ::
    Tensor.Multilinear.Multilinear Tensor.Restricted.Tensor
  DFunId
  {- Unfolding: DFun:.
                  @ Tensor.Restricted.Tensor
                  Tensor.Restricted.$fFunctorTensor
                  Tensor.Restricted.$fMultilinearTensor_$c!!
                  Tensor.Restricted.$fFloatingTensor26
                  Tensor.Restricted.$fMultilinearTensor_$cgenerate
                  Tensor.Restricted.$fMultilinearTensor_$cfromList
                  Tensor.Restricted.$fMultilinearTensor7
                  Tensor.Restricted.$fMultilinearTensor6
                  Tensor.Restricted.commonIndex1
                  Tensor.Restricted.$fMultilinearTensor5
                  Tensor.Restricted.$fMultilinearTensor4
                  Tensor.Restricted.$fMultilinearTensor3
                  Tensor.Restricted.$fMultilinearTensor2
                  Tensor.Restricted.$fMultilinearTensor_$ctranspose1
                  Tensor.Restricted.$fMultilinearTensor_$cconcat
                  Tensor.Restricted.$fMultilinearTensor1 -}
c597b80271b7834390e27f13cb520dc7
  $fMultilinearTensor1 ::
    Tensor.Index.TIndex
    -> Tensor.Restricted.Tensor a
    -> Tensor.Restricted.Tensor a
    -> Tensor.Restricted.Tensor a
  {- Arity: 3, HasNoCafRefs, Strictness: <S,1*U><S,1*U><S,1*U>,
     Unfolding: InlineRule (0, True, True)
                Tensor.Restricted.$fMultilinearTensor_$cconcat -}
c597b80271b7834390e27f13cb520dc7
  $fMultilinearTensor10 :: Tensor.Restricted.Tensor a
  {- Unfolding: (\ @ a ->
                 case GHC.CString.unpackAppendCString#
                        "(!): "#
                        Tensor.Restricted.indexOutOfRange of dt1 { DEFAULT ->
                 Tensor.Restricted.Err @ a dt1 }) -}
c597b80271b7834390e27f13cb520dc7
  $fMultilinearTensor2 ::
    Tensor.Restricted.Tensor a -> Tensor.Restricted.Tensor a
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U> -}
c597b80271b7834390e27f13cb520dc7
  $fMultilinearTensor3 ::
    Tensor.Restricted.Tensor a
    -> Tensor.Restricted.Tensor a -> GHC.Types.Bool
  {- Arity: 2, Strictness: <S,1*U><S,1*U>,
     Unfolding: InlineRule (0, True, True)
                Tensor.Restricted.$fMultilinearTensor_$s$dm!==! -}
c597b80271b7834390e27f13cb520dc7
  $fMultilinearTensor4 ::
    Tensor.Restricted.Tensor a
    -> Tensor.Restricted.Tensor a -> GHC.Types.Bool
  {- Arity: 2, Strictness: <S,1*U><S,1*U>,
     Unfolding: (\ @ a
                   (t1 :: Tensor.Restricted.Tensor a)
                   (t2 :: Tensor.Restricted.Tensor a) ->
                 case t2 of t4 { DEFAULT ->
                 (Tensor.Restricted.$fMultilinearTensor_go
                    (Tensor.Restricted.commonIndex1 @ a t1)
                    (Tensor.Restricted.commonIndex1 @ a t4))
                   `cast`
                 (Data.Monoid.N:All[0]) }) -}
c597b80271b7834390e27f13cb520dc7
  $fMultilinearTensor5 ::
    Tensor.Restricted.Tensor a
    -> GHC.Base.String -> GHC.Base.String -> Tensor.Restricted.Tensor a
  {- Arity: 3, HasNoCafRefs, Strictness: <S,1*U><S,1*U><S,1*U> -}
c597b80271b7834390e27f13cb520dc7
  $fMultilinearTensor6 :: Tensor.Restricted.Tensor a -> GHC.Types.Int
  {- Arity: 1, Strictness: <S,1*U>m, Inline: INLINE[0],
     Unfolding: InlineRule (1, True, False)
                (\ @ a (w :: Tensor.Restricted.Tensor a) ->
                 case Tensor.Restricted.$wds @ a w of ww { DEFAULT ->
                 GHC.Types.I# ww }) -}
c597b80271b7834390e27f13cb520dc7
  $fMultilinearTensor7 ::
    Tensor.Restricted.Tensor a -> (GHC.Types.Int, GHC.Types.Int)
  {- Arity: 1, Strictness: <S,1*U>m, Inline: INLINE[0],
     Unfolding: InlineRule (1, True, False)
                (\ @ a (w :: Tensor.Restricted.Tensor a) ->
                 case Tensor.Restricted.$wds1 @ a w of ww { (#,#) ww1 ww2 ->
                 (ww1, ww2) }) -}
c597b80271b7834390e27f13cb520dc7
  $fMultilinearTensor8 :: Tensor.Restricted.Tensor a
  {- Strictness: m3,
     Unfolding: (\ @ a ->
                 Tensor.Restricted.Err
                   @ a
                   Tensor.Restricted.$fMultilinearTensor9) -}
54728c8076abe53a3ce2588fa4f7234b
  $fMultilinearTensor9 :: GHC.Base.String
  {- Unfolding: (GHC.CString.unpackCString#
                   "generate: Tensor must contain at leat one element!"#) -}
c597b80271b7834390e27f13cb520dc7
  $fMultilinearTensor_$c!! ::
    Tensor.Restricted.Tensor a
    -> GHC.Types.Int -> Tensor.Restricted.Tensor a
  {- Arity: 2, Strictness: <S,1*U><S,1*U(U)>, Inline: INLINE[0],
     Unfolding: InlineRule (2, True, False)
                (\ @ a (w :: Tensor.Restricted.Tensor a) (w1 :: GHC.Types.Int) ->
                 case w1 of ww { GHC.Types.I# ww1 ->
                 Tensor.Restricted.$w$c!! @ a w ww1 }) -}
c597b80271b7834390e27f13cb520dc7
  $fMultilinearTensor_$cconcat ::
    Tensor.Index.TIndex
    -> Tensor.Restricted.Tensor a
    -> Tensor.Restricted.Tensor a
    -> Tensor.Restricted.Tensor a
  {- Arity: 3, HasNoCafRefs, Strictness: <S,1*U><S,1*U><S,1*U>,
     Unfolding: InlineRule (3, True, False)
                (\ @ a
                   (ds2 :: Tensor.Index.TIndex)
                   (t1 :: Tensor.Restricted.Tensor a)
                   (ds3 :: Tensor.Restricted.Tensor a) ->
                 case ds2 of ds4 { DEFAULT ->
                 case t1 of t2 { DEFAULT ->
                 case ds3 of ds5 { DEFAULT -> t2 } } }) -}
c597b80271b7834390e27f13cb520dc7
  $fMultilinearTensor_$cfromList ::
    Tensor.Index.TIndex -> [a] -> Tensor.Restricted.Tensor a
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>m2,
     Inline: INLINE[0],
     Unfolding: InlineRule (2, True, False)
                (\ @ a (w :: Tensor.Index.TIndex) (w1 :: [a]) ->
                 case Tensor.Restricted.$w$cfromList
                        @ a
                        w
                        w1 of ww { (#,#) ww1 ww2 ->
                 Tensor.Restricted.Tensor @ a ww1 ww2 }) -}
c597b80271b7834390e27f13cb520dc7
  $fMultilinearTensor_$cgenerate ::
    Tensor.Index.TIndex
    -> (GHC.Types.Int -> Tensor.Restricted.Tensor a)
    -> Tensor.Restricted.Tensor a
  {- Arity: 2, Strictness: <S,1*U><S,1*U>,
     Unfolding: (\ @ a
                   (index :: Tensor.Index.TIndex)
                   (f :: GHC.Types.Int -> Tensor.Restricted.Tensor a) ->
                 case f of f1 { DEFAULT ->
                 let {
                   $j :: GHC.Prim.Void# -> Tensor.Restricted.Tensor a
                     {- Arity: 1, Strictness: <L,A> -}
                   = \ (w :: GHC.Prim.Void#)[OneShot] ->
                     let {
                       $j1 :: GHC.Prim.Int# -> [Tensor.Restricted.Tensor a]
                         {- Arity: 1, Strictness: <S,U> -}
                       = \ (x1 :: GHC.Prim.Int#)[OneShot] ->
                         let {
                           y :: GHC.Prim.Int# = GHC.Prim.-# x1 1#
                         } in
                         case GHC.Prim.tagToEnum#
                                @ GHC.Types.Bool
                                (GHC.Prim.># 0# y) of wild {
                           GHC.Types.False
                           -> letrec {
                                go2 :: GHC.Prim.Int# -> [Tensor.Restricted.Tensor a]
                                  {- Arity: 1, Strictness: <L,U> -}
                                = \ (x2 :: GHC.Prim.Int#) ->
                                  GHC.Types.:
                                    @ (Tensor.Restricted.Tensor a)
                                    (f1 (GHC.Types.I# x2))
                                    (case GHC.Prim.tagToEnum#
                                            @ GHC.Types.Bool
                                            (GHC.Prim.==# x2 y) of wild1 {
                                       GHC.Types.False -> go2 (GHC.Prim.+# x2 1#)
                                       GHC.Types.True
                                       -> GHC.Types.[] @ (Tensor.Restricted.Tensor a) })
                              } in
                              go2 0#
                           GHC.Types.True -> GHC.Types.[] @ (Tensor.Restricted.Tensor a) }
                     } in
                     case case index of wild {
                            Tensor.Index.Covariant dt1 ds2 -> $j1 dt1
                            Tensor.Index.Contravariant dt1 ds2 -> $j1 dt1
                            Tensor.Index.Indifferent dt1 ds2 -> $j1 dt1 } of dt1 { DEFAULT ->
                     Tensor.Restricted.Tensor @ a index dt1 }
                 } in
                 case index of wild {
                   Tensor.Index.Covariant dt1 ds2
                   -> case GHC.Prim.tagToEnum#
                             @ GHC.Types.Bool
                             (GHC.Prim.># dt1 0#) of wild1 {
                        GHC.Types.False -> Tensor.Restricted.$fMultilinearTensor8 @ a
                        GHC.Types.True -> $j GHC.Prim.void# }
                   Tensor.Index.Contravariant dt1 ds2
                   -> case GHC.Prim.tagToEnum#
                             @ GHC.Types.Bool
                             (GHC.Prim.># dt1 0#) of wild1 {
                        GHC.Types.False -> Tensor.Restricted.$fMultilinearTensor8 @ a
                        GHC.Types.True -> $j GHC.Prim.void# }
                   Tensor.Index.Indifferent dt1 ds2
                   -> case GHC.Prim.tagToEnum#
                             @ GHC.Types.Bool
                             (GHC.Prim.># dt1 0#) of wild1 {
                        GHC.Types.False -> Tensor.Restricted.$fMultilinearTensor8 @ a
                        GHC.Types.True -> $j GHC.Prim.void# } } }) -}
c597b80271b7834390e27f13cb520dc7
  $fMultilinearTensor_$ctranspose1 ::
    Tensor.Restricted.Tensor a -> Tensor.Restricted.Tensor a
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U>,
     Unfolding: (\ @ a (ds2 :: Tensor.Restricted.Tensor a) ->
                 case ds2 of wild {
                   DEFAULT -> wild
                   Tensor.Restricted.Tensor ds3 ts
                   -> case ds3 of wild1 {
                        Tensor.Index.Covariant dt1 name
                        -> Tensor.Restricted.Tensor
                             @ a
                             (Tensor.Index.Contravariant dt1 name)
                             ts
                        Tensor.Index.Contravariant dt1 name
                        -> Tensor.Restricted.Tensor
                             @ a
                             (Tensor.Index.Covariant dt1 name)
                             ts
                        Tensor.Index.Indifferent dt1 name -> wild } }) -}
c597b80271b7834390e27f13cb520dc7
  $fMultilinearTensor_$s$dm!==! ::
    Tensor.Restricted.Tensor a
    -> Tensor.Restricted.Tensor a -> GHC.Types.Bool
  {- Arity: 2, Strictness: <S,1*U><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ @ a
                   (t1 :: Tensor.Restricted.Tensor a)
                   (t2 :: Tensor.Restricted.Tensor a) ->
                 case t1 of t4 { DEFAULT ->
                 case t2 of t5 { DEFAULT ->
                 Tensor.Restricted.$fMultilinearTensor4 @ a t4 t5 } }) -}
1e2092e52127f38988104732a682cff9
  $fMultilinearTensor_go ::
    [Tensor.Index.TIndex] -> [Tensor.Index.TIndex] -> Data.Monoid.All
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><L,1*U> -}
c597b80271b7834390e27f13cb520dc7
  $fNumTensor ::
    GHC.Num.Num a => GHC.Num.Num (Tensor.Restricted.Tensor a)
  DFunId
  {- Arity: 1,
     Strictness: <L,U(C(U),C(C1(U)),C(U),A,C(U),C(U),C(U))>m,
     Unfolding: DFun: @ a ($dNum :: GHC.Num.Num a).
                  @ (Tensor.Restricted.Tensor a)
                  (Tensor.Restricted.$fNumTensor_$c+ @ a $dNum)
                  (Tensor.Restricted.$fNumTensor_$c- @ a $dNum)
                  (Tensor.Restricted.$fFloatingTensor26 @ a $dNum)
                  (Tensor.Restricted.$fNumTensor_$cnegate @ a $dNum)
                  (Tensor.Restricted.$fNumTensor_$cabs @ a $dNum)
                  (Tensor.Restricted.$fNumTensor_$csignum @ a $dNum)
                  (Tensor.Restricted.$fNumTensor1 @ a $dNum) -}
c597b80271b7834390e27f13cb520dc7
  $fNumTensor1 ::
    GHC.Num.Num a =>
    GHC.Integer.Type.Integer -> Tensor.Restricted.Tensor a
  {- Arity: 2, HasNoCafRefs,
     Strictness: <S(LLLLLLC(S)),1*U(A,A,A,A,A,A,1*C1(U))><S,1*U>m1,
     Unfolding: InlineRule (2, True, False)
                (\ @ a ($dNum :: GHC.Num.Num a) (x1 :: GHC.Integer.Type.Integer) ->
                 case x1 of x2 { DEFAULT ->
                 case GHC.Num.fromInteger @ a $dNum x2 of dt1 { DEFAULT ->
                 Tensor.Restricted.Scalar @ a dt1 } }) -}
c597b80271b7834390e27f13cb520dc7
  $fNumTensor2 ::
    GHC.Num.Num a =>
    Tensor.Restricted.Tensor a -> Tensor.Restricted.Tensor a
  {- Arity: 2, HasNoCafRefs,
     Strictness: <L,U(A,A,A,A,A,C(U),A)><S,1*U> -}
c597b80271b7834390e27f13cb520dc7
  $fNumTensor3 ::
    GHC.Num.Num a =>
    Tensor.Restricted.Tensor a -> Tensor.Restricted.Tensor a
  {- Arity: 2, HasNoCafRefs,
     Strictness: <L,U(A,A,A,A,C(U),A,A)><S,1*U> -}
c597b80271b7834390e27f13cb520dc7
  $fNumTensor4 ::
    GHC.Num.Num a =>
    Tensor.Restricted.Tensor a -> Tensor.Restricted.Tensor a
  {- Arity: 2,
     Strictness: <S(LLLLLLC(S)),U(A,C(C1(U)),A,A,A,A,1*C1(U))><S,1*U>,
     Unfolding: (\ @ a
                   ($dNum :: GHC.Num.Num a)
                   (eta :: Tensor.Restricted.Tensor a) ->
                 case GHC.Num.fromInteger
                        @ a
                        $dNum
                        Tensor.Restricted.$fFloatingTensor8 of dt1 { DEFAULT ->
                 Tensor.Restricted.$fFloatingTensor3
                   @ a
                   $dNum
                   (Tensor.Restricted.Scalar @ a dt1)
                   eta }) -}
c597b80271b7834390e27f13cb520dc7
  $fNumTensor_$c+ ::
    GHC.Num.Num a =>
    Tensor.Restricted.Tensor a
    -> Tensor.Restricted.Tensor a -> Tensor.Restricted.Tensor a
  {- Arity: 3, Strictness: <L,U(C(U),A,A,A,A,A,A)><S,1*U><S,1*U>,
     Unfolding: InlineRule (0, True, True)
                Tensor.Restricted.$fFloatingTensor5 -}
c597b80271b7834390e27f13cb520dc7
  $fNumTensor_$c- ::
    GHC.Num.Num a =>
    Tensor.Restricted.Tensor a
    -> Tensor.Restricted.Tensor a -> Tensor.Restricted.Tensor a
  {- Arity: 3, Strictness: <L,U(A,C(C1(U)),A,A,A,A,A)><S,1*U><S,1*U>,
     Unfolding: InlineRule (0, True, True)
                Tensor.Restricted.$fFloatingTensor3 -}
c597b80271b7834390e27f13cb520dc7
  $fNumTensor_$cabs ::
    GHC.Num.Num a =>
    Tensor.Restricted.Tensor a -> Tensor.Restricted.Tensor a
  {- Arity: 2, HasNoCafRefs,
     Strictness: <L,U(A,A,A,A,C(U),A,A)><S,1*U>,
     Unfolding: InlineRule (0, True, True)
                Tensor.Restricted.$fNumTensor3 -}
c597b80271b7834390e27f13cb520dc7
  $fNumTensor_$cnegate ::
    GHC.Num.Num a =>
    Tensor.Restricted.Tensor a -> Tensor.Restricted.Tensor a
  {- Arity: 2,
     Strictness: <S(LLLLLLC(S)),U(A,C(C1(U)),A,A,A,A,1*C1(U))><S,1*U>,
     Unfolding: InlineRule (0, True, True)
                Tensor.Restricted.$fNumTensor4 -}
c597b80271b7834390e27f13cb520dc7
  $fNumTensor_$csignum ::
    GHC.Num.Num a =>
    Tensor.Restricted.Tensor a -> Tensor.Restricted.Tensor a
  {- Arity: 2, HasNoCafRefs,
     Strictness: <L,U(A,A,A,A,A,C(U),A)><S,1*U>,
     Unfolding: InlineRule (0, True, True)
                Tensor.Restricted.$fNumTensor2 -}
c597b80271b7834390e27f13cb520dc7
  $fShowTensor ::
    GHC.Show.Show a => GHC.Show.Show (Tensor.Restricted.Tensor a)
  DFunId
  {- Arity: 1, Strictness: <L,U(A,C(U),A)>m,
     Unfolding: DFun: @ a ($dShow :: GHC.Show.Show a).
                  @ (Tensor.Restricted.Tensor a)
                  (Tensor.Restricted.$fShowTensor_$cshowsPrec @ a $dShow)
                  (Tensor.Restricted.$fShowTensor_$cshow @ a $dShow)
                  (Tensor.Restricted.$fShowTensor_$cshowList @ a $dShow) -}
c597b80271b7834390e27f13cb520dc7
  $fShowTensor1 ::
    GHC.Show.Show a => [Tensor.Restricted.Tensor a] -> GHC.Show.ShowS
  {- Arity: 3, Strictness: <L,U(A,C(U),A)><S,1*U><L,U>,
     Unfolding: (\ @ a
                   ($dShow :: GHC.Show.Show a)
                   (ls :: [Tensor.Restricted.Tensor a])
                   (s :: GHC.Base.String) ->
                 GHC.Show.showList__
                   @ (Tensor.Restricted.Tensor a)
                   (\ (x1 :: Tensor.Restricted.Tensor a)
                      (s1 :: GHC.Base.String)[OneShot] ->
                    GHC.Base.++
                      @ GHC.Types.Char
                      (Tensor.Restricted.$fShowTensor2 @ a $dShow x1)
                      s1)
                   ls
                   s) -}
c597b80271b7834390e27f13cb520dc7
  $fShowTensor2 ::
    GHC.Show.Show a => Tensor.Restricted.Tensor a -> GHC.Base.String
  {- Arity: 2, Strictness: <L,U(A,C(U),A)><S,1*U> -}
c597b80271b7834390e27f13cb520dc7
  $fShowTensor3 ::
    GHC.Show.Show a =>
    GHC.Types.Int -> Tensor.Restricted.Tensor a -> GHC.Show.ShowS
  {- Arity: 4, Strictness: <L,U(A,C(U),A)><L,A><S,1*U><L,1*U>,
     Unfolding: InlineRule (4, True, False)
                (\ @ a
                   ($dShow :: GHC.Show.Show a)
                   (ds2 :: GHC.Types.Int)
                   (x1 :: Tensor.Restricted.Tensor a)
                   (s :: GHC.Base.String) ->
                 GHC.Base.augment
                   @ GHC.Types.Char
                   (\ @ b
                      (c :: GHC.Types.Char -> b -> b)[OneShot]
                      (n :: b)[OneShot] ->
                    GHC.Base.foldr
                      @ GHC.Types.Char
                      @ b
                      c
                      n
                      (Tensor.Restricted.$fShowTensor2 @ a $dShow x1))
                   s) -}
c597b80271b7834390e27f13cb520dc7
  $fShowTensor_$cshow ::
    GHC.Show.Show a => Tensor.Restricted.Tensor a -> GHC.Base.String
  {- Arity: 2, Strictness: <L,U(A,C(U),A)><S,1*U>,
     Unfolding: InlineRule (0, True, True)
                Tensor.Restricted.$fShowTensor2 -}
c597b80271b7834390e27f13cb520dc7
  $fShowTensor_$cshowList ::
    GHC.Show.Show a => [Tensor.Restricted.Tensor a] -> GHC.Show.ShowS
  {- Arity: 3, Strictness: <L,U(A,C(U),A)><S,1*U><L,U>,
     Unfolding: InlineRule (0, True, True)
                Tensor.Restricted.$fShowTensor1 -}
c597b80271b7834390e27f13cb520dc7
  $fShowTensor_$cshowsPrec ::
    GHC.Show.Show a =>
    GHC.Types.Int -> Tensor.Restricted.Tensor a -> GHC.Show.ShowS
  {- Arity: 4, Strictness: <L,U(A,C(U),A)><L,A><S,1*U><L,1*U>,
     Unfolding: InlineRule (0, True, True)
                Tensor.Restricted.$fShowTensor3 -}
dd5264b1a422e484fd3544fcee86eb17
  $tc'Err :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   14620445095352618430##
                   5153873293450290643##
                   Tensor.Restricted.$trModule
                   Tensor.Restricted.$tc'Err1) -}
2d764f9eceb86e1e22d82febb748af6b
  $tc'Err1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "'Err"#) -}
8b5c15c6b3dd4fada780d51a62a99d13
  $tc'Scalar :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   9134389122760797083##
                   5061336188621068390##
                   Tensor.Restricted.$trModule
                   Tensor.Restricted.$tc'Scalar1) -}
2818345ee67962146c3c8758e5204484
  $tc'Scalar1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "'Scalar"#) -}
de0095075127f327e831661e7c110030
  $tc'Tensor :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   6168677740314203370##
                   8492074014140338535##
                   Tensor.Restricted.$trModule
                   Tensor.Restricted.$tc'Tensor1) -}
81ad87d090847d2f27b6c5c0259f49ba
  $tc'Tensor1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "'Tensor"#) -}
e9f8c32d2785fb4e082e0ad50b1dac13
  $tcTensor :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   1317086536029024799##
                   18354611785727425210##
                   Tensor.Restricted.$trModule
                   Tensor.Restricted.$tcTensor1) -}
5a2faca5ad776a8743b568e54760e8c2
  $tcTensor1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "Tensor"#) -}
ecae84a8b7fc3d14f1e06dd5f43b60e4
  $trModule :: GHC.Types.Module
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.Module
                   Tensor.Restricted.$trModule2
                   Tensor.Restricted.$trModule1) -}
89d0ad78ced654c76b4b80779d01cbd7
  $trModule1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "Tensor.Restricted"#) -}
dec717dbe961362a6d4480f7b0528853
  $trModule2 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS
                   "Tensor-0.1.0.0-K5QdifOX00t2w9C27ImRWh"#) -}
c597b80271b7834390e27f13cb520dc7
  $w$c!! ::
    Tensor.Restricted.Tensor a
    -> GHC.Prim.Int# -> Tensor.Restricted.Tensor a
  {- Arity: 2, Strictness: <S,1*U><L,U>, Inline: [0],
     Unfolding: (\ @ a
                   (w :: Tensor.Restricted.Tensor a)
                   (ww :: GHC.Prim.Int#) ->
                 case w of wild {
                   Tensor.Restricted.Scalar ds2
                   -> Tensor.Restricted.$fMultilinearTensor10 @ a
                   Tensor.Restricted.Tensor index1 ts1
                   -> case index1 of wild1 {
                        Tensor.Index.Covariant dt1 ds2
                        -> case GHC.Prim.tagToEnum#
                                  @ GHC.Types.Bool
                                  (GHC.Prim.>=# ww dt1) of wild2 {
                             GHC.Types.False
                             -> GHC.List.$w!! @ (Tensor.Restricted.Tensor a) ts1 ww
                             GHC.Types.True -> Tensor.Restricted.$fMultilinearTensor10 @ a }
                        Tensor.Index.Contravariant dt1 ds2
                        -> case GHC.Prim.tagToEnum#
                                  @ GHC.Types.Bool
                                  (GHC.Prim.>=# ww dt1) of wild2 {
                             GHC.Types.False
                             -> GHC.List.$w!! @ (Tensor.Restricted.Tensor a) ts1 ww
                             GHC.Types.True -> Tensor.Restricted.$fMultilinearTensor10 @ a }
                        Tensor.Index.Indifferent dt1 ds2
                        -> case GHC.Prim.tagToEnum#
                                  @ GHC.Types.Bool
                                  (GHC.Prim.>=# ww dt1) of wild2 {
                             GHC.Types.False
                             -> GHC.List.$w!! @ (Tensor.Restricted.Tensor a) ts1 ww
                             GHC.Types.True -> Tensor.Restricted.$fMultilinearTensor10 @ a } }
                   Tensor.Restricted.Err msg -> wild }) -}
c597b80271b7834390e27f13cb520dc7
  $w$cfromList ::
    Tensor.Index.TIndex
    -> [a] -> (# Tensor.Index.TIndex, [Tensor.Restricted.Tensor a] #)
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>, Inline: [0],
     Unfolding: (\ @ a (w :: Tensor.Index.TIndex) (w1 :: [a]) ->
                 case w of wild {
                   Tensor.Index.Covariant dt1 name
                   -> case GHC.List.$wlenAcc @ a w1 0# of ww2 { DEFAULT ->
                      case GHC.Base.map
                             @ a
                             @ (Tensor.Restricted.Tensor a)
                             (Tensor.Restricted.$WScalar @ a)
                             w1 of dt2 { DEFAULT ->
                      (# Tensor.Index.Covariant ww2 name, dt2 #) } }
                   Tensor.Index.Contravariant dt1 name
                   -> case GHC.List.$wlenAcc @ a w1 0# of ww2 { DEFAULT ->
                      case GHC.Base.map
                             @ a
                             @ (Tensor.Restricted.Tensor a)
                             (Tensor.Restricted.$WScalar @ a)
                             w1 of dt2 { DEFAULT ->
                      (# Tensor.Index.Contravariant ww2 name, dt2 #) } }
                   Tensor.Index.Indifferent dt1 name
                   -> case GHC.List.$wlenAcc @ a w1 0# of ww2 { DEFAULT ->
                      case GHC.Base.map
                             @ a
                             @ (Tensor.Restricted.Tensor a)
                             (Tensor.Restricted.$WScalar @ a)
                             w1 of dt2 { DEFAULT ->
                      (# Tensor.Index.Indifferent ww2 name, dt2 #) } } }) -}
c597b80271b7834390e27f13cb520dc7
  $w$cput ::
    Data.Binary.Class.Binary a =>
    Tensor.Restricted.Tensor a
    -> (# (), Data.ByteString.Builder.Internal.Builder #)
  {- Arity: 2, Strictness: <L,U(C(U(U,U)),U,A)><S,1*U>, Inline: [0],
     Unfolding: (\ @ a
                   (w :: Data.Binary.Class.Binary a)
                   (w1 :: Tensor.Restricted.Tensor a) ->
                 case w1 of wild {
                   Tensor.Restricted.Scalar x1
                   -> let {
                        ds2 :: Data.Binary.Put.Put = Data.Binary.Class.put @ a w x1
                      } in
                      (# case ds2
                                `cast`
                              (Data.Binary.Put.N:PutM[0] <()>_N) of wild1 { Data.Binary.Put.PairS b1 w' ->
                         b1 },
                         (\ @ r (eta :: Data.ByteString.Builder.Internal.BuildStep r) ->
                          let {
                            eta1 :: Data.ByteString.Builder.Internal.BuildStep r
                            = case ds2
                                     `cast`
                                   (Data.Binary.Put.N:PutM[0] <()>_N) of wild1 { Data.Binary.Put.PairS b1 w' ->
                              w' `cast` (Data.ByteString.Builder.Internal.N:Builder[0]) @ r eta }
                          } in
                          let {
                            lvl9 :: Data.ByteString.Builder.Internal.BufferRange
                                    -> GHC.Prim.State# GHC.Prim.RealWorld
                                    -> (# GHC.Prim.State# GHC.Prim.RealWorld,
                                          Data.ByteString.Builder.Internal.BuildSignal r #)
                              {- Arity: 2 -}
                            = \ (ds3 :: Data.ByteString.Builder.Internal.BufferRange)
                                (eta3 :: GHC.Prim.State# GHC.Prim.RealWorld)[OneShot] ->
                              case ds3 of wild3 { Data.ByteString.Builder.Internal.BufferRange dt3 dt4 ->
                              case GHC.Prim.writeWord8OffAddr#
                                     @ GHC.Prim.RealWorld
                                     dt3
                                     0#
                                     0##
                                     eta3 of s2 { DEFAULT ->
                              (eta1
                                 (Data.ByteString.Builder.Internal.BufferRange
                                    (GHC.Prim.plusAddr# dt3 1#)
                                    dt4))
                                `cast`
                              (GHC.Types.N:IO[0]
                                   <Data.ByteString.Builder.Internal.BuildSignal r>_R)
                                s2 } }
                          } in
                          \ (eta2 :: Data.ByteString.Builder.Internal.BufferRange)
                            (eta3 :: GHC.Prim.State# GHC.Prim.RealWorld)[OneShot] ->
                          case eta2 of wild1 { Data.ByteString.Builder.Internal.BufferRange dt1 dt2 ->
                          case GHC.Prim.tagToEnum#
                                 @ GHC.Types.Bool
                                 (GHC.Prim.<# (GHC.Prim.minusAddr# dt2 dt1) 1#) of wild2 {
                            GHC.Types.False
                            -> case GHC.Prim.writeWord8OffAddr#
                                      @ GHC.Prim.RealWorld
                                      dt1
                                      0#
                                      0##
                                      eta3 of s2 { DEFAULT ->
                               (eta1
                                  (Data.ByteString.Builder.Internal.BufferRange
                                     (GHC.Prim.plusAddr# dt1 1#)
                                     dt2))
                                 `cast`
                               (GHC.Types.N:IO[0]
                                    <Data.ByteString.Builder.Internal.BuildSignal r>_R)
                                 s2 }
                            GHC.Types.True
                            -> (# eta3,
                                  Data.ByteString.Builder.Internal.BufferFull
                                    @ r
                                    1#
                                    dt1
                                    lvl9
                                      `cast`
                                    (<Data.ByteString.Builder.Internal.BufferRange>_R
                                     ->_R Sym (GHC.Types.N:IO[0]
                                                   <Data.ByteString.Builder.Internal.BuildSignal
                                                      r>_R)) #) } })
                           `cast`
                         (Trans
                              (forall (r :: <*>_N).
                               <Data.ByteString.Builder.Internal.BuildStep r>_R
                               ->_R <Data.ByteString.Builder.Internal.BufferRange>_R
                               ->_R Sym (GHC.Types.N:IO[0]
                                             <Data.ByteString.Builder.Internal.BuildSignal r>_R))
                              (Sym (Data.ByteString.Builder.Internal.N:Builder[0]))) #)
                   Tensor.Restricted.Tensor ind ts
                   -> let {
                        ds2 :: Data.Binary.Put.Put
                        = Tensor.Restricted.$fBinaryTensor1 @ a w ts
                      } in
                      (# case ds2
                                `cast`
                              (Data.Binary.Put.N:PutM[0] <()>_N) of wild1 { Data.Binary.Put.PairS b1 w' ->
                         b1 },
                         let {
                           ds3 :: Data.ByteString.Builder.Internal.Builder
                           = case Tensor.Index.$w$cput ind of ww { (#,#) ww1 ww2 -> ww2 }
                         } in
                         (\ @ r (eta :: Data.ByteString.Builder.Internal.BuildStep r) ->
                          let {
                            eta1 :: Data.ByteString.Builder.Internal.BuildStep r
                            = ds3 `cast` (Data.ByteString.Builder.Internal.N:Builder[0])
                                @ r
                                (case ds2
                                        `cast`
                                      (Data.Binary.Put.N:PutM[0] <()>_N) of wild1 { Data.Binary.Put.PairS b1 w' ->
                                 w' `cast` (Data.ByteString.Builder.Internal.N:Builder[0])
                                   @ r
                                   eta })
                          } in
                          let {
                            lvl9 :: Data.ByteString.Builder.Internal.BufferRange
                                    -> GHC.Prim.State# GHC.Prim.RealWorld
                                    -> (# GHC.Prim.State# GHC.Prim.RealWorld,
                                          Data.ByteString.Builder.Internal.BuildSignal r #)
                              {- Arity: 2 -}
                            = \ (ds4 :: Data.ByteString.Builder.Internal.BufferRange)
                                (eta3 :: GHC.Prim.State# GHC.Prim.RealWorld)[OneShot] ->
                              case ds4 of wild3 { Data.ByteString.Builder.Internal.BufferRange dt3 dt4 ->
                              case GHC.Prim.writeWord8OffAddr#
                                     @ GHC.Prim.RealWorld
                                     dt3
                                     0#
                                     1##
                                     eta3 of s2 { DEFAULT ->
                              (eta1
                                 (Data.ByteString.Builder.Internal.BufferRange
                                    (GHC.Prim.plusAddr# dt3 1#)
                                    dt4))
                                `cast`
                              (GHC.Types.N:IO[0]
                                   <Data.ByteString.Builder.Internal.BuildSignal r>_R)
                                s2 } }
                          } in
                          \ (eta2 :: Data.ByteString.Builder.Internal.BufferRange)
                            (eta3 :: GHC.Prim.State# GHC.Prim.RealWorld)[OneShot] ->
                          case eta2 of wild1 { Data.ByteString.Builder.Internal.BufferRange dt1 dt2 ->
                          case GHC.Prim.tagToEnum#
                                 @ GHC.Types.Bool
                                 (GHC.Prim.<# (GHC.Prim.minusAddr# dt2 dt1) 1#) of wild2 {
                            GHC.Types.False
                            -> case GHC.Prim.writeWord8OffAddr#
                                      @ GHC.Prim.RealWorld
                                      dt1
                                      0#
                                      1##
                                      eta3 of s2 { DEFAULT ->
                               (eta1
                                  (Data.ByteString.Builder.Internal.BufferRange
                                     (GHC.Prim.plusAddr# dt1 1#)
                                     dt2))
                                 `cast`
                               (GHC.Types.N:IO[0]
                                    <Data.ByteString.Builder.Internal.BuildSignal r>_R)
                                 s2 }
                            GHC.Types.True
                            -> (# eta3,
                                  Data.ByteString.Builder.Internal.BufferFull
                                    @ r
                                    1#
                                    dt1
                                    lvl9
                                      `cast`
                                    (<Data.ByteString.Builder.Internal.BufferRange>_R
                                     ->_R Sym (GHC.Types.N:IO[0]
                                                   <Data.ByteString.Builder.Internal.BuildSignal
                                                      r>_R)) #) } })
                           `cast`
                         (Trans
                              (forall (r :: <*>_N).
                               <Data.ByteString.Builder.Internal.BuildStep r>_R
                               ->_R <Data.ByteString.Builder.Internal.BufferRange>_R
                               ->_R Sym (GHC.Types.N:IO[0]
                                             <Data.ByteString.Builder.Internal.BuildSignal r>_R))
                              (Sym (Data.ByteString.Builder.Internal.N:Builder[0]))) #)
                   Tensor.Restricted.Err msg
                   -> let {
                        ds2 :: Data.Binary.Put.PairS ()
                        = case Data.Binary.Class.$w$cputList msg of ww { (#,#) ww1 ww2 ->
                          Data.Binary.Put.PairS @ () ww1 ww2 }
                      } in
                      (# case ds2 of wild1 { Data.Binary.Put.PairS b1 w' -> b1 },
                         (\ @ r (eta :: Data.ByteString.Builder.Internal.BuildStep r) ->
                          let {
                            eta1 :: Data.ByteString.Builder.Internal.BuildStep r
                            = case ds2 of wild1 { Data.Binary.Put.PairS b1 w' ->
                              w' `cast` (Data.ByteString.Builder.Internal.N:Builder[0]) @ r eta }
                          } in
                          let {
                            lvl9 :: Data.ByteString.Builder.Internal.BufferRange
                                    -> GHC.Prim.State# GHC.Prim.RealWorld
                                    -> (# GHC.Prim.State# GHC.Prim.RealWorld,
                                          Data.ByteString.Builder.Internal.BuildSignal r #)
                              {- Arity: 2 -}
                            = \ (ds3 :: Data.ByteString.Builder.Internal.BufferRange)
                                (eta3 :: GHC.Prim.State# GHC.Prim.RealWorld)[OneShot] ->
                              case ds3 of wild3 { Data.ByteString.Builder.Internal.BufferRange dt3 dt4 ->
                              case GHC.Prim.writeWord8OffAddr#
                                     @ GHC.Prim.RealWorld
                                     dt3
                                     0#
                                     2##
                                     eta3 of s2 { DEFAULT ->
                              (eta1
                                 (Data.ByteString.Builder.Internal.BufferRange
                                    (GHC.Prim.plusAddr# dt3 1#)
                                    dt4))
                                `cast`
                              (GHC.Types.N:IO[0]
                                   <Data.ByteString.Builder.Internal.BuildSignal r>_R)
                                s2 } }
                          } in
                          \ (eta2 :: Data.ByteString.Builder.Internal.BufferRange)
                            (eta3 :: GHC.Prim.State# GHC.Prim.RealWorld)[OneShot] ->
                          case eta2 of wild1 { Data.ByteString.Builder.Internal.BufferRange dt1 dt2 ->
                          case GHC.Prim.tagToEnum#
                                 @ GHC.Types.Bool
                                 (GHC.Prim.<# (GHC.Prim.minusAddr# dt2 dt1) 1#) of wild2 {
                            GHC.Types.False
                            -> case GHC.Prim.writeWord8OffAddr#
                                      @ GHC.Prim.RealWorld
                                      dt1
                                      0#
                                      2##
                                      eta3 of s2 { DEFAULT ->
                               (eta1
                                  (Data.ByteString.Builder.Internal.BufferRange
                                     (GHC.Prim.plusAddr# dt1 1#)
                                     dt2))
                                 `cast`
                               (GHC.Types.N:IO[0]
                                    <Data.ByteString.Builder.Internal.BuildSignal r>_R)
                                 s2 }
                            GHC.Types.True
                            -> (# eta3,
                                  Data.ByteString.Builder.Internal.BufferFull
                                    @ r
                                    1#
                                    dt1
                                    lvl9
                                      `cast`
                                    (<Data.ByteString.Builder.Internal.BufferRange>_R
                                     ->_R Sym (GHC.Types.N:IO[0]
                                                   <Data.ByteString.Builder.Internal.BuildSignal
                                                      r>_R)) #) } })
                           `cast`
                         (Trans
                              (forall (r :: <*>_N).
                               <Data.ByteString.Builder.Internal.BuildStep r>_R
                               ->_R <Data.ByteString.Builder.Internal.BufferRange>_R
                               ->_R Sym (GHC.Types.N:IO[0]
                                             <Data.ByteString.Builder.Internal.BuildSignal r>_R))
                              (Sym (Data.ByteString.Builder.Internal.N:Builder[0]))) #) }) -}
c597b80271b7834390e27f13cb520dc7
  $wds :: Tensor.Restricted.Tensor a -> GHC.Prim.Int#
  {- Arity: 1, Strictness: <S,1*U>, Inline: [0] -}
c597b80271b7834390e27f13cb520dc7
  $wds1 ::
    Tensor.Restricted.Tensor a -> (# GHC.Types.Int, GHC.Types.Int #)
  {- Arity: 1, Strictness: <S,1*U>, Inline: [0] -}
e04cf32ea86e727c74f1c8f7b1463a6e
  $wkr ::
    GHC.Num.Num a => GHC.Prim.Int# -> Tensor.Restricted.Tensor a
  {- Arity: 2, Strictness: <L,U(A,A,A,A,A,A,C(U))><S,U>, Inline: [0],
     Unfolding: (\ @ a (w :: GHC.Num.Num a) (ww :: GHC.Prim.Int#) ->
                 case Tensor.Restricted.kr2 of dt1 { DEFAULT ->
                 let {
                   lvl9 :: Tensor.Index.TIndex
                   = case Tensor.Restricted.kr1 of dt2 { DEFAULT ->
                     Tensor.Index.Covariant ww dt2 }
                 } in
                 let {
                   lvl10 :: a
                   = GHC.Num.fromInteger @ a w Tensor.Restricted.$fFloatingTensor8
                 } in
                 let {
                   lvl11 :: a
                   = GHC.Num.fromInteger @ a w Tensor.Restricted.$fFloatingTensor7
                 } in
                 Tensor.Restricted.$fMultilinearTensor_$cgenerate
                   @ a
                   (Tensor.Index.Covariant ww dt1)
                   (\ (i :: GHC.Types.Int) ->
                    case i of i1 { GHC.Types.I# ipv ->
                    Tensor.Restricted.$fMultilinearTensor_$cgenerate
                      @ a
                      lvl9
                      (\ (j :: GHC.Types.Int) ->
                       case j of j1 { GHC.Types.I# ipv1 ->
                       case case GHC.Prim.tagToEnum#
                                   @ GHC.Types.Bool
                                   (GHC.Prim.==# ipv ipv1) of wild {
                              GHC.Types.False -> lvl10
                              GHC.Types.True -> lvl11 } of dt2 { DEFAULT ->
                       Tensor.Restricted.Scalar @ a dt2 } }) }) }) -}
ea63febefdf591263a68015dd84641ad
  $wkr3 ::
    GHC.Num.Num a => GHC.Prim.Int# -> Tensor.Restricted.Tensor a
  {- Arity: 2, Strictness: <L,U(A,A,A,A,A,A,C(U))><S,U>, Inline: [0],
     Unfolding: (\ @ a (w :: GHC.Num.Num a) (ww :: GHC.Prim.Int#) ->
                 case Tensor.Restricted.kr2 of dt1 { DEFAULT ->
                 let {
                   lvl9 :: Tensor.Index.TIndex
                   = case Tensor.Restricted.kr1 of dt2 { DEFAULT ->
                     Tensor.Index.Covariant ww dt2 }
                 } in
                 let {
                   lvl10 :: Tensor.Index.TIndex
                   = case Tensor.Restricted.kr6 of dt2 { DEFAULT ->
                     Tensor.Index.Covariant ww dt2 }
                 } in
                 let {
                   lvl11 :: a
                   = GHC.Num.fromInteger @ a w Tensor.Restricted.$fFloatingTensor8
                 } in
                 let {
                   lvl12 :: a
                   = GHC.Num.fromInteger @ a w Tensor.Restricted.$fFloatingTensor7
                 } in
                 Tensor.Restricted.$fMultilinearTensor_$cgenerate
                   @ a
                   (Tensor.Index.Covariant ww dt1)
                   (\ (i :: GHC.Types.Int) ->
                    case i of i1 { GHC.Types.I# ipv ->
                    Tensor.Restricted.$fMultilinearTensor_$cgenerate
                      @ a
                      lvl9
                      (\ (j :: GHC.Types.Int) ->
                       case j of j1 { GHC.Types.I# ipv1 ->
                       let {
                         lvl13 :: GHC.Types.Bool
                         = GHC.Prim.tagToEnum# @ GHC.Types.Bool (GHC.Prim.==# ipv ipv1)
                       } in
                       Tensor.Restricted.$fMultilinearTensor_$cgenerate
                         @ a
                         lvl10
                         (\ (k :: GHC.Types.Int) ->
                          case k of k1 { GHC.Types.I# ipv2 ->
                          case case lvl13 of wild {
                                 GHC.Types.False -> lvl11
                                 GHC.Types.True
                                 -> case GHC.Prim.tagToEnum#
                                           @ GHC.Types.Bool
                                           (GHC.Prim.==# ipv1 ipv2) of wild1 {
                                      GHC.Types.False -> lvl11
                                      GHC.Types.True -> lvl12 } } of dt2 { DEFAULT ->
                          Tensor.Restricted.Scalar @ a dt2 } }) }) }) }) -}
4418909ea6de81930ce985b7887a6631
  $wkr4 ::
    GHC.Num.Num a => GHC.Prim.Int# -> Tensor.Restricted.Tensor a
  {- Arity: 2, Strictness: <L,U(A,A,A,A,A,A,C(U))><S,U>, Inline: [0],
     Unfolding: (\ @ a (w :: GHC.Num.Num a) (ww :: GHC.Prim.Int#) ->
                 case Tensor.Restricted.kr2 of dt1 { DEFAULT ->
                 let {
                   lvl9 :: Tensor.Index.TIndex
                   = case Tensor.Restricted.kr1 of dt2 { DEFAULT ->
                     Tensor.Index.Covariant ww dt2 }
                 } in
                 let {
                   lvl10 :: Tensor.Index.TIndex
                   = case Tensor.Restricted.kr6 of dt2 { DEFAULT ->
                     Tensor.Index.Covariant ww dt2 }
                 } in
                 let {
                   lvl11 :: Tensor.Index.TIndex
                   = case Tensor.Restricted.kr7 of dt2 { DEFAULT ->
                     Tensor.Index.Covariant ww dt2 }
                 } in
                 let {
                   lvl12 :: a
                   = GHC.Num.fromInteger @ a w Tensor.Restricted.$fFloatingTensor8
                 } in
                 let {
                   lvl13 :: a
                   = GHC.Num.fromInteger @ a w Tensor.Restricted.$fFloatingTensor7
                 } in
                 Tensor.Restricted.$fMultilinearTensor_$cgenerate
                   @ a
                   (Tensor.Index.Covariant ww dt1)
                   (\ (i :: GHC.Types.Int) ->
                    case i of i1 { GHC.Types.I# ipv ->
                    Tensor.Restricted.$fMultilinearTensor_$cgenerate
                      @ a
                      lvl9
                      (\ (j :: GHC.Types.Int) ->
                       case j of j1 { GHC.Types.I# ipv1 ->
                       let {
                         lvl14 :: GHC.Types.Bool
                         = GHC.Prim.tagToEnum# @ GHC.Types.Bool (GHC.Prim.==# ipv ipv1)
                       } in
                       Tensor.Restricted.$fMultilinearTensor_$cgenerate
                         @ a
                         lvl10
                         (\ (k :: GHC.Types.Int) ->
                          case k of k1 { GHC.Types.I# ipv2 ->
                          let {
                            lvl15 :: GHC.Types.Bool
                            = GHC.Prim.tagToEnum# @ GHC.Types.Bool (GHC.Prim.==# ipv1 ipv2)
                          } in
                          Tensor.Restricted.$fMultilinearTensor_$cgenerate
                            @ a
                            lvl11
                            (\ (l :: GHC.Types.Int) ->
                             case l of l1 { GHC.Types.I# ipv3 ->
                             case case lvl14 of wild {
                                    GHC.Types.False -> lvl12
                                    GHC.Types.True
                                    -> case lvl15 of wild1 {
                                         GHC.Types.False -> lvl12
                                         GHC.Types.True
                                         -> case GHC.Prim.tagToEnum#
                                                   @ GHC.Types.Bool
                                                   (GHC.Prim.==# ipv2 ipv3) of wild2 {
                                              GHC.Types.False -> lvl12
                                              GHC.Types.True -> lvl13 } } } of dt2 { DEFAULT ->
                             Tensor.Restricted.Scalar @ a dt2 } }) }) }) }) }) -}
c597b80271b7834390e27f13cb520dc7
  data Tensor a
    = Scalar {scalarVal :: !a}
    | Tensor {tensorIndex :: !Tensor.Index.TIndex,
              tensorData :: ![Tensor.Restricted.Tensor a]}
    | Err {errMsg :: !GHC.Base.String}
541f35c24eaa3cbba92807174fadfe47
  _dot ::
    GHC.Num.Num a =>
    Tensor.Restricted.Tensor a
    -> Tensor.Restricted.Tensor a -> Tensor.Restricted.Tensor a
  {- Arity: 1, Strictness: <L,U(C(U),A,C(U),A,A,A,C(U))> -}
c597b80271b7834390e27f13cb520dc7
  commonIndex ::
    Tensor.Restricted.Tensor a
    -> Tensor.Restricted.Tensor a -> GHC.Base.Maybe GHC.Base.String
  {- Arity: 2, Strictness: <S,1*U><S,1*U>,
     Unfolding: (\ @ a
                   (t1 :: Tensor.Restricted.Tensor a)
                   (t2 :: Tensor.Restricted.Tensor a) ->
                 case t1 of wild {
                   DEFAULT
                   -> case t2 of t4 { DEFAULT -> GHC.Base.Nothing @ GHC.Base.String }
                   Tensor.Restricted.Tensor ds2 ds3
                   -> case t2 of wild1 {
                        DEFAULT -> GHC.Base.Nothing @ GHC.Base.String
                        Tensor.Restricted.Tensor ds4 ds5
                        -> case GHC.Base.map
                                  @ Tensor.Index.TIndex
                                  @ [GHC.Types.Char]
                                  Tensor.Index.indexName
                                  (Tensor.Restricted.commonIndex1
                                     @ a
                                     wild1) of indicesNames2 { DEFAULT ->
                           case GHC.Base.map
                                  @ Tensor.Index.TIndex
                                  @ [GHC.Types.Char]
                                  Tensor.Index.indexName
                                  (Tensor.Restricted.commonIndex1
                                     @ a
                                     wild) of indicesNames1 { DEFAULT ->
                           letrec {
                             go2 :: [[GHC.Types.Char]] -> GHC.Base.Maybe GHC.Base.String
                               {- Arity: 1, Strictness: <S,1*U> -}
                             = \ (ds6 :: [[GHC.Types.Char]]) ->
                               case ds6 of wild2 {
                                 [] -> GHC.Base.Nothing @ GHC.Base.String
                                 : y ys
                                 -> case y of i { DEFAULT ->
                                    letrec {
                                      go3 :: [GHC.Base.String] -> Data.Monoid.First GHC.Base.String
                                        {- Arity: 1, Strictness: <S,1*U> -}
                                      = \ (ds7 :: [GHC.Base.String]) ->
                                        case ds7 of wild3 {
                                          []
                                          -> (GHC.Base.Nothing @ GHC.Base.String)
                                               `cast`
                                             (Sym (Data.Monoid.N:First[0]) <GHC.Base.String>_N)
                                          : y1 ys1
                                          -> case GHC.Base.eqString y1 i of wild4 {
                                               GHC.Types.False -> go3 ys1
                                               GHC.Types.True
                                               -> (GHC.Base.Just @ GHC.Base.String y1)
                                                    `cast`
                                                  (Sym (Data.Monoid.N:First[0]) <GHC.Base.String>_N) } }
                                    } in
                                    case (go3 indicesNames2)
                                           `cast`
                                         (Data.Monoid.N:First[0] <GHC.Base.String>_N) of wild3 {
                                      GHC.Base.Nothing -> go2 ys GHC.Base.Just ipv -> wild3 } } }
                           } in
                           go2 indicesNames1 } } } }) -}
c597b80271b7834390e27f13cb520dc7
  commonIndex1 :: Tensor.Restricted.Tensor a -> [Tensor.Index.TIndex]
  {- Arity: 1, Strictness: <S,1*U> -}
4da3c6dcafd2d2e4fe001ebd53463502
  errMsg :: Tensor.Restricted.Tensor a -> GHC.Base.String
  RecSel Left Tensor.Restricted.Tensor
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ @ a (ds2 :: Tensor.Restricted.Tensor a) ->
                 case ds2 of wild {
                   DEFAULT -> Tensor.Restricted.errMsg1
                   Tensor.Restricted.Err ds3 -> ds3 }) -}
c82767fd939fbeb504a3fd80481e1f87
  errMsg1 :: GHC.Base.String
  {- Strictness: x -}
ee96128703430c899953fb60aebfaab7
  indexOutOfRange :: GHC.Base.String
  {- Unfolding: (GHC.CString.unpackCString#
                   "Index out of range!"#) -}
1874f31579655244b7f339414f84cc10
  kr :: GHC.Num.Num a => GHC.Types.Int -> Tensor.Restricted.Tensor a
  {- Arity: 2, Strictness: <L,U(A,A,A,A,A,A,C(U))><S(S),1*U(U)>,
     Inline: INLINE[0],
     Unfolding: InlineRule (2, True, False)
                (\ @ a (w :: GHC.Num.Num a) (w1 :: GHC.Types.Int) ->
                 case w1 of ww { GHC.Types.I# ww1 ->
                 Tensor.Restricted.$wkr @ a w ww1 }) -}
81badc0eb9dbdeba4f971e2c416c5d6a
  kr1 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "j"#) -}
385337a2903e6ae12c222f00a217d2c3
  kr2 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "i"#) -}
1dd4591a1897f80843e346119af769ed
  kr3 :: GHC.Num.Num a => GHC.Types.Int -> Tensor.Restricted.Tensor a
  {- Arity: 2, Strictness: <L,U(A,A,A,A,A,A,C(U))><S(S),1*U(U)>,
     Inline: INLINE[0],
     Unfolding: InlineRule (2, True, False)
                (\ @ a (w :: GHC.Num.Num a) (w1 :: GHC.Types.Int) ->
                 case w1 of ww { GHC.Types.I# ww1 ->
                 Tensor.Restricted.$wkr3 @ a w ww1 }) -}
7e3254873368ab89dbf9f5be1500e976
  kr4 :: GHC.Num.Num a => GHC.Types.Int -> Tensor.Restricted.Tensor a
  {- Arity: 2, Strictness: <L,U(A,A,A,A,A,A,C(U))><S(S),1*U(U)>,
     Inline: INLINE[0],
     Unfolding: InlineRule (2, True, False)
                (\ @ a (w :: GHC.Num.Num a) (w1 :: GHC.Types.Int) ->
                 case w1 of ww { GHC.Types.I# ww1 ->
                 Tensor.Restricted.$wkr4 @ a w ww1 }) -}
2309df2cf381288c9796d60aa97e947f
  kr6 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "k"#) -}
9c4ee8daba8ae10a40db0109e436a243
  kr7 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "l"#) -}
1640783331e694b94828e266dd899e3b
  scalarVal :: Tensor.Restricted.Tensor a -> a
  RecSel Left Tensor.Restricted.Tensor
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ @ a (ds2 :: Tensor.Restricted.Tensor a) ->
                 case ds2 of wild {
                   DEFAULT -> Tensor.Restricted.scalarVal1 @ a
                   Tensor.Restricted.Scalar ds3 -> ds3 }) -}
3720eca0f1221f813dee74372bda0c78
  scalarVal1 :: a
  {- Strictness: x -}
8833f7094d172a6995ae86b1399bb394
  switchInd ::
    Tensor.Restricted.Tensor a
    -> GHC.Base.Maybe GHC.Base.String -> Tensor.Restricted.Tensor a
  {- Arity: 2, Strictness: <S,1*U><S,1*U> -}
c597b80271b7834390e27f13cb520dc7
  switchInd' ::
    Tensor.Restricted.Tensor a
    -> GHC.Base.Maybe GHC.Base.String -> Tensor.Restricted.Tensor a
  {- Arity: 2, Strictness: <S,1*U><S,1*U> -}
134a94b789f3d1ce2ed30ac5315e0da3
  tensorData ::
    Tensor.Restricted.Tensor a -> [Tensor.Restricted.Tensor a]
  RecSel Left Tensor.Restricted.Tensor
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ @ a (ds2 :: Tensor.Restricted.Tensor a) ->
                 case ds2 of wild {
                   DEFAULT -> Tensor.Restricted.tensorData1 @ a
                   Tensor.Restricted.Tensor ds3 ds4 -> ds4 }) -}
2703526bfe4ce8d0a7bc47da41bfe2a1
  tensorData1 :: [Tensor.Restricted.Tensor a]
  {- Strictness: x -}
f93f88ca312846901bc7c89ed31874bc
  tensorIndex :: Tensor.Restricted.Tensor a -> Tensor.Index.TIndex
  RecSel Left Tensor.Restricted.Tensor
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ @ a (ds2 :: Tensor.Restricted.Tensor a) ->
                 case ds2 of wild {
                   DEFAULT -> Tensor.Restricted.tensorIndex1
                   Tensor.Restricted.Tensor ds3 ds4 -> ds3 }) -}
4076e39486447f458c287a8aebe4aace
  tensorIndex1 :: Tensor.Index.TIndex
  {- Strictness: x -}
instance [safe] Data.Binary.Class.Binary [Tensor.Restricted.Tensor]
  = Tensor.Restricted.$fBinaryTensor
instance [safe] GHC.Classes.Eq [Tensor.Restricted.Tensor]
  = Tensor.Restricted.$fEqTensor
instance [safe] GHC.Float.Floating [Tensor.Restricted.Tensor]
  = Tensor.Restricted.$fFloatingTensor
instance [safe] GHC.Real.Fractional [Tensor.Restricted.Tensor]
  = Tensor.Restricted.$fFractionalTensor
instance [safe] GHC.Base.Functor [Tensor.Restricted.Tensor]
  = Tensor.Restricted.$fFunctorTensor
instance [safe] Tensor.Multilinear.Multilinear [Tensor.Restricted.Tensor]
  = Tensor.Restricted.$fMultilinearTensor
instance [safe] GHC.Num.Num [Tensor.Restricted.Tensor]
  = Tensor.Restricted.$fNumTensor
instance [safe] GHC.Show.Show [Tensor.Restricted.Tensor]
  = Tensor.Restricted.$fShowTensor
"SPEC/Tensor.Restricted $dm!==! @ Tensor" [ALWAYS] forall ($dMultilinear :: Tensor.Multilinear.Multilinear
                                                                              Tensor.Restricted.Tensor)
  Tensor.Multilinear.$dm!==! @ Tensor.Restricted.Tensor $dMultilinear
  = Tensor.Restricted.$fMultilinearTensor_$s$dm!==!
vectorised variables:
vectorised tycons:
vectorised reused tycons:
parallel variables:
parallel tycons:
trusted: safe
require own pkg trusted: False

