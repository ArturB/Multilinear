
==================== FINAL INTERFACE ====================
2017-01-18 19:47:46.6712965 UTC

interface Tensor-0.1.0.0-1EOex3vvt9xIu9Nz1rXDxl:Tensor.Restricted 8001
  interface hash: be1edc5df5d19fcd225a00bcfec7ceb1
  ABI hash: 0dc5ce7ec2b7af015c2c81ee2930c8cb
  export-list hash: 265c4ff84182d84bd2768c32f715f804
  orphan hash: 693e9af84d3dfcc71e640e005bdc5e2e
  flag hash: 11c1d53d86ff1fc48fbbf191e9636203
  sig of: Nothing
  used TH splices: False
  where
exports:
  Tensor.Restricted._dot
  Tensor.Restricted.commonIndex
  Tensor.Restricted.kr
  Tensor.Restricted.kr3
  Tensor.Restricted.kr4
  Tensor.Restricted.switchInd
  Tensor.Restricted.switchInd'
  Tensor.Restricted.Tensor{Tensor.Restricted.Err Tensor.Restricted.Scalar Tensor.Restricted.Tensor errMsg scalarVal tensorData tensorIndex}
module dependencies: Tensor.Index Tensor.Multilinear
package dependencies: array-0.5.1.1@array-0.5.1.1 base-4.9.0.0*
                      binary-0.8.3.0@binary-0.8.3.0*
                      bytestring-0.10.8.1@bytestring-0.10.8.1
                      containers-0.5.7.1@containers-0.5.7.1
                      deepseq-1.4.2.0@deepseq-1.4.2.0 ghc-prim-0.5.0.0
                      integer-gmp-1.0.0.1
orphans: base-4.9.0.0:GHC.Base base-4.9.0.0:GHC.Float
         binary-0.8.3.0@binary-0.8.3.0:Data.Binary.Generic
         bytestring-0.10.8.1@bytestring-0.10.8.1:Data.ByteString.Builder
family instance modules: base-4.9.0.0:Control.Applicative
                         base-4.9.0.0:Data.Complex base-4.9.0.0:Data.Either
                         base-4.9.0.0:Data.Functor.Const base-4.9.0.0:Data.Functor.Identity
                         base-4.9.0.0:Data.List.NonEmpty base-4.9.0.0:Data.Monoid
                         base-4.9.0.0:Data.Semigroup base-4.9.0.0:Data.Type.Equality
                         base-4.9.0.0:Data.Version base-4.9.0.0:Data.Void
                         base-4.9.0.0:GHC.Exts base-4.9.0.0:GHC.Generics
                         base-4.9.0.0:GHC.IO.Exception base-4.9.0.0:GHC.TypeLits
                         containers-0.5.7.1@containers-0.5.7.1:Data.IntMap.Base
                         containers-0.5.7.1@containers-0.5.7.1:Data.IntSet.Base
                         containers-0.5.7.1@containers-0.5.7.1:Data.Map.Base
                         containers-0.5.7.1@containers-0.5.7.1:Data.Sequence
                         containers-0.5.7.1@containers-0.5.7.1:Data.Set.Base
import  -/  Tensor.Index 769fc71ede0f3c521fe8f01a59c93ce2
  exports: 930656b70af87576c7a90bf4d49280ce
  !=! 9096a8a158b1a821f37b5f7a103175f6
  Contravariant 95abc25e82ccd5aa632597d8abc168d6
  Covariant 48737a6f916c7e33799bcffe9bcb42c9
  Indifferent d026770809a3eb33bf559767e8eafac7
  TIndex 2753f84c83e056ab8ce78b76a493bc70
  indexCount e6361dd771af0e7f5641972cfbd02207
  indexName a632d0855c89d2b841a50231d46ba9b4
import  -/  Tensor.Multilinear 6bc1692ae6aa026c85905ff7f31c1e09
  exports: fffde4799cec63d0ebedaa87a833690a
  !* 3f380e1131b511a59c47308607f0d646
  Multilinear 88e5c689338f269a4d054bf6318c6dde
  elems 67a832f3be00f5e3ab856ded13e9d44a
  generate c1b0da9689f898798b5b493694d14f2b
  indices 709154e860108f506af7543275c6257a
  order e010e8e47d7d28c1b8cda920b37ac87f
  rename 85f5cacddbcbac16716d3739199411ae
  transpose 36a6326b0535c26432a2fa2af35b4a8c
import  -/  base-4.9.0.0:Control.Monad b6b2f076948b5e8acd6d95beb4d22bfc
import  -/  base-4.9.0.0:Data.Foldable 3cbed01c922be29649c33015287c82ca
import  -/  base-4.9.0.0:Data.Functor 67cebb006c069ea73adcd2d468cdb0dc
import  -/  base-4.9.0.0:Data.List d711f98b49ef5d33e5b3d404631ed073
import  -/  base-4.9.0.0:Data.Maybe 086a84053ef7f7810663b5f03b7ec3f7
import  -/  base-4.9.0.0:GHC.Base dd8044a8d640eee51828c17c476a6ba7
import  -/  base-4.9.0.0:GHC.Float a46e197015eefaa013d7004e58481c54
import  -/  base-4.9.0.0:GHC.List 47d436dfb7454bb1883fb4d943e3f389
import  -/  base-4.9.0.0:GHC.Num f0aed3315b3ed1b330b71fc4148a5581
import  -/  base-4.9.0.0:GHC.Real 011de9ca3282ad24a84e4e15f974f98e
import  -/  base-4.9.0.0:GHC.Show 0b5845243cb2ec62b57dd6963d276ec6
import  -/  base-4.9.0.0:Prelude 2d9cd8b0ec3d728f62b734df888d2e34
import  -/  binary-0.8.3.0@binary-0.8.3.0:Data.Binary 6874ec1640b9c9e26e0b523287f2c847
import  -/  binary-0.8.3.0@binary-0.8.3.0:Data.Binary.Class 8597f8b1c2ab4e12727292e0fd7fcc19
import  -/  binary-0.8.3.0@binary-0.8.3.0:Data.Binary.Get.Internal 2e7605525151d1d4905dbc0c729d189c
import  -/  ghc-prim-0.5.0.0:GHC.Classes 16d48e012d23eaef9bca91ccdd572c02
d87e154ad7edb21544b399cf1c30a76d
  (!*!) ::
    GHC.Num.Num a =>
    Tensor.Restricted.Tensor a
    -> Tensor.Restricted.Tensor a -> Tensor.Restricted.Tensor a
  {- Arity: 3,
     Strictness: <L,U(C(U),A,C(U),A,A,A,C(U))><S,1*U><S,1*U> -}
d87e154ad7edb21544b399cf1c30a76d
  $fBinaryTensor ::
    Data.Binary.Class.Binary a =>
    Data.Binary.Class.Binary (Tensor.Restricted.Tensor a)
  DFunId
  {- Arity: 1, Strictness: <L,U(C(U(U,U)),U,A)>m,
     Unfolding: DFun: @ a ($dBinary :: Data.Binary.Class.Binary a).
                  @ (Tensor.Restricted.Tensor a)
                  (Tensor.Restricted.$fBinaryTensor_$cput @ a $dBinary)
                  (Tensor.Restricted.$fBinaryTensor_$cget @ a $dBinary)
                  (Tensor.Restricted.$fBinaryTensor_$cputList @ a $dBinary) -}
d87e154ad7edb21544b399cf1c30a76d
  $fBinaryTensor1 ::
    Data.Binary.Class.Binary a =>
    [Tensor.Restricted.Tensor a] -> Data.Binary.Put.Put
  {- Arity: 1, Strictness: <L,U(C(U(U,U)),U,A)> -}
d87e154ad7edb21544b399cf1c30a76d
  $fBinaryTensor2 ::
    Data.Binary.Class.Binary a =>
    Data.Binary.Get.Internal.Get (Tensor.Restricted.Tensor a)
  {- Arity: 1, Strictness: <L,U(C(U(U,U)),U,A)> -}
d87e154ad7edb21544b399cf1c30a76d
  $fBinaryTensor_$cget ::
    Data.Binary.Class.Binary a =>
    Data.Binary.Get.Internal.Get (Tensor.Restricted.Tensor a)
  {- Arity: 1, Strictness: <L,U(C(U(U,U)),U,A)>,
     Unfolding: InlineRule (0, True, True)
                Tensor.Restricted.$fBinaryTensor2 -}
d87e154ad7edb21544b399cf1c30a76d
  $fBinaryTensor_$cput ::
    Data.Binary.Class.Binary a =>
    Tensor.Restricted.Tensor a -> Data.Binary.Put.Put
  {- Arity: 2, Strictness: <L,U(C(U(U,U)),U,A)><S,1*U>m,
     Inline: INLINE[0],
     Unfolding: InlineRule (2, True, False)
                (\ @ a
                   (w :: Data.Binary.Class.Binary a)
                   (w1 :: Tensor.Restricted.Tensor a) ->
                 case Tensor.Restricted.$w$cput @ a w w1 of ww { (#,#) ww1 ww2 ->
                 (Data.Binary.Put.PairS @ () ww1 ww2)
                   `cast`
                 (Sym (Data.Binary.Put.N:PutM[0]) <()>_N) }) -}
d87e154ad7edb21544b399cf1c30a76d
  $fBinaryTensor_$cputList ::
    Data.Binary.Class.Binary a =>
    [Tensor.Restricted.Tensor a] -> Data.Binary.Put.Put
  {- Arity: 1, Strictness: <L,U(C(U(U,U)),U,A)>,
     Unfolding: InlineRule (0, True, True)
                Tensor.Restricted.$fBinaryTensor1 -}
d87e154ad7edb21544b399cf1c30a76d
  $fEqTensor ::
    GHC.Classes.Eq a => GHC.Classes.Eq (Tensor.Restricted.Tensor a)
  DFunId
  {- Arity: 1, HasNoCafRefs, Strictness: <L,U(C(C1(U)),A)>m,
     Unfolding: DFun: @ a ($dEq :: GHC.Classes.Eq a).
                  @ (Tensor.Restricted.Tensor a)
                  (Tensor.Restricted.$fEqTensor_$c== @ a $dEq)
                  (Tensor.Restricted.$fEqTensor_$c/= @ a $dEq) -}
d87e154ad7edb21544b399cf1c30a76d
  $fEqTensor1 ::
    GHC.Classes.Eq a =>
    Tensor.Restricted.Tensor a
    -> Tensor.Restricted.Tensor a -> GHC.Types.Bool
  {- Arity: 3, HasNoCafRefs,
     Strictness: <L,U(C(C1(U)),A)><S,1*U><S,1*U> -}
d87e154ad7edb21544b399cf1c30a76d
  $fEqTensor2 ::
    GHC.Classes.Eq a =>
    Tensor.Restricted.Tensor a
    -> Tensor.Restricted.Tensor a -> GHC.Types.Bool
  {- Arity: 1, HasNoCafRefs, Strictness: <L,U(C(C1(U)),A)> -}
d87e154ad7edb21544b399cf1c30a76d
  $fEqTensor_$c/= ::
    GHC.Classes.Eq a =>
    Tensor.Restricted.Tensor a
    -> Tensor.Restricted.Tensor a -> GHC.Types.Bool
  {- Arity: 3, HasNoCafRefs,
     Strictness: <L,U(C(C1(U)),A)><S,1*U><S,1*U>,
     Unfolding: InlineRule (0, True, True)
                Tensor.Restricted.$fEqTensor1 -}
d87e154ad7edb21544b399cf1c30a76d
  $fEqTensor_$c== ::
    GHC.Classes.Eq a =>
    Tensor.Restricted.Tensor a
    -> Tensor.Restricted.Tensor a -> GHC.Types.Bool
  {- Arity: 1, HasNoCafRefs, Strictness: <L,U(C(C1(U)),A)>,
     Unfolding: InlineRule (0, True, True)
                Tensor.Restricted.$fEqTensor2 -}
d87e154ad7edb21544b399cf1c30a76d
  $fFloatingTensor ::
    GHC.Float.Floating a =>
    GHC.Float.Floating (Tensor.Restricted.Tensor a)
  DFunId
  {- Arity: 1,
     Strictness: <L,U(U(U(U,U,U,U,U,U,U),U,U,U),1*U,C(U),C(U),A,A,A,C(U),C(U),A,C(U),C(U),C(U),C(U),C(U),A,C(U),C(U),C(U),A,A,A,A)>,
     Unfolding: DFun: @ a ($dFloating :: GHC.Float.Floating a).
                  @ (Tensor.Restricted.Tensor a)
                  (Tensor.Restricted.$fFloatingTensor32 @ a $dFloating)
                  (Tensor.Restricted.$fFloatingTensor31 @ a $dFloating)
                  (Tensor.Restricted.$fFloatingTensor_$cexp @ a $dFloating)
                  (Tensor.Restricted.$fFloatingTensor_$clog @ a $dFloating)
                  (Tensor.Restricted.$fFloatingTensor_$csqrt @ a $dFloating)
                  (Tensor.Restricted.$fFloatingTensor_$c** @ a $dFloating)
                  (Tensor.Restricted.$fFloatingTensor_$clogBase @ a $dFloating)
                  (Tensor.Restricted.$fFloatingTensor_$csin @ a $dFloating)
                  (Tensor.Restricted.$fFloatingTensor_$ccos @ a $dFloating)
                  (Tensor.Restricted.$fFloatingTensor_$ctan @ a $dFloating)
                  (Tensor.Restricted.$fFloatingTensor_$casin @ a $dFloating)
                  (Tensor.Restricted.$fFloatingTensor_$cacos @ a $dFloating)
                  (Tensor.Restricted.$fFloatingTensor_$catan @ a $dFloating)
                  (Tensor.Restricted.$fFloatingTensor_$csinh @ a $dFloating)
                  (Tensor.Restricted.$fFloatingTensor_$ccosh @ a $dFloating)
                  (Tensor.Restricted.$fFloatingTensor_$ctanh @ a $dFloating)
                  (Tensor.Restricted.$fFloatingTensor_$casinh @ a $dFloating)
                  (Tensor.Restricted.$fFloatingTensor_$cacosh @ a $dFloating)
                  (Tensor.Restricted.$fFloatingTensor_$catanh @ a $dFloating)
                  (Tensor.Restricted.$fFloatingTensor_$clog1p @ a $dFloating)
                  (Tensor.Restricted.$fFloatingTensor_$cexpm1 @ a $dFloating)
                  (Tensor.Restricted.$fFloatingTensor_$clog1pexp @ a $dFloating)
                  (Tensor.Restricted.$fFloatingTensor_$clog1mexp @ a $dFloating) -}
d87e154ad7edb21544b399cf1c30a76d
  $fFloatingTensor1 ::
    GHC.Float.Floating a =>
    Tensor.Restricted.Tensor a -> Tensor.Restricted.Tensor a
  {- Arity: 2,
     Strictness: <S(S(S(LLLLLLC(S))LLL)LLLLLLLLLLLLLLLLLLLLLL),U(U(U(U,U,U,U,U,U,U),U,U,U),A,C(U),C(U),A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A)><S,1*U>,
     Unfolding: (\ @ a
                   ($dFloating :: GHC.Float.Floating a)
                   (eta :: Tensor.Restricted.Tensor a) ->
                 let {
                   $dNum :: GHC.Real.Fractional a
                   = GHC.Float.$p1Floating @ a $dFloating
                 } in
                 let {
                   $dNum1 :: GHC.Num.Num a = GHC.Real.$p1Fractional @ a $dNum
                 } in
                 case GHC.Num.fromInteger
                        @ a
                        $dNum1
                        Tensor.Restricted.$fFloatingTensor8 of dt1 { DEFAULT ->
                 Tensor.Restricted.$fFloatingTensor4
                   @ a
                   $dFloating
                   (Tensor.Restricted.$fFloatingTensor3
                      @ a
                      $dNum1
                      (Tensor.Restricted.Scalar @ a dt1)
                      (Tensor.Restricted.$fFloatingTensor2 @ a $dFloating eta)) }) -}
d87e154ad7edb21544b399cf1c30a76d
  $fFloatingTensor10 ::
    GHC.Float.Floating a =>
    Tensor.Restricted.Tensor a -> Tensor.Restricted.Tensor a
  {- Arity: 2,
     Strictness: <S(SLLLLLLLLLLLLLLLLLLLLLL),U(1*U,A,C(U),A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A)><S,1*U>,
     Unfolding: (\ @ a
                   ($dFloating :: GHC.Float.Floating a)
                   (eta :: Tensor.Restricted.Tensor a) ->
                 let {
                   $dFractional :: GHC.Real.Fractional a
                   = GHC.Float.$p1Floating @ a $dFloating
                 } in
                 let {
                   $dNum :: GHC.Num.Num a = GHC.Real.$p1Fractional @ a $dFractional
                 } in
                 case GHC.Num.fromInteger
                        @ a
                        $dNum
                        Tensor.Restricted.$fFloatingTensor7 of dt1 { DEFAULT ->
                 Tensor.Restricted.$fFloatingTensor3
                   @ a
                   $dNum
                   (Tensor.Restricted.$fFloatingTensor2 @ a $dFloating eta)
                   (Tensor.Restricted.Scalar @ a dt1) }) -}
d87e154ad7edb21544b399cf1c30a76d
  $fFloatingTensor11 ::
    GHC.Float.Floating a =>
    Tensor.Restricted.Tensor a -> Tensor.Restricted.Tensor a
  {- Arity: 2, HasNoCafRefs,
     Strictness: <L,U(A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,C(U),A,A,A,A)><S,1*U> -}
d87e154ad7edb21544b399cf1c30a76d
  $fFloatingTensor12 ::
    GHC.Float.Floating a =>
    Tensor.Restricted.Tensor a -> Tensor.Restricted.Tensor a
  {- Arity: 2, HasNoCafRefs,
     Strictness: <L,U(A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,C(U),A,A,A,A,A)><S,1*U> -}
d87e154ad7edb21544b399cf1c30a76d
  $fFloatingTensor13 ::
    GHC.Float.Floating a =>
    Tensor.Restricted.Tensor a -> Tensor.Restricted.Tensor a
  {- Arity: 2, HasNoCafRefs,
     Strictness: <L,U(A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,C(U),A,A,A,A,A,A)><S,1*U> -}
d87e154ad7edb21544b399cf1c30a76d
  $fFloatingTensor14 ::
    GHC.Float.Floating a =>
    Tensor.Restricted.Tensor a -> Tensor.Restricted.Tensor a
  {- Arity: 2,
     Strictness: <L,U(1*U(A,C(U),A,A),A,A,A,A,A,A,A,A,A,A,A,A,C(U),C(U),A,A,A,A,A,A,A,A)><S,U>,
     Unfolding: (\ @ a
                   ($dFloating :: GHC.Float.Floating a)
                   (eta :: Tensor.Restricted.Tensor a) ->
                 Tensor.Restricted.$fFloatingTensor17
                   @ a
                   (GHC.Float.$p1Floating @ a $dFloating)
                   (Tensor.Restricted.$fFloatingTensor16 @ a $dFloating eta)
                   (Tensor.Restricted.$fFloatingTensor15 @ a $dFloating eta)) -}
d87e154ad7edb21544b399cf1c30a76d
  $fFloatingTensor15 ::
    GHC.Float.Floating a =>
    Tensor.Restricted.Tensor a -> Tensor.Restricted.Tensor a
  {- Arity: 2, HasNoCafRefs,
     Strictness: <L,U(A,A,A,A,A,A,A,A,A,A,A,A,A,A,C(U),A,A,A,A,A,A,A,A)><S,1*U> -}
d87e154ad7edb21544b399cf1c30a76d
  $fFloatingTensor16 ::
    GHC.Float.Floating a =>
    Tensor.Restricted.Tensor a -> Tensor.Restricted.Tensor a
  {- Arity: 2, HasNoCafRefs,
     Strictness: <L,U(A,A,A,A,A,A,A,A,A,A,A,A,A,C(U),A,A,A,A,A,A,A,A,A)><S,1*U> -}
d87e154ad7edb21544b399cf1c30a76d
  $fFloatingTensor17 ::
    GHC.Real.Fractional a =>
    Tensor.Restricted.Tensor a
    -> Tensor.Restricted.Tensor a -> Tensor.Restricted.Tensor a
  {- Arity: 3, Strictness: <L,U(A,C(U),A,A)><S,1*U><S,1*U> -}
d87e154ad7edb21544b399cf1c30a76d
  $fFloatingTensor18 ::
    GHC.Float.Floating a =>
    Tensor.Restricted.Tensor a -> Tensor.Restricted.Tensor a
  {- Arity: 2, HasNoCafRefs,
     Strictness: <L,U(A,A,A,A,A,A,A,A,A,A,A,A,C(U),A,A,A,A,A,A,A,A,A,A)><S,1*U> -}
d87e154ad7edb21544b399cf1c30a76d
  $fFloatingTensor19 ::
    GHC.Float.Floating a =>
    Tensor.Restricted.Tensor a -> Tensor.Restricted.Tensor a
  {- Arity: 2, HasNoCafRefs,
     Strictness: <L,U(A,A,A,A,A,A,A,A,A,A,A,C(U),A,A,A,A,A,A,A,A,A,A,A)><S,1*U> -}
d87e154ad7edb21544b399cf1c30a76d
  $fFloatingTensor2 ::
    GHC.Float.Floating a =>
    Tensor.Restricted.Tensor a -> Tensor.Restricted.Tensor a
  {- Arity: 2, HasNoCafRefs,
     Strictness: <L,U(A,A,C(U),A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A)><S,1*U> -}
d87e154ad7edb21544b399cf1c30a76d
  $fFloatingTensor20 ::
    GHC.Float.Floating a =>
    Tensor.Restricted.Tensor a -> Tensor.Restricted.Tensor a
  {- Arity: 2, HasNoCafRefs,
     Strictness: <L,U(A,A,A,A,A,A,A,A,A,A,C(U),A,A,A,A,A,A,A,A,A,A,A,A)><S,1*U> -}
d87e154ad7edb21544b399cf1c30a76d
  $fFloatingTensor21 ::
    GHC.Float.Floating a =>
    Tensor.Restricted.Tensor a -> Tensor.Restricted.Tensor a
  {- Arity: 2,
     Strictness: <L,U(1*U(A,C(U),A,A),A,A,A,A,A,A,C(U),C(U),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><S,U>,
     Unfolding: (\ @ a
                   ($dFloating :: GHC.Float.Floating a)
                   (eta :: Tensor.Restricted.Tensor a) ->
                 Tensor.Restricted.$fFloatingTensor17
                   @ a
                   (GHC.Float.$p1Floating @ a $dFloating)
                   (Tensor.Restricted.$fFloatingTensor23 @ a $dFloating eta)
                   (Tensor.Restricted.$fFloatingTensor22 @ a $dFloating eta)) -}
d87e154ad7edb21544b399cf1c30a76d
  $fFloatingTensor22 ::
    GHC.Float.Floating a =>
    Tensor.Restricted.Tensor a -> Tensor.Restricted.Tensor a
  {- Arity: 2, HasNoCafRefs,
     Strictness: <L,U(A,A,A,A,A,A,A,A,C(U),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><S,1*U> -}
d87e154ad7edb21544b399cf1c30a76d
  $fFloatingTensor23 ::
    GHC.Float.Floating a =>
    Tensor.Restricted.Tensor a -> Tensor.Restricted.Tensor a
  {- Arity: 2, HasNoCafRefs,
     Strictness: <L,U(A,A,A,A,A,A,A,C(U),A,A,A,A,A,A,A,A,A,A,A,A,A,A,A)><S,1*U> -}
d87e154ad7edb21544b399cf1c30a76d
  $fFloatingTensor24 ::
    GHC.Float.Floating a =>
    Tensor.Restricted.Tensor a
    -> Tensor.Restricted.Tensor a -> Tensor.Restricted.Tensor a
  {- Arity: 3,
     Strictness: <L,U(1*U(A,C(U),A,A),A,A,C(U),A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A)><S,1*U><S,1*U>,
     Unfolding: (\ @ a
                   ($dFloating :: GHC.Float.Floating a)
                   (eta :: Tensor.Restricted.Tensor a)
                   (eta1 :: Tensor.Restricted.Tensor a) ->
                 Tensor.Restricted.$fFloatingTensor17
                   @ a
                   (GHC.Float.$p1Floating @ a $dFloating)
                   (Tensor.Restricted.$fFloatingTensor6 @ a $dFloating eta1)
                   (Tensor.Restricted.$fFloatingTensor6 @ a $dFloating eta)) -}
d87e154ad7edb21544b399cf1c30a76d
  $fFloatingTensor25 ::
    GHC.Float.Floating a =>
    Tensor.Restricted.Tensor a
    -> Tensor.Restricted.Tensor a -> Tensor.Restricted.Tensor a
  {- Arity: 3,
     Strictness: <L,U(1*U(1*U(C(U),A,C(U),A,A,A,C(U)),A,A,A),A,C(U),C(U),A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A)><S,1*U><S,1*U>,
     Unfolding: (\ @ a
                   ($dFloating :: GHC.Float.Floating a)
                   (eta :: Tensor.Restricted.Tensor a)
                   (eta1 :: Tensor.Restricted.Tensor a) ->
                 Tensor.Restricted.$fFloatingTensor2
                   @ a
                   $dFloating
                   (Tensor.Restricted.$fFloatingTensor26
                      @ a
                      (GHC.Real.$p1Fractional @ a (GHC.Float.$p1Floating @ a $dFloating))
                      (Tensor.Restricted.$fFloatingTensor6 @ a $dFloating eta)
                      eta1)) -}
d87e154ad7edb21544b399cf1c30a76d
  $fFloatingTensor26 ::
    GHC.Num.Num a =>
    Tensor.Restricted.Tensor a
    -> Tensor.Restricted.Tensor a -> Tensor.Restricted.Tensor a
  {- Arity: 3,
     Strictness: <L,U(C(U),A,C(U),A,A,A,C(U))><S,1*U><S,1*U>,
     Unfolding: (\ @ a
                   ($dNum :: GHC.Num.Num a)
                   (ds2 :: Tensor.Restricted.Tensor a)
                   (ds3 :: Tensor.Restricted.Tensor a) ->
                 case ds2 of wild {
                   DEFAULT
                   -> case ds3 of wild1 {
                        DEFAULT
                        -> case wild of wild2 {
                             Tensor.Restricted.Tensor ds4 ds5
                             -> case wild1 of wild3 {
                                  Tensor.Restricted.Tensor ds6 ds7
                                  -> case Tensor.Restricted.commonIndex
                                            @ a
                                            wild2
                                            wild3 of cmi { DEFAULT ->
                                     Tensor.Restricted.!*!
                                       @ a
                                       $dNum
                                       (Tensor.Restricted.switchInd' @ a wild2 cmi)
                                       (Tensor.Restricted.switchInd' @ a wild3 cmi) }
                                  Tensor.Restricted.Err ipv -> wild3 }
                             Tensor.Restricted.Err msg -> wild2 }
                        Tensor.Restricted.Scalar x2
                        -> Tensor.Restricted.$fFloatingTensor27
                             @ a
                             @ a
                             (\ (ds4 :: a) -> GHC.Num.* @ a $dNum ds4 x2)
                             wild }
                   Tensor.Restricted.Scalar x1
                   -> case ds3 of wild1 {
                        DEFAULT
                        -> Tensor.Restricted.$fFloatingTensor27
                             @ a
                             @ a
                             (GHC.Num.* @ a $dNum x1)
                             wild1
                        Tensor.Restricted.Scalar x2
                        -> case GHC.Num.* @ a $dNum x1 x2 of dt1 { DEFAULT ->
                           Tensor.Restricted.Scalar @ a dt1 } } }) -}
d87e154ad7edb21544b399cf1c30a76d
  $fFloatingTensor27 ::
    (a -> b)
    -> Tensor.Restricted.Tensor a -> Tensor.Restricted.Tensor b
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U> -}
d87e154ad7edb21544b399cf1c30a76d
  $fFloatingTensor28 ::
    GHC.Float.Floating a =>
    Tensor.Restricted.Tensor a -> Tensor.Restricted.Tensor a
  {- Arity: 2,
     Strictness: <S(S(LLLC(S))LLLLLLLLLLLLLLLLLLLLLL),U(U(U(C(U),A,C(U),A,A,A,C(U)),A,A,1*C1(U)),A,C(U),C(U),A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A)><S,1*U>,
     Unfolding: (\ @ a
                   ($dFloating :: GHC.Float.Floating a)
                   (eta :: Tensor.Restricted.Tensor a) ->
                 case GHC.Real.fromRational
                        @ a
                        (GHC.Float.$p1Floating @ a $dFloating)
                        Tensor.Restricted.$fFloatingTensor29 of dt1 { DEFAULT ->
                 Tensor.Restricted.$fFloatingTensor25
                   @ a
                   $dFloating
                   eta
                   (Tensor.Restricted.Scalar @ a dt1) }) -}
b5bb067d5cd12882c22e1b851b2e8364
  $fFloatingTensor29 :: GHC.Real.Ratio GHC.Integer.Type.Integer
  {- HasNoCafRefs,
     Unfolding: (GHC.Real.:%
                   @ GHC.Integer.Type.Integer
                   Tensor.Restricted.$fFloatingTensor7
                   Tensor.Restricted.$fFloatingTensor30) -}
d87e154ad7edb21544b399cf1c30a76d
  $fFloatingTensor3 ::
    GHC.Num.Num a =>
    Tensor.Restricted.Tensor a
    -> Tensor.Restricted.Tensor a -> Tensor.Restricted.Tensor a
  {- Arity: 3,
     Strictness: <L,U(A,C(C1(U)),A,A,A,A,A)><S,1*U><S,1*U> -}
2c80444d271d0bc5d90ce9503a1d4e5c
  $fFloatingTensor30 :: GHC.Integer.Type.Integer
  {- HasNoCafRefs, Unfolding: (2) -}
d87e154ad7edb21544b399cf1c30a76d
  $fFloatingTensor31 ::
    GHC.Float.Floating a => Tensor.Restricted.Tensor a
  {- Arity: 1, HasNoCafRefs,
     Strictness: <S(LSLLLLLLLLLLLLLLLLLLLLL),1*U(A,1*U,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A)>m1,
     Unfolding: InlineRule (1, True, False)
                (\ @ a ($dFloating :: GHC.Float.Floating a) ->
                 case GHC.Float.pi @ a $dFloating of dt1 { DEFAULT ->
                 Tensor.Restricted.Scalar @ a dt1 }) -}
d87e154ad7edb21544b399cf1c30a76d
  $fFloatingTensor32 ::
    GHC.Float.Floating a =>
    GHC.Real.Fractional (Tensor.Restricted.Tensor a)
  {- Arity: 1,
     Strictness: <L,1*U(1*U(U(C(U),C(C1(U)),C(U),A,C(U),C(U),C(U)),C(U),A,C(U)),A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A)>m,
     Unfolding: InlineRule (1, True, False)
                (\ @ a ($dFloating :: GHC.Float.Floating a) ->
                 Tensor.Restricted.$fFractionalTensor
                   @ a
                   (GHC.Float.$p1Floating @ a $dFloating)) -}
d87e154ad7edb21544b399cf1c30a76d
  $fFloatingTensor4 ::
    GHC.Float.Floating a =>
    Tensor.Restricted.Tensor a -> Tensor.Restricted.Tensor a
  {- Arity: 2,
     Strictness: <S(SLLLLLLLLLLLLLLLLLLLLLL),U(1*U,A,A,C(U),A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A)><S,1*U>,
     Unfolding: (\ @ a
                   ($dFloating :: GHC.Float.Floating a)
                   (eta :: Tensor.Restricted.Tensor a) ->
                 let {
                   $dFractional :: GHC.Real.Fractional a
                   = GHC.Float.$p1Floating @ a $dFloating
                 } in
                 let {
                   $dNum :: GHC.Num.Num a = GHC.Real.$p1Fractional @ a $dFractional
                 } in
                 case GHC.Num.fromInteger
                        @ a
                        $dNum
                        Tensor.Restricted.$fFloatingTensor7 of dt1 { DEFAULT ->
                 Tensor.Restricted.$fFloatingTensor6
                   @ a
                   $dFloating
                   (Tensor.Restricted.$fFloatingTensor5
                      @ a
                      $dNum
                      (Tensor.Restricted.Scalar @ a dt1)
                      eta) }) -}
d87e154ad7edb21544b399cf1c30a76d
  $fFloatingTensor5 ::
    GHC.Num.Num a =>
    Tensor.Restricted.Tensor a
    -> Tensor.Restricted.Tensor a -> Tensor.Restricted.Tensor a
  {- Arity: 3, Strictness: <L,U(C(U),A,A,A,A,A,A)><S,1*U><S,1*U> -}
d87e154ad7edb21544b399cf1c30a76d
  $fFloatingTensor6 ::
    GHC.Float.Floating a =>
    Tensor.Restricted.Tensor a -> Tensor.Restricted.Tensor a
  {- Arity: 2, HasNoCafRefs,
     Strictness: <L,U(A,A,A,C(U),A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A)><S,1*U> -}
0c72f521322688a488cd65852011ed78
  $fFloatingTensor7 :: GHC.Integer.Type.Integer
  {- HasNoCafRefs, Unfolding: (1) -}
67d0aae2e7dd3c71a8c1a52c014e7ca0
  $fFloatingTensor8 :: GHC.Integer.Type.Integer
  {- HasNoCafRefs, Unfolding: (0) -}
d87e154ad7edb21544b399cf1c30a76d
  $fFloatingTensor9 ::
    GHC.Float.Floating a =>
    Tensor.Restricted.Tensor a -> Tensor.Restricted.Tensor a
  {- Arity: 2,
     Strictness: <S(SLLLLLLLLLLLLLLLLLLLLLL),U(U,A,C(U),C(U),A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A)><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ @ a
                   ($dFloating :: GHC.Float.Floating a)
                   (eta :: Tensor.Restricted.Tensor a) ->
                 Tensor.Restricted.$fFloatingTensor4
                   @ a
                   $dFloating
                   (Tensor.Restricted.$fFloatingTensor2 @ a $dFloating eta)) -}
d87e154ad7edb21544b399cf1c30a76d
  $fFloatingTensor_$c** ::
    GHC.Float.Floating a =>
    Tensor.Restricted.Tensor a
    -> Tensor.Restricted.Tensor a -> Tensor.Restricted.Tensor a
  {- Arity: 3,
     Strictness: <L,U(1*U(1*U(C(U),A,C(U),A,A,A,C(U)),A,A,A),A,C(U),C(U),A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A)><S,1*U><S,1*U>,
     Unfolding: InlineRule (0, True, True)
                Tensor.Restricted.$fFloatingTensor25 -}
d87e154ad7edb21544b399cf1c30a76d
  $fFloatingTensor_$cacos ::
    GHC.Float.Floating a =>
    Tensor.Restricted.Tensor a -> Tensor.Restricted.Tensor a
  {- Arity: 2, HasNoCafRefs,
     Strictness: <L,U(A,A,A,A,A,A,A,A,A,A,A,C(U),A,A,A,A,A,A,A,A,A,A,A)><S,1*U>,
     Unfolding: InlineRule (0, True, True)
                Tensor.Restricted.$fFloatingTensor19 -}
d87e154ad7edb21544b399cf1c30a76d
  $fFloatingTensor_$cacosh ::
    GHC.Float.Floating a =>
    Tensor.Restricted.Tensor a -> Tensor.Restricted.Tensor a
  {- Arity: 2, HasNoCafRefs,
     Strictness: <L,U(A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,C(U),A,A,A,A,A)><S,1*U>,
     Unfolding: InlineRule (0, True, True)
                Tensor.Restricted.$fFloatingTensor12 -}
d87e154ad7edb21544b399cf1c30a76d
  $fFloatingTensor_$casin ::
    GHC.Float.Floating a =>
    Tensor.Restricted.Tensor a -> Tensor.Restricted.Tensor a
  {- Arity: 2, HasNoCafRefs,
     Strictness: <L,U(A,A,A,A,A,A,A,A,A,A,C(U),A,A,A,A,A,A,A,A,A,A,A,A)><S,1*U>,
     Unfolding: InlineRule (0, True, True)
                Tensor.Restricted.$fFloatingTensor20 -}
d87e154ad7edb21544b399cf1c30a76d
  $fFloatingTensor_$casinh ::
    GHC.Float.Floating a =>
    Tensor.Restricted.Tensor a -> Tensor.Restricted.Tensor a
  {- Arity: 2, HasNoCafRefs,
     Strictness: <L,U(A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,C(U),A,A,A,A,A,A)><S,1*U>,
     Unfolding: InlineRule (0, True, True)
                Tensor.Restricted.$fFloatingTensor13 -}
d87e154ad7edb21544b399cf1c30a76d
  $fFloatingTensor_$catan ::
    GHC.Float.Floating a =>
    Tensor.Restricted.Tensor a -> Tensor.Restricted.Tensor a
  {- Arity: 2, HasNoCafRefs,
     Strictness: <L,U(A,A,A,A,A,A,A,A,A,A,A,A,C(U),A,A,A,A,A,A,A,A,A,A)><S,1*U>,
     Unfolding: InlineRule (0, True, True)
                Tensor.Restricted.$fFloatingTensor18 -}
d87e154ad7edb21544b399cf1c30a76d
  $fFloatingTensor_$catanh ::
    GHC.Float.Floating a =>
    Tensor.Restricted.Tensor a -> Tensor.Restricted.Tensor a
  {- Arity: 2, HasNoCafRefs,
     Strictness: <L,U(A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,C(U),A,A,A,A)><S,1*U>,
     Unfolding: InlineRule (0, True, True)
                Tensor.Restricted.$fFloatingTensor11 -}
d87e154ad7edb21544b399cf1c30a76d
  $fFloatingTensor_$ccos ::
    GHC.Float.Floating a =>
    Tensor.Restricted.Tensor a -> Tensor.Restricted.Tensor a
  {- Arity: 2, HasNoCafRefs,
     Strictness: <L,U(A,A,A,A,A,A,A,A,C(U),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><S,1*U>,
     Unfolding: InlineRule (0, True, True)
                Tensor.Restricted.$fFloatingTensor22 -}
d87e154ad7edb21544b399cf1c30a76d
  $fFloatingTensor_$ccosh ::
    GHC.Float.Floating a =>
    Tensor.Restricted.Tensor a -> Tensor.Restricted.Tensor a
  {- Arity: 2, HasNoCafRefs,
     Strictness: <L,U(A,A,A,A,A,A,A,A,A,A,A,A,A,A,C(U),A,A,A,A,A,A,A,A)><S,1*U>,
     Unfolding: InlineRule (0, True, True)
                Tensor.Restricted.$fFloatingTensor15 -}
d87e154ad7edb21544b399cf1c30a76d
  $fFloatingTensor_$cexp ::
    GHC.Float.Floating a =>
    Tensor.Restricted.Tensor a -> Tensor.Restricted.Tensor a
  {- Arity: 2, HasNoCafRefs,
     Strictness: <L,U(A,A,C(U),A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A)><S,1*U>,
     Unfolding: InlineRule (0, True, True)
                Tensor.Restricted.$fFloatingTensor2 -}
d87e154ad7edb21544b399cf1c30a76d
  $fFloatingTensor_$cexpm1 ::
    GHC.Float.Floating a =>
    Tensor.Restricted.Tensor a -> Tensor.Restricted.Tensor a
  {- Arity: 2,
     Strictness: <S(SLLLLLLLLLLLLLLLLLLLLLL),U(1*U,A,C(U),A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A)><S,1*U>,
     Unfolding: InlineRule (0, True, True)
                Tensor.Restricted.$fFloatingTensor10 -}
d87e154ad7edb21544b399cf1c30a76d
  $fFloatingTensor_$clog ::
    GHC.Float.Floating a =>
    Tensor.Restricted.Tensor a -> Tensor.Restricted.Tensor a
  {- Arity: 2, HasNoCafRefs,
     Strictness: <L,U(A,A,A,C(U),A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A)><S,1*U>,
     Unfolding: InlineRule (0, True, True)
                Tensor.Restricted.$fFloatingTensor6 -}
d87e154ad7edb21544b399cf1c30a76d
  $fFloatingTensor_$clog1mexp ::
    GHC.Float.Floating a =>
    Tensor.Restricted.Tensor a -> Tensor.Restricted.Tensor a
  {- Arity: 2,
     Strictness: <S(S(S(LLLLLLC(S))LLL)LLLLLLLLLLLLLLLLLLLLLL),U(U(U(U,U,U,U,U,U,U),U,U,U),A,C(U),C(U),A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A)><S,1*U>,
     Unfolding: InlineRule (0, True, True)
                Tensor.Restricted.$fFloatingTensor1 -}
d87e154ad7edb21544b399cf1c30a76d
  $fFloatingTensor_$clog1p ::
    GHC.Float.Floating a =>
    Tensor.Restricted.Tensor a -> Tensor.Restricted.Tensor a
  {- Arity: 2,
     Strictness: <S(SLLLLLLLLLLLLLLLLLLLLLL),U(1*U,A,A,C(U),A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A)><S,1*U>,
     Unfolding: InlineRule (0, True, True)
                Tensor.Restricted.$fFloatingTensor4 -}
d87e154ad7edb21544b399cf1c30a76d
  $fFloatingTensor_$clog1pexp ::
    GHC.Float.Floating a =>
    Tensor.Restricted.Tensor a -> Tensor.Restricted.Tensor a
  {- Arity: 2,
     Strictness: <S(SLLLLLLLLLLLLLLLLLLLLLL),U(U,A,C(U),C(U),A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A)><S,1*U>,
     Unfolding: InlineRule (0, True, True)
                Tensor.Restricted.$fFloatingTensor9 -}
d87e154ad7edb21544b399cf1c30a76d
  $fFloatingTensor_$clogBase ::
    GHC.Float.Floating a =>
    Tensor.Restricted.Tensor a
    -> Tensor.Restricted.Tensor a -> Tensor.Restricted.Tensor a
  {- Arity: 3,
     Strictness: <L,U(1*U(A,C(U),A,A),A,A,C(U),A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A)><S,1*U><S,1*U>,
     Unfolding: InlineRule (0, True, True)
                Tensor.Restricted.$fFloatingTensor24 -}
d87e154ad7edb21544b399cf1c30a76d
  $fFloatingTensor_$csin ::
    GHC.Float.Floating a =>
    Tensor.Restricted.Tensor a -> Tensor.Restricted.Tensor a
  {- Arity: 2, HasNoCafRefs,
     Strictness: <L,U(A,A,A,A,A,A,A,C(U),A,A,A,A,A,A,A,A,A,A,A,A,A,A,A)><S,1*U>,
     Unfolding: InlineRule (0, True, True)
                Tensor.Restricted.$fFloatingTensor23 -}
d87e154ad7edb21544b399cf1c30a76d
  $fFloatingTensor_$csinh ::
    GHC.Float.Floating a =>
    Tensor.Restricted.Tensor a -> Tensor.Restricted.Tensor a
  {- Arity: 2, HasNoCafRefs,
     Strictness: <L,U(A,A,A,A,A,A,A,A,A,A,A,A,A,C(U),A,A,A,A,A,A,A,A,A)><S,1*U>,
     Unfolding: InlineRule (0, True, True)
                Tensor.Restricted.$fFloatingTensor16 -}
d87e154ad7edb21544b399cf1c30a76d
  $fFloatingTensor_$csqrt ::
    GHC.Float.Floating a =>
    Tensor.Restricted.Tensor a -> Tensor.Restricted.Tensor a
  {- Arity: 2,
     Strictness: <S(S(LLLC(S))LLLLLLLLLLLLLLLLLLLLLL),U(U(U(C(U),A,C(U),A,A,A,C(U)),A,A,1*C1(U)),A,C(U),C(U),A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A)><S,1*U>,
     Unfolding: InlineRule (0, True, True)
                Tensor.Restricted.$fFloatingTensor28 -}
d87e154ad7edb21544b399cf1c30a76d
  $fFloatingTensor_$ctan ::
    GHC.Float.Floating a =>
    Tensor.Restricted.Tensor a -> Tensor.Restricted.Tensor a
  {- Arity: 2,
     Strictness: <L,U(1*U(A,C(U),A,A),A,A,A,A,A,A,C(U),C(U),A,A,A,A,A,A,A,A,A,A,A,A,A,A)><S,U>,
     Unfolding: InlineRule (0, True, True)
                Tensor.Restricted.$fFloatingTensor21 -}
d87e154ad7edb21544b399cf1c30a76d
  $fFloatingTensor_$ctanh ::
    GHC.Float.Floating a =>
    Tensor.Restricted.Tensor a -> Tensor.Restricted.Tensor a
  {- Arity: 2,
     Strictness: <L,U(1*U(A,C(U),A,A),A,A,A,A,A,A,A,A,A,A,A,A,C(U),C(U),A,A,A,A,A,A,A,A)><S,U>,
     Unfolding: InlineRule (0, True, True)
                Tensor.Restricted.$fFloatingTensor14 -}
d87e154ad7edb21544b399cf1c30a76d
  $fFractionalTensor ::
    GHC.Real.Fractional a =>
    GHC.Real.Fractional (Tensor.Restricted.Tensor a)
  DFunId
  {- Arity: 1,
     Strictness: <L,U(U(C(U),C(C1(U)),C(U),A,C(U),C(U),C(U)),C(U),A,C(U))>m,
     Unfolding: DFun: @ a ($dFractional :: GHC.Real.Fractional a).
                  @ (Tensor.Restricted.Tensor a)
                  (Tensor.Restricted.$fFractionalTensor3 @ a $dFractional)
                  (Tensor.Restricted.$fFractionalTensor_$c/ @ a $dFractional)
                  (Tensor.Restricted.$fFractionalTensor_$crecip @ a $dFractional)
                  (Tensor.Restricted.$fFractionalTensor1 @ a $dFractional) -}
d87e154ad7edb21544b399cf1c30a76d
  $fFractionalTensor1 ::
    GHC.Real.Fractional a =>
    GHC.Real.Rational -> Tensor.Restricted.Tensor a
  {- Arity: 2, HasNoCafRefs,
     Strictness: <S(LLLC(S)),1*U(A,A,A,1*C1(U))><S(SS),1*U(U,U)>m1,
     Unfolding: InlineRule (2, True, False)
                (\ @ a
                   ($dFractional :: GHC.Real.Fractional a)
                   (x1 :: GHC.Real.Rational) ->
                 case x1 of x2 { GHC.Real.:% ipv ipv1 ->
                 case GHC.Real.fromRational @ a $dFractional x2 of dt1 { DEFAULT ->
                 Tensor.Restricted.Scalar @ a dt1 } }) -}
d87e154ad7edb21544b399cf1c30a76d
  $fFractionalTensor2 ::
    GHC.Real.Fractional a =>
    Tensor.Restricted.Tensor a -> Tensor.Restricted.Tensor a
  {- Arity: 2,
     Strictness: <S(S(LLLLLLC(S))LLL),U(1*U(A,A,A,A,A,A,1*C1(U)),C(U),A,A)><S,1*U>,
     Unfolding: (\ @ a
                   ($dFractional :: GHC.Real.Fractional a)
                   (eta :: Tensor.Restricted.Tensor a) ->
                 case GHC.Num.fromInteger
                        @ a
                        (GHC.Real.$p1Fractional @ a $dFractional)
                        Tensor.Restricted.$fFloatingTensor7 of dt1 { DEFAULT ->
                 Tensor.Restricted.$fFloatingTensor17
                   @ a
                   $dFractional
                   (Tensor.Restricted.Scalar @ a dt1)
                   eta }) -}
d87e154ad7edb21544b399cf1c30a76d
  $fFractionalTensor3 ::
    GHC.Real.Fractional a => GHC.Num.Num (Tensor.Restricted.Tensor a)
  {- Arity: 1,
     Strictness: <L,1*U(1*U(C(U),C(C1(U)),C(U),A,C(U),C(U),C(U)),A,A,A)>m,
     Unfolding: InlineRule (1, True, False)
                (\ @ a ($dFractional :: GHC.Real.Fractional a) ->
                 Tensor.Restricted.$fNumTensor
                   @ a
                   (GHC.Real.$p1Fractional @ a $dFractional)) -}
d87e154ad7edb21544b399cf1c30a76d
  $fFractionalTensor_$c/ ::
    GHC.Real.Fractional a =>
    Tensor.Restricted.Tensor a
    -> Tensor.Restricted.Tensor a -> Tensor.Restricted.Tensor a
  {- Arity: 3, Strictness: <L,U(A,C(U),A,A)><S,1*U><S,1*U>,
     Unfolding: InlineRule (0, True, True)
                Tensor.Restricted.$fFloatingTensor17 -}
d87e154ad7edb21544b399cf1c30a76d
  $fFractionalTensor_$crecip ::
    GHC.Real.Fractional a =>
    Tensor.Restricted.Tensor a -> Tensor.Restricted.Tensor a
  {- Arity: 2,
     Strictness: <S(S(LLLLLLC(S))LLL),U(1*U(A,A,A,A,A,A,1*C1(U)),C(U),A,A)><S,1*U>,
     Unfolding: InlineRule (0, True, True)
                Tensor.Restricted.$fFractionalTensor2 -}
d87e154ad7edb21544b399cf1c30a76d
  $fFunctorTensor :: GHC.Base.Functor Tensor.Restricted.Tensor
  DFunId
  {- HasNoCafRefs, Strictness: m,
     Unfolding: DFun:.
                  @ Tensor.Restricted.Tensor
                  Tensor.Restricted.$fFloatingTensor27
                  Tensor.Restricted.$fFunctorTensor1 -}
d87e154ad7edb21544b399cf1c30a76d
  $fFunctorTensor1 ::
    a -> Tensor.Restricted.Tensor b -> Tensor.Restricted.Tensor a
  {- Arity: 2, HasNoCafRefs, Strictness: <L,U><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ @ a @ b (eta :: a) (eta1 :: Tensor.Restricted.Tensor b) ->
                 Tensor.Restricted.$fFloatingTensor27
                   @ b
                   @ a
                   (\ (ds2 :: b) -> eta)
                   eta1) -}
d87e154ad7edb21544b399cf1c30a76d
  $fMultilinearTensor ::
    Tensor.Multilinear.Multilinear Tensor.Restricted.Tensor
  DFunId
  {- Unfolding: DFun:.
                  @ Tensor.Restricted.Tensor
                  Tensor.Restricted.$fFunctorTensor
                  Tensor.Restricted.$fMultilinearTensor_$c!!
                  Tensor.Restricted.$fFloatingTensor26
                  Tensor.Restricted.$fMultilinearTensor_$cgenerate
                  Tensor.Restricted.$fMultilinearTensor_$cfromList
                  Tensor.Restricted.$fMultilinearTensor7
                  Tensor.Restricted.$fMultilinearTensor6
                  Tensor.Restricted.commonIndex1
                  Tensor.Restricted.$fMultilinearTensor5
                  Tensor.Restricted.$fMultilinearTensor4
                  Tensor.Restricted.$fMultilinearTensor3
                  Tensor.Restricted.$fMultilinearTensor2
                  Tensor.Restricted.$fMultilinearTensor_$ctranspose1
                  Tensor.Restricted.$fMultilinearTensor_$cconcat
                  Tensor.Restricted.$fMultilinearTensor1 -}
d87e154ad7edb21544b399cf1c30a76d
  $fMultilinearTensor1 ::
    Tensor.Index.TIndex
    -> Tensor.Restricted.Tensor a
    -> Tensor.Restricted.Tensor a
    -> Tensor.Restricted.Tensor a
  {- Arity: 3, HasNoCafRefs, Strictness: <S,1*U><S,1*U><S,1*U>,
     Unfolding: InlineRule (0, True, True)
                Tensor.Restricted.$fMultilinearTensor_$cconcat -}
d87e154ad7edb21544b399cf1c30a76d
  $fMultilinearTensor10 :: Tensor.Restricted.Tensor a
  {- Unfolding: (\ @ a ->
                 case GHC.CString.unpackAppendCString#
                        "(!): "#
                        Tensor.Restricted.indexOutOfRange of dt1 { DEFAULT ->
                 Tensor.Restricted.Err @ a dt1 }) -}
d87e154ad7edb21544b399cf1c30a76d
  $fMultilinearTensor2 ::
    Tensor.Restricted.Tensor a -> Tensor.Restricted.Tensor a
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U> -}
d87e154ad7edb21544b399cf1c30a76d
  $fMultilinearTensor3 ::
    Tensor.Restricted.Tensor a
    -> Tensor.Restricted.Tensor a -> GHC.Types.Bool
  {- Arity: 2, Strictness: <S,1*U><S,1*U>,
     Unfolding: InlineRule (0, True, True)
                Tensor.Restricted.$fMultilinearTensor_$s$dm!==! -}
d87e154ad7edb21544b399cf1c30a76d
  $fMultilinearTensor4 ::
    Tensor.Restricted.Tensor a
    -> Tensor.Restricted.Tensor a -> GHC.Types.Bool
  {- Arity: 2, Strictness: <S,1*U><S,1*U>,
     Unfolding: (\ @ a
                   (t1 :: Tensor.Restricted.Tensor a)
                   (t2 :: Tensor.Restricted.Tensor a) ->
                 case t2 of t4 { DEFAULT ->
                 (Tensor.Restricted.$fMultilinearTensor_go
                    (Tensor.Restricted.commonIndex1 @ a t1)
                    (Tensor.Restricted.commonIndex1 @ a t4))
                   `cast`
                 (Data.Monoid.N:All[0]) }) -}
d87e154ad7edb21544b399cf1c30a76d
  $fMultilinearTensor5 ::
    Tensor.Restricted.Tensor a
    -> GHC.Base.String -> GHC.Base.String -> Tensor.Restricted.Tensor a
  {- Arity: 3, HasNoCafRefs, Strictness: <S,1*U><S,1*U><S,1*U> -}
d87e154ad7edb21544b399cf1c30a76d
  $fMultilinearTensor6 :: Tensor.Restricted.Tensor a -> GHC.Types.Int
  {- Arity: 1, Strictness: <S,1*U>m, Inline: INLINE[0],
     Unfolding: InlineRule (1, True, False)
                (\ @ a (w :: Tensor.Restricted.Tensor a) ->
                 case Tensor.Restricted.$wds @ a w of ww { DEFAULT ->
                 GHC.Types.I# ww }) -}
d87e154ad7edb21544b399cf1c30a76d
  $fMultilinearTensor7 ::
    Tensor.Restricted.Tensor a -> (GHC.Types.Int, GHC.Types.Int)
  {- Arity: 1, Strictness: <S,1*U>m, Inline: INLINE[0],
     Unfolding: InlineRule (1, True, False)
                (\ @ a (w :: Tensor.Restricted.Tensor a) ->
                 case Tensor.Restricted.$wds1 @ a w of ww { (#,#) ww1 ww2 ->
                 (ww1, ww2) }) -}
d87e154ad7edb21544b399cf1c30a76d
  $fMultilinearTensor8 :: Tensor.Restricted.Tensor a
  {- Strictness: m3,
     Unfolding: (\ @ a ->
                 Tensor.Restricted.Err
                   @ a
                   Tensor.Restricted.$fMultilinearTensor9) -}
1556f107dd895e7da78830af7c1bb524
  $fMultilinearTensor9 :: GHC.Base.String
  {- Unfolding: (GHC.CString.unpackCString#
                   "generate: Tensor must contain at leat one element!"#) -}
d87e154ad7edb21544b399cf1c30a76d
  $fMultilinearTensor_$c!! ::
    Tensor.Restricted.Tensor a
    -> GHC.Types.Int -> Tensor.Restricted.Tensor a
  {- Arity: 2, Strictness: <S,1*U><S,1*U(U)>, Inline: INLINE[0],
     Unfolding: InlineRule (2, True, False)
                (\ @ a (w :: Tensor.Restricted.Tensor a) (w1 :: GHC.Types.Int) ->
                 case w1 of ww { GHC.Types.I# ww1 ->
                 Tensor.Restricted.$w$c!! @ a w ww1 }) -}
d87e154ad7edb21544b399cf1c30a76d
  $fMultilinearTensor_$cconcat ::
    Tensor.Index.TIndex
    -> Tensor.Restricted.Tensor a
    -> Tensor.Restricted.Tensor a
    -> Tensor.Restricted.Tensor a
  {- Arity: 3, HasNoCafRefs, Strictness: <S,1*U><S,1*U><S,1*U>,
     Unfolding: InlineRule (3, True, False)
                (\ @ a
                   (ds2 :: Tensor.Index.TIndex)
                   (t1 :: Tensor.Restricted.Tensor a)
                   (ds3 :: Tensor.Restricted.Tensor a) ->
                 case ds2 of ds4 { DEFAULT ->
                 case t1 of t2 { DEFAULT ->
                 case ds3 of ds5 { DEFAULT -> t2 } } }) -}
d87e154ad7edb21544b399cf1c30a76d
  $fMultilinearTensor_$cfromList ::
    Tensor.Index.TIndex -> [a] -> Tensor.Restricted.Tensor a
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>m2,
     Inline: INLINE[0],
     Unfolding: InlineRule (2, True, False)
                (\ @ a (w :: Tensor.Index.TIndex) (w1 :: [a]) ->
                 case Tensor.Restricted.$w$cfromList
                        @ a
                        w
                        w1 of ww { (#,#) ww1 ww2 ->
                 Tensor.Restricted.Tensor @ a ww1 ww2 }) -}
d87e154ad7edb21544b399cf1c30a76d
  $fMultilinearTensor_$cgenerate ::
    Tensor.Index.TIndex
    -> (GHC.Types.Int -> Tensor.Restricted.Tensor a)
    -> Tensor.Restricted.Tensor a
  {- Arity: 2, Strictness: <S,1*U><S,1*U>,
     Unfolding: (\ @ a
                   (index :: Tensor.Index.TIndex)
                   (f :: GHC.Types.Int -> Tensor.Restricted.Tensor a) ->
                 case f of f1 { DEFAULT ->
                 let {
                   $j :: GHC.Prim.Void# -> Tensor.Restricted.Tensor a
                     {- Arity: 1, Strictness: <L,A> -}
                   = \ (w :: GHC.Prim.Void#)[OneShot] ->
                     let {
                       $j1 :: GHC.Prim.Int# -> [Tensor.Restricted.Tensor a]
                         {- Arity: 1, Strictness: <S,U> -}
                       = \ (y :: GHC.Prim.Int#)[OneShot] ->
                         case GHC.Prim.tagToEnum#
                                @ GHC.Types.Bool
                                (GHC.Prim.># 1# y) of wild {
                           GHC.Types.False
                           -> letrec {
                                go2 :: GHC.Prim.Int# -> [Tensor.Restricted.Tensor a]
                                  {- Arity: 1, Strictness: <L,U> -}
                                = \ (x1 :: GHC.Prim.Int#) ->
                                  GHC.Types.:
                                    @ (Tensor.Restricted.Tensor a)
                                    (f1 (GHC.Types.I# x1))
                                    (case GHC.Prim.tagToEnum#
                                            @ GHC.Types.Bool
                                            (GHC.Prim.==# x1 y) of wild1 {
                                       GHC.Types.False -> go2 (GHC.Prim.+# x1 1#)
                                       GHC.Types.True
                                       -> GHC.Types.[] @ (Tensor.Restricted.Tensor a) })
                              } in
                              go2 1#
                           GHC.Types.True -> GHC.Types.[] @ (Tensor.Restricted.Tensor a) }
                     } in
                     case case index of wild {
                            Tensor.Index.Covariant dt1 ds2 -> $j1 dt1
                            Tensor.Index.Contravariant dt1 ds2 -> $j1 dt1
                            Tensor.Index.Indifferent dt1 ds2 -> $j1 dt1 } of dt1 { DEFAULT ->
                     Tensor.Restricted.Tensor @ a index dt1 }
                 } in
                 case index of wild {
                   Tensor.Index.Covariant dt1 ds2
                   -> case GHC.Prim.tagToEnum#
                             @ GHC.Types.Bool
                             (GHC.Prim.># dt1 0#) of wild1 {
                        GHC.Types.False -> Tensor.Restricted.$fMultilinearTensor8 @ a
                        GHC.Types.True -> $j GHC.Prim.void# }
                   Tensor.Index.Contravariant dt1 ds2
                   -> case GHC.Prim.tagToEnum#
                             @ GHC.Types.Bool
                             (GHC.Prim.># dt1 0#) of wild1 {
                        GHC.Types.False -> Tensor.Restricted.$fMultilinearTensor8 @ a
                        GHC.Types.True -> $j GHC.Prim.void# }
                   Tensor.Index.Indifferent dt1 ds2
                   -> case GHC.Prim.tagToEnum#
                             @ GHC.Types.Bool
                             (GHC.Prim.># dt1 0#) of wild1 {
                        GHC.Types.False -> Tensor.Restricted.$fMultilinearTensor8 @ a
                        GHC.Types.True -> $j GHC.Prim.void# } } }) -}
d87e154ad7edb21544b399cf1c30a76d
  $fMultilinearTensor_$ctranspose1 ::
    Tensor.Restricted.Tensor a -> Tensor.Restricted.Tensor a
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U>,
     Unfolding: (\ @ a (ds2 :: Tensor.Restricted.Tensor a) ->
                 case ds2 of wild {
                   DEFAULT -> wild
                   Tensor.Restricted.Tensor ds3 ts
                   -> case ds3 of wild1 {
                        Tensor.Index.Covariant dt1 name
                        -> Tensor.Restricted.Tensor
                             @ a
                             (Tensor.Index.Contravariant dt1 name)
                             ts
                        Tensor.Index.Contravariant dt1 name
                        -> Tensor.Restricted.Tensor
                             @ a
                             (Tensor.Index.Covariant dt1 name)
                             ts
                        Tensor.Index.Indifferent dt1 name -> wild } }) -}
d87e154ad7edb21544b399cf1c30a76d
  $fMultilinearTensor_$s$dm!==! ::
    Tensor.Restricted.Tensor a
    -> Tensor.Restricted.Tensor a -> GHC.Types.Bool
  {- Arity: 2, Strictness: <S,1*U><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ @ a
                   (t1 :: Tensor.Restricted.Tensor a)
                   (t2 :: Tensor.Restricted.Tensor a) ->
                 case t1 of t4 { DEFAULT ->
                 case t2 of t5 { DEFAULT ->
                 Tensor.Restricted.$fMultilinearTensor4 @ a t4 t5 } }) -}
f4c6cbf813ca1936325a254cae6cf492
  $fMultilinearTensor_go ::
    [Tensor.Index.TIndex] -> [Tensor.Index.TIndex] -> Data.Monoid.All
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><L,1*U> -}
d87e154ad7edb21544b399cf1c30a76d
  $fNumTensor ::
    GHC.Num.Num a => GHC.Num.Num (Tensor.Restricted.Tensor a)
  DFunId
  {- Arity: 1,
     Strictness: <L,U(C(U),C(C1(U)),C(U),A,C(U),C(U),C(U))>m,
     Unfolding: DFun: @ a ($dNum :: GHC.Num.Num a).
                  @ (Tensor.Restricted.Tensor a)
                  (Tensor.Restricted.$fNumTensor_$c+ @ a $dNum)
                  (Tensor.Restricted.$fNumTensor_$c- @ a $dNum)
                  (Tensor.Restricted.$fFloatingTensor26 @ a $dNum)
                  (Tensor.Restricted.$fNumTensor_$cnegate @ a $dNum)
                  (Tensor.Restricted.$fNumTensor_$cabs @ a $dNum)
                  (Tensor.Restricted.$fNumTensor_$csignum @ a $dNum)
                  (Tensor.Restricted.$fNumTensor1 @ a $dNum) -}
d87e154ad7edb21544b399cf1c30a76d
  $fNumTensor1 ::
    GHC.Num.Num a =>
    GHC.Integer.Type.Integer -> Tensor.Restricted.Tensor a
  {- Arity: 2, HasNoCafRefs,
     Strictness: <S(LLLLLLC(S)),1*U(A,A,A,A,A,A,1*C1(U))><S,1*U>m1,
     Unfolding: InlineRule (2, True, False)
                (\ @ a ($dNum :: GHC.Num.Num a) (x1 :: GHC.Integer.Type.Integer) ->
                 case x1 of x2 { DEFAULT ->
                 case GHC.Num.fromInteger @ a $dNum x2 of dt1 { DEFAULT ->
                 Tensor.Restricted.Scalar @ a dt1 } }) -}
d87e154ad7edb21544b399cf1c30a76d
  $fNumTensor2 ::
    GHC.Num.Num a =>
    Tensor.Restricted.Tensor a -> Tensor.Restricted.Tensor a
  {- Arity: 2, HasNoCafRefs,
     Strictness: <L,U(A,A,A,A,A,C(U),A)><S,1*U> -}
d87e154ad7edb21544b399cf1c30a76d
  $fNumTensor3 ::
    GHC.Num.Num a =>
    Tensor.Restricted.Tensor a -> Tensor.Restricted.Tensor a
  {- Arity: 2, HasNoCafRefs,
     Strictness: <L,U(A,A,A,A,C(U),A,A)><S,1*U> -}
d87e154ad7edb21544b399cf1c30a76d
  $fNumTensor4 ::
    GHC.Num.Num a =>
    Tensor.Restricted.Tensor a -> Tensor.Restricted.Tensor a
  {- Arity: 2,
     Strictness: <S(LLLLLLC(S)),U(A,C(C1(U)),A,A,A,A,1*C1(U))><S,1*U>,
     Unfolding: (\ @ a
                   ($dNum :: GHC.Num.Num a)
                   (eta :: Tensor.Restricted.Tensor a) ->
                 case GHC.Num.fromInteger
                        @ a
                        $dNum
                        Tensor.Restricted.$fFloatingTensor8 of dt1 { DEFAULT ->
                 Tensor.Restricted.$fFloatingTensor3
                   @ a
                   $dNum
                   (Tensor.Restricted.Scalar @ a dt1)
                   eta }) -}
d87e154ad7edb21544b399cf1c30a76d
  $fNumTensor_$c+ ::
    GHC.Num.Num a =>
    Tensor.Restricted.Tensor a
    -> Tensor.Restricted.Tensor a -> Tensor.Restricted.Tensor a
  {- Arity: 3, Strictness: <L,U(C(U),A,A,A,A,A,A)><S,1*U><S,1*U>,
     Unfolding: InlineRule (0, True, True)
                Tensor.Restricted.$fFloatingTensor5 -}
d87e154ad7edb21544b399cf1c30a76d
  $fNumTensor_$c- ::
    GHC.Num.Num a =>
    Tensor.Restricted.Tensor a
    -> Tensor.Restricted.Tensor a -> Tensor.Restricted.Tensor a
  {- Arity: 3, Strictness: <L,U(A,C(C1(U)),A,A,A,A,A)><S,1*U><S,1*U>,
     Unfolding: InlineRule (0, True, True)
                Tensor.Restricted.$fFloatingTensor3 -}
d87e154ad7edb21544b399cf1c30a76d
  $fNumTensor_$cabs ::
    GHC.Num.Num a =>
    Tensor.Restricted.Tensor a -> Tensor.Restricted.Tensor a
  {- Arity: 2, HasNoCafRefs,
     Strictness: <L,U(A,A,A,A,C(U),A,A)><S,1*U>,
     Unfolding: InlineRule (0, True, True)
                Tensor.Restricted.$fNumTensor3 -}
d87e154ad7edb21544b399cf1c30a76d
  $fNumTensor_$cnegate ::
    GHC.Num.Num a =>
    Tensor.Restricted.Tensor a -> Tensor.Restricted.Tensor a
  {- Arity: 2,
     Strictness: <S(LLLLLLC(S)),U(A,C(C1(U)),A,A,A,A,1*C1(U))><S,1*U>,
     Unfolding: InlineRule (0, True, True)
                Tensor.Restricted.$fNumTensor4 -}
d87e154ad7edb21544b399cf1c30a76d
  $fNumTensor_$csignum ::
    GHC.Num.Num a =>
    Tensor.Restricted.Tensor a -> Tensor.Restricted.Tensor a
  {- Arity: 2, HasNoCafRefs,
     Strictness: <L,U(A,A,A,A,A,C(U),A)><S,1*U>,
     Unfolding: InlineRule (0, True, True)
                Tensor.Restricted.$fNumTensor2 -}
d87e154ad7edb21544b399cf1c30a76d
  $fShowTensor ::
    GHC.Show.Show a => GHC.Show.Show (Tensor.Restricted.Tensor a)
  DFunId
  {- Arity: 1, Strictness: <L,U(A,C(U),A)>m,
     Unfolding: DFun: @ a ($dShow :: GHC.Show.Show a).
                  @ (Tensor.Restricted.Tensor a)
                  (Tensor.Restricted.$fShowTensor_$cshowsPrec @ a $dShow)
                  (Tensor.Restricted.$fShowTensor_$cshow @ a $dShow)
                  (Tensor.Restricted.$fShowTensor_$cshowList @ a $dShow) -}
d87e154ad7edb21544b399cf1c30a76d
  $fShowTensor1 ::
    GHC.Show.Show a => [Tensor.Restricted.Tensor a] -> GHC.Show.ShowS
  {- Arity: 3, Strictness: <L,U(A,C(U),A)><S,1*U><L,U>,
     Unfolding: (\ @ a
                   ($dShow :: GHC.Show.Show a)
                   (ls :: [Tensor.Restricted.Tensor a])
                   (s :: GHC.Base.String) ->
                 GHC.Show.showList__
                   @ (Tensor.Restricted.Tensor a)
                   (\ (x1 :: Tensor.Restricted.Tensor a)
                      (s1 :: GHC.Base.String)[OneShot] ->
                    GHC.Base.++
                      @ GHC.Types.Char
                      (Tensor.Restricted.$fShowTensor2 @ a $dShow x1)
                      s1)
                   ls
                   s) -}
d87e154ad7edb21544b399cf1c30a76d
  $fShowTensor2 ::
    GHC.Show.Show a => Tensor.Restricted.Tensor a -> GHC.Base.String
  {- Arity: 2, Strictness: <L,U(A,C(U),A)><S,1*U> -}
d87e154ad7edb21544b399cf1c30a76d
  $fShowTensor3 ::
    GHC.Show.Show a =>
    GHC.Types.Int -> Tensor.Restricted.Tensor a -> GHC.Show.ShowS
  {- Arity: 4, Strictness: <L,U(A,C(U),A)><L,A><S,1*U><L,1*U>,
     Unfolding: InlineRule (4, True, False)
                (\ @ a
                   ($dShow :: GHC.Show.Show a)
                   (ds2 :: GHC.Types.Int)
                   (x1 :: Tensor.Restricted.Tensor a)
                   (s :: GHC.Base.String) ->
                 GHC.Base.augment
                   @ GHC.Types.Char
                   (\ @ b
                      (c :: GHC.Types.Char -> b -> b)[OneShot]
                      (n :: b)[OneShot] ->
                    GHC.Base.foldr
                      @ GHC.Types.Char
                      @ b
                      c
                      n
                      (Tensor.Restricted.$fShowTensor2 @ a $dShow x1))
                   s) -}
d87e154ad7edb21544b399cf1c30a76d
  $fShowTensor_$cshow ::
    GHC.Show.Show a => Tensor.Restricted.Tensor a -> GHC.Base.String
  {- Arity: 2, Strictness: <L,U(A,C(U),A)><S,1*U>,
     Unfolding: InlineRule (0, True, True)
                Tensor.Restricted.$fShowTensor2 -}
d87e154ad7edb21544b399cf1c30a76d
  $fShowTensor_$cshowList ::
    GHC.Show.Show a => [Tensor.Restricted.Tensor a] -> GHC.Show.ShowS
  {- Arity: 3, Strictness: <L,U(A,C(U),A)><S,1*U><L,U>,
     Unfolding: InlineRule (0, True, True)
                Tensor.Restricted.$fShowTensor1 -}
d87e154ad7edb21544b399cf1c30a76d
  $fShowTensor_$cshowsPrec ::
    GHC.Show.Show a =>
    GHC.Types.Int -> Tensor.Restricted.Tensor a -> GHC.Show.ShowS
  {- Arity: 4, Strictness: <L,U(A,C(U),A)><L,A><S,1*U><L,1*U>,
     Unfolding: InlineRule (0, True, True)
                Tensor.Restricted.$fShowTensor3 -}
ce5310616cd164d96b50b8004a7f8463
  $tc'Err :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   1848752219878878379##
                   13417166131268378417##
                   Tensor.Restricted.$trModule
                   Tensor.Restricted.$tc'Err1) -}
e5b4a7ad2d5452efdff3c46076d4981b
  $tc'Err1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "'Err"#) -}
0ddb0d0f1e5d685883f85bfdbd6b608a
  $tc'Scalar :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   1427787049303785293##
                   4163579772116192252##
                   Tensor.Restricted.$trModule
                   Tensor.Restricted.$tc'Scalar1) -}
267019e1371ae787164787e5f5e12969
  $tc'Scalar1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "'Scalar"#) -}
9a20b260340a2787fcb7a760bd50f035
  $tc'Tensor :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   16669137873843754194##
                   8302181846300601936##
                   Tensor.Restricted.$trModule
                   Tensor.Restricted.$tc'Tensor1) -}
6bbb328b40dfb160e9a3290995e6550a
  $tc'Tensor1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "'Tensor"#) -}
6e760691aaac73f4857594eff7f0bf86
  $tcTensor :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   7539650681459429837##
                   9707602141204626817##
                   Tensor.Restricted.$trModule
                   Tensor.Restricted.$tcTensor1) -}
b6a627351f8368de5fbf5f73ba9c588d
  $tcTensor1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "Tensor"#) -}
21ae577d0294d1bd150a369706e67ed4
  $trModule :: GHC.Types.Module
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.Module
                   Tensor.Restricted.$trModule2
                   Tensor.Restricted.$trModule1) -}
4ca145591a267abf9feee43736f6d4f8
  $trModule1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "Tensor.Restricted"#) -}
82fa42bd9e1d1b8d6084f766ad690626
  $trModule2 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS
                   "Tensor-0.1.0.0-1EOex3vvt9xIu9Nz1rXDxl"#) -}
d87e154ad7edb21544b399cf1c30a76d
  $w$c!! ::
    Tensor.Restricted.Tensor a
    -> GHC.Prim.Int# -> Tensor.Restricted.Tensor a
  {- Arity: 2, Strictness: <S,1*U><L,U>, Inline: [0],
     Unfolding: (\ @ a
                   (w :: Tensor.Restricted.Tensor a)
                   (ww :: GHC.Prim.Int#) ->
                 case w of wild {
                   Tensor.Restricted.Scalar ds2
                   -> Tensor.Restricted.$fMultilinearTensor10 @ a
                   Tensor.Restricted.Tensor index1 ts1
                   -> case index1 of wild1 {
                        Tensor.Index.Covariant dt1 ds2
                        -> case GHC.Prim.tagToEnum#
                                  @ GHC.Types.Bool
                                  (GHC.Prim.>=# ww dt1) of wild2 {
                             GHC.Types.False
                             -> GHC.List.$w!! @ (Tensor.Restricted.Tensor a) ts1 ww
                             GHC.Types.True -> Tensor.Restricted.$fMultilinearTensor10 @ a }
                        Tensor.Index.Contravariant dt1 ds2
                        -> case GHC.Prim.tagToEnum#
                                  @ GHC.Types.Bool
                                  (GHC.Prim.>=# ww dt1) of wild2 {
                             GHC.Types.False
                             -> GHC.List.$w!! @ (Tensor.Restricted.Tensor a) ts1 ww
                             GHC.Types.True -> Tensor.Restricted.$fMultilinearTensor10 @ a }
                        Tensor.Index.Indifferent dt1 ds2
                        -> case GHC.Prim.tagToEnum#
                                  @ GHC.Types.Bool
                                  (GHC.Prim.>=# ww dt1) of wild2 {
                             GHC.Types.False
                             -> GHC.List.$w!! @ (Tensor.Restricted.Tensor a) ts1 ww
                             GHC.Types.True -> Tensor.Restricted.$fMultilinearTensor10 @ a } }
                   Tensor.Restricted.Err msg -> wild }) -}
d87e154ad7edb21544b399cf1c30a76d
  $w$cfromList ::
    Tensor.Index.TIndex
    -> [a] -> (# Tensor.Index.TIndex, [Tensor.Restricted.Tensor a] #)
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>, Inline: [0],
     Unfolding: (\ @ a (w :: Tensor.Index.TIndex) (w1 :: [a]) ->
                 case w of wild {
                   Tensor.Index.Covariant dt1 name
                   -> case GHC.List.$wlenAcc @ a w1 0# of ww2 { DEFAULT ->
                      case GHC.Base.map
                             @ a
                             @ (Tensor.Restricted.Tensor a)
                             (Tensor.Restricted.$WScalar @ a)
                             w1 of dt2 { DEFAULT ->
                      (# Tensor.Index.Covariant ww2 name, dt2 #) } }
                   Tensor.Index.Contravariant dt1 name
                   -> case GHC.List.$wlenAcc @ a w1 0# of ww2 { DEFAULT ->
                      case GHC.Base.map
                             @ a
                             @ (Tensor.Restricted.Tensor a)
                             (Tensor.Restricted.$WScalar @ a)
                             w1 of dt2 { DEFAULT ->
                      (# Tensor.Index.Contravariant ww2 name, dt2 #) } }
                   Tensor.Index.Indifferent dt1 name
                   -> case GHC.List.$wlenAcc @ a w1 0# of ww2 { DEFAULT ->
                      case GHC.Base.map
                             @ a
                             @ (Tensor.Restricted.Tensor a)
                             (Tensor.Restricted.$WScalar @ a)
                             w1 of dt2 { DEFAULT ->
                      (# Tensor.Index.Indifferent ww2 name, dt2 #) } } }) -}
d87e154ad7edb21544b399cf1c30a76d
  $w$cput ::
    Data.Binary.Class.Binary a =>
    Tensor.Restricted.Tensor a
    -> (# (), Data.ByteString.Builder.Internal.Builder #)
  {- Arity: 2, Strictness: <L,U(C(U(U,U)),U,A)><S,1*U>, Inline: [0],
     Unfolding: (\ @ a
                   (w :: Data.Binary.Class.Binary a)
                   (w1 :: Tensor.Restricted.Tensor a) ->
                 case w1 of wild {
                   Tensor.Restricted.Scalar x1
                   -> let {
                        ds2 :: Data.Binary.Put.Put = Data.Binary.Class.put @ a w x1
                      } in
                      (# case ds2
                                `cast`
                              (Data.Binary.Put.N:PutM[0] <()>_N) of wild1 { Data.Binary.Put.PairS b1 w' ->
                         b1 },
                         (\ @ r (eta :: Data.ByteString.Builder.Internal.BuildStep r) ->
                          let {
                            eta1 :: Data.ByteString.Builder.Internal.BuildStep r
                            = case ds2
                                     `cast`
                                   (Data.Binary.Put.N:PutM[0] <()>_N) of wild1 { Data.Binary.Put.PairS b1 w' ->
                              w' `cast` (Data.ByteString.Builder.Internal.N:Builder[0]) @ r eta }
                          } in
                          let {
                            lvl9 :: Data.ByteString.Builder.Internal.BufferRange
                                    -> GHC.Prim.State# GHC.Prim.RealWorld
                                    -> (# GHC.Prim.State# GHC.Prim.RealWorld,
                                          Data.ByteString.Builder.Internal.BuildSignal r #)
                              {- Arity: 2 -}
                            = \ (ds3 :: Data.ByteString.Builder.Internal.BufferRange)
                                (eta3 :: GHC.Prim.State# GHC.Prim.RealWorld)[OneShot] ->
                              case ds3 of wild3 { Data.ByteString.Builder.Internal.BufferRange dt3 dt4 ->
                              case GHC.Prim.writeWord8OffAddr#
                                     @ GHC.Prim.RealWorld
                                     dt3
                                     0#
                                     0##
                                     eta3 of s2 { DEFAULT ->
                              (eta1
                                 (Data.ByteString.Builder.Internal.BufferRange
                                    (GHC.Prim.plusAddr# dt3 1#)
                                    dt4))
                                `cast`
                              (GHC.Types.N:IO[0]
                                   <Data.ByteString.Builder.Internal.BuildSignal r>_R)
                                s2 } }
                          } in
                          \ (eta2 :: Data.ByteString.Builder.Internal.BufferRange)
                            (eta3 :: GHC.Prim.State# GHC.Prim.RealWorld)[OneShot] ->
                          case eta2 of wild1 { Data.ByteString.Builder.Internal.BufferRange dt1 dt2 ->
                          case GHC.Prim.tagToEnum#
                                 @ GHC.Types.Bool
                                 (GHC.Prim.<# (GHC.Prim.minusAddr# dt2 dt1) 1#) of wild2 {
                            GHC.Types.False
                            -> case GHC.Prim.writeWord8OffAddr#
                                      @ GHC.Prim.RealWorld
                                      dt1
                                      0#
                                      0##
                                      eta3 of s2 { DEFAULT ->
                               (eta1
                                  (Data.ByteString.Builder.Internal.BufferRange
                                     (GHC.Prim.plusAddr# dt1 1#)
                                     dt2))
                                 `cast`
                               (GHC.Types.N:IO[0]
                                    <Data.ByteString.Builder.Internal.BuildSignal r>_R)
                                 s2 }
                            GHC.Types.True
                            -> (# eta3,
                                  Data.ByteString.Builder.Internal.BufferFull
                                    @ r
                                    1#
                                    dt1
                                    lvl9
                                      `cast`
                                    (<Data.ByteString.Builder.Internal.BufferRange>_R
                                     ->_R Sym (GHC.Types.N:IO[0]
                                                   <Data.ByteString.Builder.Internal.BuildSignal
                                                      r>_R)) #) } })
                           `cast`
                         (Trans
                              (forall (r :: <*>_N).
                               <Data.ByteString.Builder.Internal.BuildStep r>_R
                               ->_R <Data.ByteString.Builder.Internal.BufferRange>_R
                               ->_R Sym (GHC.Types.N:IO[0]
                                             <Data.ByteString.Builder.Internal.BuildSignal r>_R))
                              (Sym (Data.ByteString.Builder.Internal.N:Builder[0]))) #)
                   Tensor.Restricted.Tensor ind ts
                   -> let {
                        ds2 :: Data.Binary.Put.Put
                        = Tensor.Restricted.$fBinaryTensor1 @ a w ts
                      } in
                      (# case ds2
                                `cast`
                              (Data.Binary.Put.N:PutM[0] <()>_N) of wild1 { Data.Binary.Put.PairS b1 w' ->
                         b1 },
                         let {
                           ds3 :: Data.ByteString.Builder.Internal.Builder
                           = case Tensor.Index.$w$cput ind of ww { (#,#) ww1 ww2 -> ww2 }
                         } in
                         (\ @ r (eta :: Data.ByteString.Builder.Internal.BuildStep r) ->
                          let {
                            eta1 :: Data.ByteString.Builder.Internal.BuildStep r
                            = ds3 `cast` (Data.ByteString.Builder.Internal.N:Builder[0])
                                @ r
                                (case ds2
                                        `cast`
                                      (Data.Binary.Put.N:PutM[0] <()>_N) of wild1 { Data.Binary.Put.PairS b1 w' ->
                                 w' `cast` (Data.ByteString.Builder.Internal.N:Builder[0])
                                   @ r
                                   eta })
                          } in
                          let {
                            lvl9 :: Data.ByteString.Builder.Internal.BufferRange
                                    -> GHC.Prim.State# GHC.Prim.RealWorld
                                    -> (# GHC.Prim.State# GHC.Prim.RealWorld,
                                          Data.ByteString.Builder.Internal.BuildSignal r #)
                              {- Arity: 2 -}
                            = \ (ds4 :: Data.ByteString.Builder.Internal.BufferRange)
                                (eta3 :: GHC.Prim.State# GHC.Prim.RealWorld)[OneShot] ->
                              case ds4 of wild3 { Data.ByteString.Builder.Internal.BufferRange dt3 dt4 ->
                              case GHC.Prim.writeWord8OffAddr#
                                     @ GHC.Prim.RealWorld
                                     dt3
                                     0#
                                     1##
                                     eta3 of s2 { DEFAULT ->
                              (eta1
                                 (Data.ByteString.Builder.Internal.BufferRange
                                    (GHC.Prim.plusAddr# dt3 1#)
                                    dt4))
                                `cast`
                              (GHC.Types.N:IO[0]
                                   <Data.ByteString.Builder.Internal.BuildSignal r>_R)
                                s2 } }
                          } in
                          \ (eta2 :: Data.ByteString.Builder.Internal.BufferRange)
                            (eta3 :: GHC.Prim.State# GHC.Prim.RealWorld)[OneShot] ->
                          case eta2 of wild1 { Data.ByteString.Builder.Internal.BufferRange dt1 dt2 ->
                          case GHC.Prim.tagToEnum#
                                 @ GHC.Types.Bool
                                 (GHC.Prim.<# (GHC.Prim.minusAddr# dt2 dt1) 1#) of wild2 {
                            GHC.Types.False
                            -> case GHC.Prim.writeWord8OffAddr#
                                      @ GHC.Prim.RealWorld
                                      dt1
                                      0#
                                      1##
                                      eta3 of s2 { DEFAULT ->
                               (eta1
                                  (Data.ByteString.Builder.Internal.BufferRange
                                     (GHC.Prim.plusAddr# dt1 1#)
                                     dt2))
                                 `cast`
                               (GHC.Types.N:IO[0]
                                    <Data.ByteString.Builder.Internal.BuildSignal r>_R)
                                 s2 }
                            GHC.Types.True
                            -> (# eta3,
                                  Data.ByteString.Builder.Internal.BufferFull
                                    @ r
                                    1#
                                    dt1
                                    lvl9
                                      `cast`
                                    (<Data.ByteString.Builder.Internal.BufferRange>_R
                                     ->_R Sym (GHC.Types.N:IO[0]
                                                   <Data.ByteString.Builder.Internal.BuildSignal
                                                      r>_R)) #) } })
                           `cast`
                         (Trans
                              (forall (r :: <*>_N).
                               <Data.ByteString.Builder.Internal.BuildStep r>_R
                               ->_R <Data.ByteString.Builder.Internal.BufferRange>_R
                               ->_R Sym (GHC.Types.N:IO[0]
                                             <Data.ByteString.Builder.Internal.BuildSignal r>_R))
                              (Sym (Data.ByteString.Builder.Internal.N:Builder[0]))) #)
                   Tensor.Restricted.Err msg
                   -> let {
                        ds2 :: Data.Binary.Put.PairS ()
                        = case Data.Binary.Class.$w$cputList msg of ww { (#,#) ww1 ww2 ->
                          Data.Binary.Put.PairS @ () ww1 ww2 }
                      } in
                      (# case ds2 of wild1 { Data.Binary.Put.PairS b1 w' -> b1 },
                         (\ @ r (eta :: Data.ByteString.Builder.Internal.BuildStep r) ->
                          let {
                            eta1 :: Data.ByteString.Builder.Internal.BuildStep r
                            = case ds2 of wild1 { Data.Binary.Put.PairS b1 w' ->
                              w' `cast` (Data.ByteString.Builder.Internal.N:Builder[0]) @ r eta }
                          } in
                          let {
                            lvl9 :: Data.ByteString.Builder.Internal.BufferRange
                                    -> GHC.Prim.State# GHC.Prim.RealWorld
                                    -> (# GHC.Prim.State# GHC.Prim.RealWorld,
                                          Data.ByteString.Builder.Internal.BuildSignal r #)
                              {- Arity: 2 -}
                            = \ (ds3 :: Data.ByteString.Builder.Internal.BufferRange)
                                (eta3 :: GHC.Prim.State# GHC.Prim.RealWorld)[OneShot] ->
                              case ds3 of wild3 { Data.ByteString.Builder.Internal.BufferRange dt3 dt4 ->
                              case GHC.Prim.writeWord8OffAddr#
                                     @ GHC.Prim.RealWorld
                                     dt3
                                     0#
                                     2##
                                     eta3 of s2 { DEFAULT ->
                              (eta1
                                 (Data.ByteString.Builder.Internal.BufferRange
                                    (GHC.Prim.plusAddr# dt3 1#)
                                    dt4))
                                `cast`
                              (GHC.Types.N:IO[0]
                                   <Data.ByteString.Builder.Internal.BuildSignal r>_R)
                                s2 } }
                          } in
                          \ (eta2 :: Data.ByteString.Builder.Internal.BufferRange)
                            (eta3 :: GHC.Prim.State# GHC.Prim.RealWorld)[OneShot] ->
                          case eta2 of wild1 { Data.ByteString.Builder.Internal.BufferRange dt1 dt2 ->
                          case GHC.Prim.tagToEnum#
                                 @ GHC.Types.Bool
                                 (GHC.Prim.<# (GHC.Prim.minusAddr# dt2 dt1) 1#) of wild2 {
                            GHC.Types.False
                            -> case GHC.Prim.writeWord8OffAddr#
                                      @ GHC.Prim.RealWorld
                                      dt1
                                      0#
                                      2##
                                      eta3 of s2 { DEFAULT ->
                               (eta1
                                  (Data.ByteString.Builder.Internal.BufferRange
                                     (GHC.Prim.plusAddr# dt1 1#)
                                     dt2))
                                 `cast`
                               (GHC.Types.N:IO[0]
                                    <Data.ByteString.Builder.Internal.BuildSignal r>_R)
                                 s2 }
                            GHC.Types.True
                            -> (# eta3,
                                  Data.ByteString.Builder.Internal.BufferFull
                                    @ r
                                    1#
                                    dt1
                                    lvl9
                                      `cast`
                                    (<Data.ByteString.Builder.Internal.BufferRange>_R
                                     ->_R Sym (GHC.Types.N:IO[0]
                                                   <Data.ByteString.Builder.Internal.BuildSignal
                                                      r>_R)) #) } })
                           `cast`
                         (Trans
                              (forall (r :: <*>_N).
                               <Data.ByteString.Builder.Internal.BuildStep r>_R
                               ->_R <Data.ByteString.Builder.Internal.BufferRange>_R
                               ->_R Sym (GHC.Types.N:IO[0]
                                             <Data.ByteString.Builder.Internal.BuildSignal r>_R))
                              (Sym (Data.ByteString.Builder.Internal.N:Builder[0]))) #) }) -}
d87e154ad7edb21544b399cf1c30a76d
  $wds :: Tensor.Restricted.Tensor a -> GHC.Prim.Int#
  {- Arity: 1, Strictness: <S,1*U>, Inline: [0] -}
d87e154ad7edb21544b399cf1c30a76d
  $wds1 ::
    Tensor.Restricted.Tensor a -> (# GHC.Types.Int, GHC.Types.Int #)
  {- Arity: 1, Strictness: <S,1*U>, Inline: [0] -}
11391534c2f4310c4b29ca4f990ff346
  $wkr ::
    GHC.Num.Num a => GHC.Prim.Int# -> Tensor.Restricted.Tensor a
  {- Arity: 2, Strictness: <L,U(A,A,A,A,A,A,C(U))><S,U>, Inline: [0],
     Unfolding: (\ @ a (w :: GHC.Num.Num a) (ww :: GHC.Prim.Int#) ->
                 case Tensor.Restricted.kr2 of dt1 { DEFAULT ->
                 let {
                   lvl9 :: Tensor.Index.TIndex
                   = case Tensor.Restricted.kr1 of dt2 { DEFAULT ->
                     Tensor.Index.Covariant ww dt2 }
                 } in
                 let {
                   lvl10 :: a
                   = GHC.Num.fromInteger @ a w Tensor.Restricted.$fFloatingTensor8
                 } in
                 let {
                   lvl11 :: a
                   = GHC.Num.fromInteger @ a w Tensor.Restricted.$fFloatingTensor7
                 } in
                 Tensor.Restricted.$fMultilinearTensor_$cgenerate
                   @ a
                   (Tensor.Index.Covariant ww dt1)
                   (\ (i :: GHC.Types.Int) ->
                    case i of i1 { GHC.Types.I# ipv ->
                    Tensor.Restricted.$fMultilinearTensor_$cgenerate
                      @ a
                      lvl9
                      (\ (j :: GHC.Types.Int) ->
                       case j of j1 { GHC.Types.I# ipv1 ->
                       case case GHC.Prim.tagToEnum#
                                   @ GHC.Types.Bool
                                   (GHC.Prim.==# ipv ipv1) of wild {
                              GHC.Types.False -> lvl10
                              GHC.Types.True -> lvl11 } of dt2 { DEFAULT ->
                       Tensor.Restricted.Scalar @ a dt2 } }) }) }) -}
da817b15b4aecf394400ed4fc869e198
  $wkr3 ::
    GHC.Num.Num a => GHC.Prim.Int# -> Tensor.Restricted.Tensor a
  {- Arity: 2, Strictness: <L,U(A,A,A,A,A,A,C(U))><S,U>, Inline: [0],
     Unfolding: (\ @ a (w :: GHC.Num.Num a) (ww :: GHC.Prim.Int#) ->
                 case Tensor.Restricted.kr2 of dt1 { DEFAULT ->
                 let {
                   lvl9 :: Tensor.Index.TIndex
                   = case Tensor.Restricted.kr1 of dt2 { DEFAULT ->
                     Tensor.Index.Covariant ww dt2 }
                 } in
                 let {
                   lvl10 :: Tensor.Index.TIndex
                   = case Tensor.Restricted.kr6 of dt2 { DEFAULT ->
                     Tensor.Index.Covariant ww dt2 }
                 } in
                 let {
                   lvl11 :: a
                   = GHC.Num.fromInteger @ a w Tensor.Restricted.$fFloatingTensor8
                 } in
                 let {
                   lvl12 :: a
                   = GHC.Num.fromInteger @ a w Tensor.Restricted.$fFloatingTensor7
                 } in
                 Tensor.Restricted.$fMultilinearTensor_$cgenerate
                   @ a
                   (Tensor.Index.Covariant ww dt1)
                   (\ (i :: GHC.Types.Int) ->
                    case i of i1 { GHC.Types.I# ipv ->
                    Tensor.Restricted.$fMultilinearTensor_$cgenerate
                      @ a
                      lvl9
                      (\ (j :: GHC.Types.Int) ->
                       case j of j1 { GHC.Types.I# ipv1 ->
                       let {
                         lvl13 :: GHC.Types.Bool
                         = GHC.Prim.tagToEnum# @ GHC.Types.Bool (GHC.Prim.==# ipv ipv1)
                       } in
                       Tensor.Restricted.$fMultilinearTensor_$cgenerate
                         @ a
                         lvl10
                         (\ (k :: GHC.Types.Int) ->
                          case k of k1 { GHC.Types.I# ipv2 ->
                          case case lvl13 of wild {
                                 GHC.Types.False -> lvl11
                                 GHC.Types.True
                                 -> case GHC.Prim.tagToEnum#
                                           @ GHC.Types.Bool
                                           (GHC.Prim.==# ipv1 ipv2) of wild1 {
                                      GHC.Types.False -> lvl11
                                      GHC.Types.True -> lvl12 } } of dt2 { DEFAULT ->
                          Tensor.Restricted.Scalar @ a dt2 } }) }) }) }) -}
9a60f3bad58cfe2251e70a8694edd31f
  $wkr4 ::
    GHC.Num.Num a => GHC.Prim.Int# -> Tensor.Restricted.Tensor a
  {- Arity: 2, Strictness: <L,U(A,A,A,A,A,A,C(U))><S,U>, Inline: [0],
     Unfolding: (\ @ a (w :: GHC.Num.Num a) (ww :: GHC.Prim.Int#) ->
                 case Tensor.Restricted.kr2 of dt1 { DEFAULT ->
                 let {
                   lvl9 :: Tensor.Index.TIndex
                   = case Tensor.Restricted.kr1 of dt2 { DEFAULT ->
                     Tensor.Index.Covariant ww dt2 }
                 } in
                 let {
                   lvl10 :: Tensor.Index.TIndex
                   = case Tensor.Restricted.kr6 of dt2 { DEFAULT ->
                     Tensor.Index.Covariant ww dt2 }
                 } in
                 let {
                   lvl11 :: Tensor.Index.TIndex
                   = case Tensor.Restricted.kr7 of dt2 { DEFAULT ->
                     Tensor.Index.Covariant ww dt2 }
                 } in
                 let {
                   lvl12 :: a
                   = GHC.Num.fromInteger @ a w Tensor.Restricted.$fFloatingTensor8
                 } in
                 let {
                   lvl13 :: a
                   = GHC.Num.fromInteger @ a w Tensor.Restricted.$fFloatingTensor7
                 } in
                 Tensor.Restricted.$fMultilinearTensor_$cgenerate
                   @ a
                   (Tensor.Index.Covariant ww dt1)
                   (\ (i :: GHC.Types.Int) ->
                    case i of i1 { GHC.Types.I# ipv ->
                    Tensor.Restricted.$fMultilinearTensor_$cgenerate
                      @ a
                      lvl9
                      (\ (j :: GHC.Types.Int) ->
                       case j of j1 { GHC.Types.I# ipv1 ->
                       let {
                         lvl14 :: GHC.Types.Bool
                         = GHC.Prim.tagToEnum# @ GHC.Types.Bool (GHC.Prim.==# ipv ipv1)
                       } in
                       Tensor.Restricted.$fMultilinearTensor_$cgenerate
                         @ a
                         lvl10
                         (\ (k :: GHC.Types.Int) ->
                          case k of k1 { GHC.Types.I# ipv2 ->
                          let {
                            lvl15 :: GHC.Types.Bool
                            = GHC.Prim.tagToEnum# @ GHC.Types.Bool (GHC.Prim.==# ipv1 ipv2)
                          } in
                          Tensor.Restricted.$fMultilinearTensor_$cgenerate
                            @ a
                            lvl11
                            (\ (l :: GHC.Types.Int) ->
                             case l of l1 { GHC.Types.I# ipv3 ->
                             case case lvl14 of wild {
                                    GHC.Types.False -> lvl12
                                    GHC.Types.True
                                    -> case lvl15 of wild1 {
                                         GHC.Types.False -> lvl12
                                         GHC.Types.True
                                         -> case GHC.Prim.tagToEnum#
                                                   @ GHC.Types.Bool
                                                   (GHC.Prim.==# ipv2 ipv3) of wild2 {
                                              GHC.Types.False -> lvl12
                                              GHC.Types.True -> lvl13 } } } of dt2 { DEFAULT ->
                             Tensor.Restricted.Scalar @ a dt2 } }) }) }) }) }) -}
d87e154ad7edb21544b399cf1c30a76d
  data Tensor a
    = Scalar {scalarVal :: !a}
    | Tensor {tensorIndex :: !Tensor.Index.TIndex,
              tensorData :: ![Tensor.Restricted.Tensor a]}
    | Err {errMsg :: !GHC.Base.String}
21d0aa482f1c00c21aadf2dae52e4af9
  _dot ::
    GHC.Num.Num a =>
    Tensor.Restricted.Tensor a
    -> Tensor.Restricted.Tensor a -> Tensor.Restricted.Tensor a
  {- Arity: 1, Strictness: <L,U(C(U),A,C(U),A,A,A,C(U))> -}
d87e154ad7edb21544b399cf1c30a76d
  commonIndex ::
    Tensor.Restricted.Tensor a
    -> Tensor.Restricted.Tensor a -> GHC.Base.Maybe GHC.Base.String
  {- Arity: 2, Strictness: <S,1*U><S,1*U>,
     Unfolding: (\ @ a
                   (t1 :: Tensor.Restricted.Tensor a)
                   (t2 :: Tensor.Restricted.Tensor a) ->
                 case t1 of wild {
                   DEFAULT
                   -> case t2 of t4 { DEFAULT -> GHC.Base.Nothing @ GHC.Base.String }
                   Tensor.Restricted.Tensor ds2 ds3
                   -> case t2 of wild1 {
                        DEFAULT -> GHC.Base.Nothing @ GHC.Base.String
                        Tensor.Restricted.Tensor ds4 ds5
                        -> case GHC.Base.map
                                  @ Tensor.Index.TIndex
                                  @ [GHC.Types.Char]
                                  Tensor.Index.indexName
                                  (Tensor.Restricted.commonIndex1
                                     @ a
                                     wild1) of indicesNames2 { DEFAULT ->
                           case GHC.Base.map
                                  @ Tensor.Index.TIndex
                                  @ [GHC.Types.Char]
                                  Tensor.Index.indexName
                                  (Tensor.Restricted.commonIndex1
                                     @ a
                                     wild) of indicesNames1 { DEFAULT ->
                           letrec {
                             go2 :: [[GHC.Types.Char]] -> GHC.Base.Maybe GHC.Base.String
                               {- Arity: 1, Strictness: <S,1*U> -}
                             = \ (ds6 :: [[GHC.Types.Char]]) ->
                               case ds6 of wild2 {
                                 [] -> GHC.Base.Nothing @ GHC.Base.String
                                 : y ys
                                 -> case y of i { DEFAULT ->
                                    letrec {
                                      go3 :: [GHC.Base.String] -> Data.Monoid.First GHC.Base.String
                                        {- Arity: 1, Strictness: <S,1*U> -}
                                      = \ (ds7 :: [GHC.Base.String]) ->
                                        case ds7 of wild3 {
                                          []
                                          -> (GHC.Base.Nothing @ GHC.Base.String)
                                               `cast`
                                             (Sym (Data.Monoid.N:First[0]) <GHC.Base.String>_N)
                                          : y1 ys1
                                          -> case GHC.Base.eqString y1 i of wild4 {
                                               GHC.Types.False -> go3 ys1
                                               GHC.Types.True
                                               -> (GHC.Base.Just @ GHC.Base.String y1)
                                                    `cast`
                                                  (Sym (Data.Monoid.N:First[0]) <GHC.Base.String>_N) } }
                                    } in
                                    case (go3 indicesNames2)
                                           `cast`
                                         (Data.Monoid.N:First[0] <GHC.Base.String>_N) of wild3 {
                                      GHC.Base.Nothing -> go2 ys GHC.Base.Just ipv -> wild3 } } }
                           } in
                           go2 indicesNames1 } } } }) -}
d87e154ad7edb21544b399cf1c30a76d
  commonIndex1 :: Tensor.Restricted.Tensor a -> [Tensor.Index.TIndex]
  {- Arity: 1, Strictness: <S,1*U> -}
046cc338a19d2df1d9638f5fc8789301
  errMsg :: Tensor.Restricted.Tensor a -> GHC.Base.String
  RecSel Left Tensor.Restricted.Tensor
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ @ a (ds2 :: Tensor.Restricted.Tensor a) ->
                 case ds2 of wild {
                   DEFAULT -> Tensor.Restricted.errMsg1
                   Tensor.Restricted.Err ds3 -> ds3 }) -}
bd06f5a5b35fc5a1b598f9ba8378897f
  errMsg1 :: GHC.Base.String
  {- Strictness: x -}
be51dca50293e7c5643202f3953a434b
  indexOutOfRange :: GHC.Base.String
  {- Unfolding: (GHC.CString.unpackCString#
                   "Index out of range!"#) -}
541a631b8027dd31de748fa743eb8ef7
  kr :: GHC.Num.Num a => GHC.Types.Int -> Tensor.Restricted.Tensor a
  {- Arity: 2, Strictness: <L,U(A,A,A,A,A,A,C(U))><S(S),1*U(U)>,
     Inline: INLINE[0],
     Unfolding: InlineRule (2, True, False)
                (\ @ a (w :: GHC.Num.Num a) (w1 :: GHC.Types.Int) ->
                 case w1 of ww { GHC.Types.I# ww1 ->
                 Tensor.Restricted.$wkr @ a w ww1 }) -}
85b94bbbcf191d6f79043c910d319ab9
  kr1 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "j"#) -}
41781ed600b663f83d7d9e7261833f1b
  kr2 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "i"#) -}
3e7f9d72e399a65ba83efe88684b7b13
  kr3 :: GHC.Num.Num a => GHC.Types.Int -> Tensor.Restricted.Tensor a
  {- Arity: 2, Strictness: <L,U(A,A,A,A,A,A,C(U))><S(S),1*U(U)>,
     Inline: INLINE[0],
     Unfolding: InlineRule (2, True, False)
                (\ @ a (w :: GHC.Num.Num a) (w1 :: GHC.Types.Int) ->
                 case w1 of ww { GHC.Types.I# ww1 ->
                 Tensor.Restricted.$wkr3 @ a w ww1 }) -}
a779532632ae381684a219c2f37ef0f7
  kr4 :: GHC.Num.Num a => GHC.Types.Int -> Tensor.Restricted.Tensor a
  {- Arity: 2, Strictness: <L,U(A,A,A,A,A,A,C(U))><S(S),1*U(U)>,
     Inline: INLINE[0],
     Unfolding: InlineRule (2, True, False)
                (\ @ a (w :: GHC.Num.Num a) (w1 :: GHC.Types.Int) ->
                 case w1 of ww { GHC.Types.I# ww1 ->
                 Tensor.Restricted.$wkr4 @ a w ww1 }) -}
1a716c33b96568ce7528e4359edff889
  kr6 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "k"#) -}
0d15a972cb508b1a6a767c91cdb1f915
  kr7 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "l"#) -}
31f3aad378d31d643093a5fc9cad3bf4
  scalarVal :: Tensor.Restricted.Tensor a -> a
  RecSel Left Tensor.Restricted.Tensor
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ @ a (ds2 :: Tensor.Restricted.Tensor a) ->
                 case ds2 of wild {
                   DEFAULT -> Tensor.Restricted.scalarVal1 @ a
                   Tensor.Restricted.Scalar ds3 -> ds3 }) -}
56135c0a2d1b5b01d1f9bcc68785fa5b
  scalarVal1 :: a
  {- Strictness: x -}
ff9af7a484dd83133475eea35895113e
  switchInd ::
    Tensor.Restricted.Tensor a
    -> GHC.Base.Maybe GHC.Base.String -> Tensor.Restricted.Tensor a
  {- Arity: 2, Strictness: <S,1*U><S,1*U> -}
d87e154ad7edb21544b399cf1c30a76d
  switchInd' ::
    Tensor.Restricted.Tensor a
    -> GHC.Base.Maybe GHC.Base.String -> Tensor.Restricted.Tensor a
  {- Arity: 2, Strictness: <S,1*U><S,1*U> -}
7ac99451781b4e47a785f6bb0a9dc8af
  tensorData ::
    Tensor.Restricted.Tensor a -> [Tensor.Restricted.Tensor a]
  RecSel Left Tensor.Restricted.Tensor
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ @ a (ds2 :: Tensor.Restricted.Tensor a) ->
                 case ds2 of wild {
                   DEFAULT -> Tensor.Restricted.tensorData1 @ a
                   Tensor.Restricted.Tensor ds3 ds4 -> ds4 }) -}
8141079082c9d755a63e14ebeec5b10d
  tensorData1 :: [Tensor.Restricted.Tensor a]
  {- Strictness: x -}
3eef713cf9ba7d6985f0ca0f97659d32
  tensorIndex :: Tensor.Restricted.Tensor a -> Tensor.Index.TIndex
  RecSel Left Tensor.Restricted.Tensor
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ @ a (ds2 :: Tensor.Restricted.Tensor a) ->
                 case ds2 of wild {
                   DEFAULT -> Tensor.Restricted.tensorIndex1
                   Tensor.Restricted.Tensor ds3 ds4 -> ds3 }) -}
616403d3cb16b31662f9d36702ac2884
  tensorIndex1 :: Tensor.Index.TIndex
  {- Strictness: x -}
instance [safe] Data.Binary.Class.Binary [Tensor.Restricted.Tensor]
  = Tensor.Restricted.$fBinaryTensor
instance [safe] GHC.Classes.Eq [Tensor.Restricted.Tensor]
  = Tensor.Restricted.$fEqTensor
instance [safe] GHC.Float.Floating [Tensor.Restricted.Tensor]
  = Tensor.Restricted.$fFloatingTensor
instance [safe] GHC.Real.Fractional [Tensor.Restricted.Tensor]
  = Tensor.Restricted.$fFractionalTensor
instance [safe] GHC.Base.Functor [Tensor.Restricted.Tensor]
  = Tensor.Restricted.$fFunctorTensor
instance [safe] Tensor.Multilinear.Multilinear [Tensor.Restricted.Tensor]
  = Tensor.Restricted.$fMultilinearTensor
instance [safe] GHC.Num.Num [Tensor.Restricted.Tensor]
  = Tensor.Restricted.$fNumTensor
instance [safe] GHC.Show.Show [Tensor.Restricted.Tensor]
  = Tensor.Restricted.$fShowTensor
"SPEC/Tensor.Restricted $dm!==! @ Tensor" [ALWAYS] forall ($dMultilinear :: Tensor.Multilinear.Multilinear
                                                                              Tensor.Restricted.Tensor)
  Tensor.Multilinear.$dm!==! @ Tensor.Restricted.Tensor $dMultilinear
  = Tensor.Restricted.$fMultilinearTensor_$s$dm!==!
vectorised variables:
vectorised tycons:
vectorised reused tycons:
parallel variables:
parallel tycons:
trusted: safe
require own pkg trusted: False

